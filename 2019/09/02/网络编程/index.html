<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Xiaoqiang's Blog##,如：Charles·Zheng's blog."><meta name="keywords" content="个人博客, java, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/blog/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/blog/favicon.ico"><link rel="bookmark" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/blog/atom.xml"><title>网络编程 | 陌染殇雪</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">网络编程</h1><a id="logo" href="/blog/.">陌染殇雪</a><p class="description">命运不会亏待正在努力变好的你.</p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">网络编程</h1><div class="post-meta"><a href="/blog/2019/09/02/网络编程/#comments" class="comment-count"></a><p><span class="date">Sep 02, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p><a href="https://www.cnblogs.com/midiyu/p/7875574.html**‘" target="_blank" rel="noopener">https://www.cnblogs.com/midiyu/p/7875574.html**‘</a>**</p>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h3><p>计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。网络编程就就是编写程序使联网的两个(或多个)设备(例如计算机)之间进行数据传输。Java语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便地进行网络编程。下面先对网络编程的一些基础知识进行介绍，最后给出使用Java语言进行网络编程的实例。</p>
<h3 id="二、计算机网络"><a href="#二、计算机网络" class="headerlink" title="二、计算机网络"></a><strong>二、计算机网络</strong></h3><p>计算机网络20世纪60年代出现，经历了20世纪70年代、80年代和90年代的发展，进入21世纪后，计算机网络已经成为信息社会的基础设施，深入到人类社会的方方面面，与人们的工作、学习和生活息息相关。</p>
<p><strong>网络协议</strong></p>
<p>如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的规则，即网络协议。</p>
<p><strong>网络体系结构</strong></p>
<p>计算机网络是个复杂的系统，按照人们解决复杂问题的方法，把计算机网络实现的功能分到不同的层次上，层与层之间用接口连接。通信的双方具有相同的层次，层次实现的功能由协议数据单元(PDU)来描述。不同系统中的同一层构成对等层，对等层之间通过对等层协议进行通信，理解彼此定义好的规则和约定。</p>
<p>计算机网络体系结构是计算机网络层次和协议的集合，网络体系结构对计算机网络实现的功能，以及网络协议、层次、接口和服务进行了描述，但并不涉及具体的实现。接口是同一节点内相邻层之间交换信息的连接处，也叫服务访问点(SAP)。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/05b22ea2944e4ef986677c8d029a8046/d16a7b653a66.png" alt="img"></p>
<p>计算机网络层次模型</p>
<h3 id="三、OSI参考模型"><a href="#三、OSI参考模型" class="headerlink" title="三、OSI参考模型"></a><strong>三、OSI参考模型</strong></h3><p>前面我们介绍了计算机网络的体系结构，因为计算机网络是个复杂的系统，所以把计算机网络实现的功能分到不同的层次上，而计算机网络体系结构是计算机网络层次和协议的集合。那么，计算机网络如何进行分层呢？下面先介绍的是OSI参考模型。</p>
<p>OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/586a1e872e0f499c94037fd2c6fe4ea4/9d383354abe1.png" alt="img"></p>
<p>OSI参考模型的7个层次</p>
<p>OSI模型层次功能</p>
<ul>
<li><strong>物理层</strong></li>
</ul>
<p>物理层处于OSI的最底层，是整个开放系统的基础。物理层涉及通信信道上传输的原始比特流(bits)，它的功能主要是为数据端设备提供传送数据的通路以及传输数据。</p>
<ul>
<li><strong>数据链路层</strong></li>
</ul>
<p>数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，把原始的、有差错的物理传输线路加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。</p>
<ul>
<li><strong>网络层</strong></li>
</ul>
<p>网络层涉及源主机节点到目的主机节点之间可靠的网络传输，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互连等。</p>
<ul>
<li><strong>传输层</strong></li>
</ul>
<p>传输层起着承上启下的作用，涉及源端节点到目的端节点之间可靠的信息传输。传输层需要解决跨越网络连接的建立和释放，对底层不可靠的网络，建立连接时需要三次握手，释放连接时需要四次挥手。</p>
<ul>
<li><strong>会话层和表示层</strong></li>
</ul>
<p>会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信。</p>
<p>表示层关心所传输数据信息的格式定义，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。</p>
<ul>
<li><strong>应用层</strong></li>
</ul>
<p>应用层为OSI的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。</p>
<h3 id="四、TCP-IP参考模型"><a href="#四、TCP-IP参考模型" class="headerlink" title="四、TCP/IP参考模型"></a><strong>四、TCP/IP参考模型</strong></h3><p>OSI参考模型的初衷是提供全世界范围的计算机网络都要遵循的统一标准，但是由于存在模型和协议自身的缺陷，迟迟没有成熟的产品推出。TCP/IP协议在实践中不断完善和发展取得成功，作为网络的基础，Internet的语言，可以说没有TCP/IP协议就没有互联网的今天。</p>
<p>简介</p>
<p>TCP/IP，即Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议、Internet国际互联网络的基础。</p>
<p>TCP/IP协议是一个开放的网络协议簇，它的名字主要取自最重要的网络层IP协议和传输层TCP协议。TCP/IP协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。TCP/IP参考模型采用4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这4个层次分别是：<strong>网络接口层、互联网层(IP层)、传输层(TCP层)、应用层。</strong></p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/aa62eff61037486db833ed6968c0693b/a2f44e2f31dc.png" alt="img"></p>
<p>OSI 和 TCP/IP模型对比</p>
<p>TCP/IP模型层次功能</p>
<ul>
<li><strong>网络接口层</strong></li>
</ul>
<p>TCP/IP协议对网络接口层没有给出具体的描述，网络接口层对应着物理层和数据链路层。</p>
<ul>
<li><strong>互联网层 ( IP层 )</strong></li>
</ul>
<p>互联网层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。互联网层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能。　　</p>
<ul>
<li><strong>传输层 ( TCP层 )</strong></li>
</ul>
<p>TCP层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP层涉及两个协议，TCP和UDP。其中，TCP协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。</p>
<ul>
<li><strong>应用层</strong></li>
</ul>
<p>应用层为Internet中的各种网络应用提供服务。</p>
<h3 id="五、常见网络协议"><a href="#五、常见网络协议" class="headerlink" title="五、常见网络协议"></a><strong>五、常见网络协议</strong></h3><p>上面主要介绍了OSI参考模型和TCP/IP模型的相关内容，从下面这张图可以看出TCP/IP协议簇中不同的层次中有着很多不同的网络协议，下面主要介绍传输层的TCP、UDP协议和应用层的HTTP协议。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/3b6ffabd1cf64273a874544c8e13598d/80336d0431cf.png" alt="img"></p>
<p>TCP协议</p>
<ul>
<li><strong>简介</strong></li>
</ul>
<p>TCP（Transmission Control Protocol ，传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。TCP协议采用字节流传输数据。</p>
<ul>
<li><strong>TCP报文段格式</strong></li>
</ul>
<p>TCP报文段包括协议首部和数据两部分，协议首部的固定部分有20个字节，首部的固定部分后面是选项部分。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/fc14ded2449a448eb5d1b18cbef7d6f4/95be64863fcf.png" alt="img"></p>
<p>TCP报文段</p>
<p>下面是报文段首部各个字段的含义。</p>
<ol>
<li>源端口号以及目的端口号，各占2个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和IP地址，可以唯一确定一个TCP连接，在网络编程中，通常被称为一个socket接口。</li>
<li>序号（seq），占4字节，用来标识从TCP发送端向TCP接收端发送的数据字节流。</li>
<li>确认序号（ack），占4字节，包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已经成功收到数据字节序号加1.</li>
<li>数据偏移，占4位，用于指出TCP首部长度，若不存在选项，则这个值为20字节，数据偏移的最大值为60字节。</li>
<li>保留字段占6位，暂时可忽略，值全为0</li>
<li>标志位</li>
</ol>
<p>URG（紧急） : 为1时表明紧急指针字段有效</p>
<p><strong>ACK（确认）：为1时表明确认号字段有效</strong></p>
<p>PSH（推送）：为1时接收方应尽快将这个报文段交给应用层</p>
<p>RST（复位）：为1时表明TCP连接出现故障必须重建连接</p>
<p><strong>SYN（同步）：在连接建立时用来同步序号</strong></p>
<p><strong>FIN （终止）： 为1时表明发送端数据发送完毕要求释放连接</strong></p>
<ol>
<li>接收窗口占2个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。</li>
<li>校验和占2个字节，范围包括首部和数据两部分。</li>
<li>选项是可选的，默认情况是不选。</li>
</ol>
<ul>
<li><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a><strong>三次握手与四次挥手</strong></h3></li>
</ul>
<p>TCP是面向连接的协议，因此每个TCP连接都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”。</p>
<p>TCP三次握手过程如下：</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/b11b3a90e24a4d649c8a54fe75620757/6778bea8db9.jpeg" alt="img"></p>
<ol>
<li>第一次握手</li>
</ol>
<p>客户机发送<strong>连接请求报文段</strong>到服务器，并进入<strong>SYN_SENT</strong>状态，等待服务器确认。（SYN = 1,seq=x）</p>
<ol start="2">
<li>第二次握手</li>
</ol>
<p>服务器收到连接请求报文，如果同意建立连接，向客户机发回<strong>确认报文段</strong>，并为该TCP连接分配TCP缓存和变量。(SYN=1,ACK=1,seq=y,ack=x+1)。</p>
<ol start="3">
<li>第三次握手</li>
</ol>
<p>客户机收到服务器的确认报文段后，向服务器给出<strong>确认报文段</strong>，并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入<strong>ESTABLISHED</strong>（建立）（TCP连接成功）状态，完成三次握手。(ACK=1,seq=x+1,ack=y+1)。</p>
<h3 id="TCP四次挥手过程如下："><a href="#TCP四次挥手过程如下：" class="headerlink" title="TCP四次挥手过程如下："></a>TCP四次挥手过程如下：</h3><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/4af101455d874f15b0c5b36f24d4b1ae/8315648d177e.png" alt="img"></p>
<p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是<strong>当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。</strong>收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li>TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。（FIN = 1，seq = u）</li>
<li>服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。（ACK = 1，seq = v ，ack= u + 1）</li>
<li>服务器关闭客户端的连接，发送一个FIN给客户端。（FIN = 1，ACK = 1，seq = w ，ack = u + 1 ）</li>
<li>客户端发回ACK报文确认，并将确认序号设置为收到序号加1。（ACK = 1，seq = u + 1，ack = w+ 1 ）</li>
</ol>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><ul>
<li><strong>简介</strong></li>
</ul>
<p>UDP，用户数据报协议，英文全称是User Datagram Protocol，它是TCP/IP协议簇中无连接的运输层协议。</p>
<ul>
<li><strong>UDP协议格式</strong></li>
</ul>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/0ce46cc136574d87a0b9cea1123fec8c/05c373a98eb2.png" alt="img"></p>
<p>UDP格式</p>
<p>从图中可以看到，UDP协议十分简单，它由两部分组成：首部和数据。其中，首部仅有8个字节，包括源端口和目的端口，长度（UDP用于数据报的长度）、校验和。</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><ul>
<li><strong>简介</strong></li>
</ul>
<p>HTTP，超文本传输协议，英文全称是Hypertext Transfer Protocol，它是互联网上应用最为广泛的一种网络协议。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。HTTP协议默认的端口号为80.</p>
<p>现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP运输层协议建立起来的连接，使客户机和服务器可以继续在这条连接上传输HTTP报文。</p>
<p>是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入”Connection:Keep-Alive”，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入”Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。</p>
<ul>
<li><strong>HTTP报文</strong></li>
</ul>
<p>HTTP协议是基于TCP协议之上的请求/响应式协议，下面主要介绍HTTP报文的格式，HTTP报文主要有请求报文和响应报文两种。首先看请求报文的格式：</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/01fdde7e3de1449ba119436d48a1a1b5/fc06cc0455a8.png" alt="img"></p>
<p>HTTP请求报文格式</p>
<p>HTTP请求报文由<strong>请求行、首部行和实体主体</strong>组成，由浏览器发送给服务器。上面这张图中SP表示空格，cr lf表示回车和换行。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/4d2a96e2fed04493afbdc251a3af427d/cd5d58e6ccbc.png" alt="img"></p>
<p>HTTP响应报文格式</p>
<p>上面这张图是HTTP响应报文，它由状态行、首部行和实体主体组成。下面两张图是在谷歌浏览器内访问服务器查看的HTTP请求和响应。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/75a40bc2f98a4b3f9de2122bdff2846e/995e9be5c7a8.png" alt="img"></p>
<p>HTTP请求报文例子</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/37f47e72f0ed49a3ab115d5d9b4eb863/1e413bdf79de.png" alt="img"></p>
<p>HTTP响应报文例子</p>
<ul>
<li><strong>HTTP请求方法和响应状态码</strong></li>
</ul>
<p>在上面的HTTP请求报文例子中，我们可以看到请求方法是GET，这表示请求读取由URL所标志的信息，除了GET，还有其它几种常用的方法。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/b6d1d7170f594307bc18c310f6ce8127/dcc5013da14a.png" alt="img"></p>
<p>HTTP请求报文的一些方法</p>
<p>在HTTP响应报文的例子中，我们可以看到状态码是200，表示响应成功。下表是其它状态码，总共5大类，33种。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/eb22239cdac345f786250d41f46feab0/8a134314eeb0.png" alt="img"></p>
<h4 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h4><p>HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。</p>
<p>超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，<strong>SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</strong></p>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<p>1、https协议需要到ca申请证书，一般免费证书很少，需要交费。</p>
<p>2、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p><strong>六、常见问题</strong></p>
<p>到这里，关于计算机网络部分的总结内容就结束了，下面是几个常见的问题，汇总在这里。</p>
<ul>
<li>OSI参考模型的分为哪几层，每层的功能？</li>
</ul>
<p>OSI，开放系统互连参考模型，它的7个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。各层的功能见文章开始。</p>
<ul>
<li>TCP协议和UDP协议的区别？</li>
</ul>
<p>TCP协议是传输控制协议，UDP协议是用户数据报协议，两者都是传输层的协议，主要区别在于<strong>前者是可靠的，面向连接的协议，后者是不可靠的，无连接的协议</strong>。其它的区别还有，TCP协议传输速度慢，UDP常用于一次性传输比较少量数据的网络应用。</p>
<ul>
<li><strong>TCP三次握手为什么不能是两次?</strong></li>
</ul>
<p>主要是防止两次握手情况下已经失效的连接请求报文段突然又传送到服务端而产生错误。例如，客户机A向服务器B发送TCP连接请求，第一个连接请求报文在网络的某个节点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接，而这时之前滞留的连接请求到达了服务端B，而B认为A又发来连接请求。如果两次握手建立连接，A并无连接请求，造成B的资源浪费。</p>
<ul>
<li>HTTP请求的GET方法和POST方法的区别？</li>
</ul>
<p>GET和POST是HTTP请求的两种方法，主要区别在于GET方法是请求读取由URL所标志的信息，POST是给服务器添加信息。<a href="http://kb.cnblogs.com/page/188928/" target="_blank" rel="noopener">点击查看更多</a></p>
<ul>
<li>在浏览器中输入网址到显示出页面的整个过程？</li>
</ul>
<p>(1) 输出包含域名的网址</p>
<p> (2) 浏览器向DNS请求解析域名对应的IP地址</p>
<p> (3) 域名系统DNS解析出域名对应的IP地址 </p>
<p>(4) 浏览器与该服务器建立TCP连接 </p>
<p>  (5) 浏览器发送HTTP请求 </p>
<p>(6) 服务器通过HTTP响应把页面文件发送给浏览器 </p>
<p>(7) TCP连接释放 (8) 浏览器解释文件，并显示</p>
<h3 id="七、Java网络编程"><a href="#七、Java网络编程" class="headerlink" title="*七、Java网络编程  *"></a>*<em>七、Java网络编程  *</em></h3><p>Java的网络编程主要涉及到的内容是Socket编程，那么什么是Socket呢？简单地说，Socket，套接字，就是两台主机之间逻辑连接的端点。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。Socket，本质上就是一组接口，是对TCP/IP协议的封装和应用(程序员层面上)。</p>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>Socket编程主要涉及到客户端和服务器端两个方面，首先是在服务器端创建一个<strong>服务器套接字(ServerSocket)</strong>，<strong>并把它附加到一个端口上，服务器从这个端口监听连接</strong>。端口号的范围是0到65536，但是0到1024是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。</p>
<p>客户端请求与服务器进行连接的时候，根据服务器的域名或者IP地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/5b24a40f4c66499ab4e7f2c5c6f9b5a1/da391807643e.png" alt="img"></p>
<p>实例一</p>
<p>下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端，通过这个例子可以初步对Socket编程有个把握。</p>
<ul>
<li><strong>服务器端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 端口号</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7000</span>;</span><br><span class="line">        <span class="comment">// 在端口上创建一个服务器套接字</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// 监听来自客户端的连接</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> length = dis.readDouble();</span><br><span class="line">            System.out.println(<span class="string">"服务器端收到的边长数据为："</span> + length);</span><br><span class="line">            <span class="keyword">double</span> result = length * length;</span><br><span class="line">            dos.writeDouble(result);</span><br><span class="line">            dos.flush();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (dis.readInt() != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7000</span>;</span><br><span class="line"></span><br><span class="line">        String host = <span class="string">"localhost"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个套接字并将其连接到指定端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line"></span><br><span class="line">        DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"请输入正方形的边长:"</span>);</span><br><span class="line">            <span class="keyword">double</span> length = sc.nextDouble();</span><br><span class="line"></span><br><span class="line">            dos.writeDouble(length);</span><br><span class="line">            dos.flush();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">double</span> area = dis.readDouble();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"服务器返回的计算面积为:"</span> + area);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"继续计算？(Y/N)"</span>);</span><br><span class="line"></span><br><span class="line">                String str = sc.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (str.equalsIgnoreCase(<span class="string">"N"</span>)) &#123;</span><br><span class="line">                    dos.writeInt(<span class="number">0</span>);</span><br><span class="line">                    dos.flush();</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.equalsIgnoreCase(<span class="string">"Y"</span>)) &#123;</span><br><span class="line">                    dos.writeInt(<span class="number">1</span>);</span><br><span class="line">                    dos.flush();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例二</p>
<p>可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServerM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">7000</span>;</span><br><span class="line">        <span class="keyword">int</span> clientNo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                exec.execute(<span class="keyword">new</span> SingleServer(socket, clientNo));</span><br><span class="line">                clientNo++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> clientNo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingleServer</span><span class="params">(Socket socket, <span class="keyword">int</span> clientNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.clientNo = clientNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            DataInputStream dis = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedInputStream(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">            DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">double</span> length = dis.readDouble();</span><br><span class="line">                System.out.println(<span class="string">"从客户端"</span> + clientNo + <span class="string">"接收到的边长数据为："</span> + length);</span><br><span class="line">                <span class="keyword">double</span> result = length * length;</span><br><span class="line">                dos.writeDouble(result);</span><br><span class="line">                dos.flush();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">while</span> (dis.readInt() != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"与客户端"</span> + clientNo + <span class="string">"通信结束"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面改进后的服务器端代码可以支持不断地并发响应网络中的客户请求。关键的地方在于多线程机制的运用，同时利用线程池可以改善服务器程序的性能。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: xiaoqiang</p><p>原文链接: <a href="http://cxqiang.gitee.io/blog/2019/09/02/网络编程/">http://cxqiang.gitee.io/blog/2019/09/02/网络编程/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/blog/tags/Java高级/">Java高级</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/blog/2019/09/03/数据类型/" class="pre">数据类型</a><a href="/blog/2019/09/02/反射/" class="next">反射</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、概述"><span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、计算机网络"><span class="toc-text">二、计算机网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、OSI参考模型"><span class="toc-text">三、OSI参考模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、TCP-IP参考模型"><span class="toc-text">四、TCP/IP参考模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、常见网络协议"><span class="toc-text">五、常见网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手与四次挥手"><span class="toc-text">三次握手与四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP四次挥手过程如下："><span class="toc-text">TCP四次挥手过程如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP协议"><span class="toc-text">UDP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP协议"><span class="toc-text">HTTP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS和HTTP的区别"><span class="toc-text">HTTPS和HTTP的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、Java网络编程"><span class="toc-text">*七、Java网络编程  *</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#整体流程"><span class="toc-text">整体流程</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/TreeSet/">TreeSet</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/Vector/">Vector</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/HashSet/">HashSet</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/TreeMap/">TreeMap</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/ComcurrentHashMap2/">ComcurrentHashMap(JDK8)</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/ComcurrentHashMap/">ComcurrentHashMap(JDK1.7)</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/04/LinkedHashMap/">LinkedHashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/03/HashMap2/">HashMap2</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/03/HashMap/">HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/03/LinkedList/">LinkedList</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/容器/" style="font-size: 15px;">容器</a> <a href="/blog/tags/常用类/" style="font-size: 15px;">常用类</a> <a href="/blog/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/blog/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/blog/tags/关键字/" style="font-size: 15px;">关键字</a> <a href="/blog/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/blog/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/blog/tags/面向对象/" style="font-size: 15px;">面向对象</a> <a href="/blog/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/blog/tags/Java高级/" style="font-size: 15px;">Java高级</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/blog/baidusitemap.xml">网站地图</a> |  <a href="/blog/atom.xml">订阅本站</a> |  <a href="/blog/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/blog/." rel="nofollow">xiaoqiang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/blog/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/blog/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/blog/share/css/share.css"><script type="text/javascript" src="/blog/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/blog/share/js/qrcode.js" charset="utf-8"></script></body></html>