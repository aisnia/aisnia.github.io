<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Xiaoqiang's Blog##,如：Charles·Zheng's blog."><meta name="keywords" content="个人博客, java, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/blog/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/blog/favicon.ico"><link rel="bookmark" href="/blog/favicon.ico"><link rel="apple-touch-icon" href="/blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/blog/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/blog/atom.xml"><title>并发常见用语 | 陌染殇雪</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">并发常见用语</h1><a id="logo" href="/blog/.">陌染殇雪</a><p class="description">命运不会亏待正在努力变好的你.</p></div><div id="nav-menu"><a href="/blog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/blog/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">并发常见用语</h1><div class="post-meta"><a href="/blog/2019/09/06/并发常见用语/#comments" class="comment-count"></a><p><span class="date">Sep 06, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="1、同步和异步"><a href="#1、同步和异步" class="headerlink" title="1、同步和异步"></a><strong>1、同步和异步</strong></h3><p>同步和异步通常是用来形容一次方法的调用</p>
<p>同步的方法一旦被调用，必须等待调用的返回，才能进行后续的行为</p>
<p>异步方法更像一个消息的传递，一旦开始，方法会立即返回，可以做其他的事情，而另一个线程就正在执行这个方法，不会阻碍继续后续的执行</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/fc509607cc3a4abe92b8ab867c7ecddf/clipboard.png" alt="img"></p>
<p>打个比方，你去超市购物，买一个空调，当你下了单，催促着售货员帮你送回家，直到商家把你和空调一起送回家，中间你只能在那等着，这就是同步</p>
<p>如果你是在家网购的话，只需要在网上下个单支付完后，这时对于你来说购物已经结束了，虽然空调还未到家，但是你的任务已经完成了，商家的出货配送已经与你没有关系，这段时你想干嘛就干嘛做自己的事情，等送货上门时，只需要签收就行</p>
<h3 id="2、并行与并发"><a href="#2、并行与并发" class="headerlink" title="2、并行与并发"></a><strong>2、并行与并发</strong></h3><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/dba41f40ef574fb88787ca4a1ed43d72/clipboard.png" alt="img"></p>
<p>并行是真正意义上的同时执行，即多个线程在同一时刻同时执行某一任务</p>
<p><strong>并发是交替的执行，</strong></p>
<h3 id="3、临界区"><a href="#3、临界区" class="headerlink" title="3、临界区"></a><strong>3、临界区</strong></h3><p>临界区用来表示一种公共资源或者说是共享的数据，它可以被多个线程使用，但每一次，只有一个线程使用它，一旦临界区资源被占用，其他线程想要使用这个资源没救必须等待</p>
<h3 id="4、阻塞-Blocking-和非阻塞-Non-Blocking"><a href="#4、阻塞-Blocking-和非阻塞-Non-Blocking" class="headerlink" title="4、阻塞(Blocking)和非阻塞(Non-Blocking)"></a><strong>4、阻塞(Blocking)和非阻塞(Non-Blocking)</strong></h3><p>阻塞和非阻塞是形容多线程之间的相互影响</p>
<p>阻塞：比如一个线程占用了临界区的资源，那么另一个请求这个资源的线程就必须等待，而导致线程的挂起</p>
<p>非阻塞：强调没有一个线程可以妨碍其他线程的执行，所有的线程都会尝试不断的向前执行</p>
<h3 id="5、死锁-DeadLock-，饥饿-Starvation-，活锁-Livelock"><a href="#5、死锁-DeadLock-，饥饿-Starvation-，活锁-Livelock" class="headerlink" title="5、死锁(DeadLock)，饥饿(Starvation)，活锁(Livelock)"></a><strong>5、死锁(DeadLock)，饥饿(Starvation)，活锁(Livelock)</strong></h3><ul>
<li><p><strong>死锁</strong>：当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p>
</li>
<li><p><strong>饥饿</strong>：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果<strong>优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行</strong>，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。</p>
</li>
<li><p><strong>活锁</strong>：活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。比如生活中的让路，你向左，它向右有碰到一起了</p>
</li>
<li><p><strong>无锁</strong>：即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过JDK的CAS原理及应用即是无锁的实现。</p>
</li>
</ul>
<h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a><strong>并发级别</strong></h3><p><strong>1、阻塞(Blocking)</strong></p>
<p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行，当用sychronized 关键字 或者 重入锁，会有线程阻塞</p>
<p><strong>2、无饥饿(Starvation-Free)</strong></p>
<p>线程是公平的，没有优先级的比较，所有线程想要获取资源机会是一样的，这个取决于线程之间是否有优先级的存在，如果系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。</p>
<p><strong>3、无障碍(Obnstruction-Free)</strong></p>
<p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。换言之，大家都进入临界区了。那么如果一起修改共享数据，把数据改坏了可怎么办呢？<strong>对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。如果说阻塞的控制方式是悲观策略，相对来说非阻塞的调度就是一种乐观的策略。</strong>从这个策略中也可以看到，当临界区中存在严重的冲突时，所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。</p>
<p>一种可行的无障碍实现可以依赖一个“一致性标记”来实现,即版本控制)，比如modCount。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。</p>
<p>Obstruction-free 是指在任何时间点，一个孤立运行线程的每一个操作可以在有限步之内结束。<strong>只要没有竞争，线程就可以持续运行，一旦共享数据被修改，Obstruction-free 要求中止已经完成的部分操作，并进行回滚。</strong></p>
<p><strong>4、无锁（Lock-freedom）</strong></p>
<p>在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够<strong>在有限步内完成操作离开临界区</strong>，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果修改成功，程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程是可以胜出的。至于临界区中竞争失败的线程，它们则不断重试，直到自己获胜。如果总是尝试不成功，则会出现类似饥饿的现象，线程会停止不前。</p>
<p>Lock-freedom 指的是<strong>整个系统作为一个整体一直运行下去</strong>，系统内部单个线程某段时间内可能会饥饿，这是比wait-freedom弱的并发级别，但系统整体上看依然是没有阻塞的。所有wait-free的算法显然都满足lock-free的要求。<strong>Lock-free算法通常可以通过循环+同步原语CAS实现。</strong></p>
<p><strong>5、无等待(Wait-Free)</strong></p>
<p><strong>无锁只要求有一个线程可以在有限步内完成操作</strong>，而无等待则在无锁的基础上更进一步进行扩展。<strong>它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题</strong>。如果限制这个步骤上限，还可以进一步分解为有界无等待和线程数无关的无等待几种，它们之间的区别只是对循环次数的限制不同。</p>
<p>一种典型的无等待结构就是RCU(Read-Copy-Update)。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据(这就是为什么读可以不加控制)，修改完成后，在合适的时机回写数据。</p>
<p><strong>一：原子性(Atomicity)</strong></p>
<p>不可分割，一个操作是不可中断的，一定会执行，</p>
<p>不然int类型赋值和读取操作，当然long和double就不一定了，因为对于32位系统的来说（long和double是64位的）他们的读写不是原子的</p>
<p><strong>二：可见性（Visibility）</strong></p>
<p>可见性是指当一个线程修改了某一个共享的变量，其他线程是否能够立即知道这个修改</p>
<p><strong>三：有序性(Ordering)</strong></p>
<p>就是写在前面的代码，可能会在后面执行</p>
<p>原因是：在程序执行是，可能会进行指令重排，重排后后的指令可能与原来的顺序不一样，下面有个简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=a+<span class="number">1</span>;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入A线程首先执行 writer()方法，紧接着B执行执行reader()方法，加入B执行到了第10行进入了if语句，这时不一定能看到 a已经被赋值为1了，因为可能发生了指令重排，先执行的是 flag=true；这个指令</p>
<p>指令重排不会让逻辑发生变化的，上面两个赋值的操作相互之间没有影响，调换位置也没关系，所有可能发生指令重排序，总之指令重排序的结果是不会改变的</p>
<p><strong>为什么要指令重排？</strong></p>
<p> 主要还是编译器以及CPU为了优化代码或者执行的效率而执行的优化操作；应用条件是单线程场景下，对于并发多线程场景下，指令重排会产生不确定的执行效果。</p>
<p><a href="http://mageek.cn/archives/99/" target="_blank" rel="noopener">http://mageek.cn/archives/99/</a></p>
<p><strong>那些指令不能重排序(happens-before原则（先行发生原则）</strong></p>
<p>1、程序顺序原则：一个线程内保证语义的串行，</p>
<p>2、volatile规则：volatile变量的写，先发生于读，保证了可见性</p>
<p>3、锁规则：解锁必然在加锁前</p>
<p>4：传递性：A先与B。B先于C，A一定先于C</p>
<p>5、线程的start方法，先于它的每一个动作</p>
<p>6、线程的所有操作先于线程的终结</p>
<p>7、线程的中断先于被中断的代码</p>
<p>8、对象的构造函数执行，结束先于先于finalize()</p>
</div><div class="post-copyright"><blockquote><p>原文作者: xiaoqiang</p><p>原文链接: <a href="http://cxqiang.gitee.io/blog/2019/09/06/并发常见用语/">http://cxqiang.gitee.io/blog/2019/09/06/并发常见用语/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/blog/tags/并发/">并发</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/blog/2019/09/06/并发编程基础/" class="pre">并发编程基础</a><a href="/blog/2019/09/06/序列化/" class="next">序列化</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、同步和异步"><span class="toc-text">1、同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、并行与并发"><span class="toc-text">2、并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、临界区"><span class="toc-text">3、临界区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、阻塞-Blocking-和非阻塞-Non-Blocking"><span class="toc-text">4、阻塞(Blocking)和非阻塞(Non-Blocking)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、死锁-DeadLock-，饥饿-Starvation-，活锁-Livelock"><span class="toc-text">5、死锁(DeadLock)，饥饿(Starvation)，活锁(Livelock)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发级别"><span class="toc-text">并发级别</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/JDBC/">JDBC</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/监听器Listener/">监听器Listener</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/过滤器Filter/">过滤器Filter</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/Request与Response/">Request与Response</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/Cookie与Session/">Cookie与Session</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/Servlet/">Servlet</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/10/Web基础/">Web基础</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/07/原子性和CAS算法/">原子性和CAS算法</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/07/volatile/">volatile</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2019/09/07/锁的优化与注意事项/">锁的优化与注意事项</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/blog/tags/关键字/" style="font-size: 15px;">关键字</a> <a href="/blog/tags/容器/" style="font-size: 15px;">容器</a> <a href="/blog/tags/IO/" style="font-size: 15px;">IO</a> <a href="/blog/tags/常用类/" style="font-size: 15px;">常用类</a> <a href="/blog/tags/并发/" style="font-size: 15px;">并发</a> <a href="/blog/tags/Web核心技术/" style="font-size: 15px;">Web核心技术</a> <a href="/blog/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/blog/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/blog/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/blog/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/blog/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/blog/tags/面向对象/" style="font-size: 15px;">面向对象</a> <a href="/blog/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/blog/tags/Java高级/" style="font-size: 15px;">Java高级</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/blog/baidusitemap.xml">网站地图</a> |  <a href="/blog/atom.xml">订阅本站</a> |  <a href="/blog/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/blog/." rel="nofollow">xiaoqiang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/blog/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/blog/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/blog/share/css/share.css"><script type="text/javascript" src="/blog/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/blog/share/js/qrcode.js" charset="utf-8"></script></body></html>