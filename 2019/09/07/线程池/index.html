<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Xiaoqiang's Blog##,如：Charles·Zheng's blog."><meta name="keywords" content="个人博客, java, 后端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>线程池 | 陌染殇雪</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">线程池</h1><a id="logo" href="/.">陌染殇雪</a><p class="description">命运不会亏待正在努力变好的你.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">线程池</h1><div class="post-meta"><a href="/2019/09/07/线程池/#comments" class="comment-count"></a><p><span class="date">Sep 07, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="线程复用：线程池"><a href="#线程复用：线程池" class="headerlink" title="线程复用：线程池"></a><strong>线程复用：线程池</strong></h3><p>在实际的生产环境中，线程的数量必须得到控制，盲目的大量创建线程对系统性能是有伤害的</p>
<h3 id="1、什么是线程池？"><a href="#1、什么是线程池？" class="headerlink" title="1、什么是线程池？"></a><strong>1、什么是线程池？</strong></h3><p>线程池中，总有那么几个活跃的线程，当你需要使用线程时，可以从池子中随便拿一个线程，当完成工作时不必关闭线程，而是将这个线程归还到池子中，回到空闲的状态</p>
<h4 id="JDK对线程池的支持"><a href="#JDK对线程池的支持" class="headerlink" title="JDK对线程池的支持"></a><strong>JDK对线程池的支持</strong></h4><p>架构图</p>
<p>​    <img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/44032e19ad9a4a55873c9395c33e0b2f/clipboard.png" alt="img"></p>
<p>Executor框架提供了各种类型的线程池，主要有以下工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThread)</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个固定线程数量的线程池，该线程池的数量始终不变，当有一个新的任务提交时</span></span><br><span class="line"><span class="comment">    线程池中若有空闲的线程就立即执行，没有则新的任务会放在一个任务队列中，待有空闲</span></span><br><span class="line"><span class="comment">    的线程时在执行*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingelThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个只有一个线程的线程池，若多于一个任务提交到线程池中，任务会保存到一个任务</span></span><br><span class="line"><span class="comment">    队列中，待线程空闲，会按照先入先出的顺序执行队列中的任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个可根据实际情况调整线程数量的线程池，若有空闲的线程，则任务优先分配空闲</span></span><br><span class="line"><span class="comment">    的可复用的线程，否则会创建新的线程处理任务，线程在当前任务完成后，将返回线程池*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个ScheduledExecutorService的线程池 大小为1，在ExecutorService 接口上扩展</span></span><br><span class="line"><span class="comment">    了接受定时执行任务的功能，周期执行*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> nThread)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回ScheduledExecutorService 可指定线程数量的线程池</span></span></span><br></pre></td></tr></table></figure>

<p><strong>计划任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay,</span><br><span class="line">                                    TimeUnit unit);</span><br><span class="line">   <span class="comment">// 给定时间，对任务进行一次调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                            <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                            <span class="keyword">long</span> period,</span><br><span class="line">                                            TimeUnit unit);</span><br><span class="line">       <span class="comment">//创建一个任务，任务开始于给定的初始延迟，后序任务按照周期执行，比如第一个任务</span></span><br><span class="line">       <span class="comment">//将在 initialDelay+period 时执行，而第二个任务将在 initialDelay+2*period</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                <span class="keyword">long</span> delay,</span><br><span class="line">                                                TimeUnit unit)</span><br><span class="line">  <span class="comment">//  创建并执行一个周期性任务，任务开始于初始延迟，第二个任务在第一个任务</span></span><br><span class="line">   <span class="comment">// 执行完成后的delay时间后执行</span></span><br></pre></td></tr></table></figure>

<p><strong>刨根究底：核心线程池的内部实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThread)</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingelThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>三个线程的实现方式其实都是一样的即 返回一个 return new ThreadPoolExecutor(……)对象</p>
<p>其构造方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>其中每个参数的意义</p>
<table>
<thead>
<tr>
<th>corePoolSize</th>
<th>指定线程池中线程的数量</th>
</tr>
</thead>
<tbody><tr>
<td>maximumPoolSize</td>
<td>线程池中最大线程数量</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>当线程池数量超过corePoolSize时，多余线程的存活时间</td>
</tr>
<tr>
<td>unit</td>
<td>keepAliveTime 的时间单位</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列，被提交但尚未被执行的任务</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂，用于创建线程，一般用默认的即可</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略，当任务太多来不及处理，如何拒绝任务</td>
</tr>
</tbody></table>
<h4 id="workQueue-任务队列"><a href="#workQueue-任务队列" class="headerlink" title="workQueue 任务队列"></a><strong>workQueue</strong> 任务队列</h4><p>指被提交但是为执行的任务队列，是一个BlockingQueue对象，只能存放Runnable对象，其中可以使用以下几种对象</p>
<ul>
<li><p>直接提交的队列：该功能有SynchronousQueue 对象提供，它是一个特殊的BlockingQueue，没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待一个插入操作，如果是同SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程则尝试创建新的线程，如果线程数量已经达到了最大值，则执行拒绝策略，因此使用SynchronousQueue 队列，通常设置很大的maximumPoolSize，否则很容易执行拒绝策略。</p>
</li>
<li><p>有界的任务队列：使用ArrayBlockingQueue实现，带有一个容量参数<code>public ArrayBlockingQueue(int capacity)</code>当使用有界的任务队列时，若有新的任务需要执行，如果线程的实际线程数小于corePoolSize，则优先创建新的线程，若大于corePoolSize，则会将新的任务加入到等待队列，若队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务，若大于maximumPoolSize，则执行拒绝策略</p>
</li>
<li><p>无界的任务队列，通过LinkedBlockingQueue类实现的，与有界的队列相比，除非系统的资源耗尽，否则不会出现任务入队失败的情况，当有新的任务来到，系统的线程小于corePoolSize时，线程池会生成新的线程执行任务，若线程数达到corePoolSize时，就不会继续增加，若后续仍有新的任务加入，而有没有空闲的线程，则任务直接加入等待队列，若任务创建和处理的速度相差很大则无界队列会快速增长，直到耗尽系统的内存。</p>
</li>
<li><p>优先任务队列：优先任务队列是带有执行优先级的队列，通过PriorityBlockingQueue实现，可以控制任务的执行先后顺序，它是一特殊的无界队列</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*其中用的是LinkedBlockingQueue队列，corePoolSize和maximumPoolSize相等，无界队列存放无法立即执行的任务</span></span><br><span class="line"><span class="comment">当任务提交非频繁时，改队列会迅速膨胀，从而耗尽系统资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单线程线程池，是newFixedThreadPool的一种简化，将线程数量设置为1了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">corePoolSize为0，最大容量为无限大，这意味着没有任务执行时，改线程内是没有线程的，当任务被提交时，该线程会使用空闲的线程执行任务，</span></span><br><span class="line"><span class="comment">若无空闲的线程，则将任务加入到SynchronousQueue 队列，而SynchronousQueue 队列是一种直接提交的队列，它会迫使线程池增加新的线程</span></span><br><span class="line"><span class="comment">执行任务，当线程执行完毕后，由于corePoolSize为0，因此空闲的线程有会在指定的时间内（60）秒回收</span></span><br><span class="line"><span class="comment">但当有大量的任务被提交时，而任务不能执行太快时，那么系统会开启大量的线程，而使系统的资源消耗过快*/</span></span><br></pre></td></tr></table></figure>

<p><strong>ThreadPoolExecutor 线程池的核心调度代码，冲分体现了上诉线程池的工作逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   <span class="comment">/*分三步进行：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      * 1.如果正在运行少于corePoolSize的线程，请尝试</span></span><br><span class="line"><span class="comment">      *首先使用给定命令启动一个新线程</span></span><br><span class="line"><span class="comment">      *任务。 对addWorker的调用以原子方式检查runState和</span></span><br><span class="line"><span class="comment">      * workerCount，因此可以防止会添加的错误警报</span></span><br><span class="line"><span class="comment">      *线程何时不应该，返回false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      * 2.如果任务可以成功排队，那么我们仍然需要</span></span><br><span class="line"><span class="comment">      *仔细检查我们是否应该添加一个帖子</span></span><br><span class="line"><span class="comment">      *（因为现有的自上次检查后死亡）或那</span></span><br><span class="line"><span class="comment">      *自进入此方法后，池关闭。 所以我们</span></span><br><span class="line"><span class="comment">      *重新检查状态，如有必要，回滚入队if</span></span><br><span class="line"><span class="comment">      *停止，或者如果没有则启动新线程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      * 3.如果我们无法排队任务，那么我们尝试添加新的</span></span><br><span class="line"><span class="comment">      *线程。 如果失败，我们知道我们已关闭或饱和</span></span><br><span class="line"><span class="comment">      *等等拒绝任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码第24行的workerCountOf()函数取得了当前线程池的线程总数，当线程总数小于coreSize时通过addWork()方法直接创建分配线程执行该任务，否则，则会在第29行的 workQueue.offer()</p>
<p>方法进入等待对列，若进入队列失败(比如当有界队列到达上限，或者是直接提交队列SynchronousQueue），则会执行第36行，交给线程池，如果当前线程数达到了max则提交失败，进行37行的拒绝策略，否则分配线程执行任务</p>
<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/ab50147f40b84096bf98a6c3a74e0401/clipboard.png" alt="img"></p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a><strong>拒绝策略</strong></h3><p>ThreadPoolExecutor的最后一个参数RejectedExecutionHandler handler指定了拒绝的策略，拒绝策略可以说是系统超负荷运行时的不就措施通常由于压力太大引起的，也就是线程池中的线程已经用完，同时队列中也已经排满了，再也塞不下新的任务了，我们就需要一套机制，合理的处理这个问题，JDK提供了4中拒绝策略</p>
<ol>
<li><p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常的工作</p>
</li>
<li><p>CallerRunsPolicy策略：只要线程池为关闭，该策略直接在调用者线程中，运行当前被丢弃的任务，显然这样做不会真的丢弃任务，但是任务提交线程的性能可能会急剧下降</p>
</li>
<li><p>DisCardOledestPolicy策略：改策略将丢弃最老的请求，也就是即将被执行的一个任务，并尝试再次提交当前任务</p>
</li>
<li><p>DisCardPolicy策略：改策略默默的丢弃无法处理的任务，不予任何的处理，</p>
</li>
</ol>
<p>以上的策略均实现了 RejectExecutionHandler接口，自定义拒绝策略可以实现这个接口自己扩展</p>
<p>自定义线程池与拒绝策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-10:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="comment">//定义线程池  初始为5个  最大也为5个，最大的等待队列为10个，拒绝策略不做任何处理 就打印一下信息记录或记录日志</span></span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">                <span class="comment">//自定义 线程工厂 在创建后可以设置为 守护线程，还可以记录线程的创建</span></span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">                        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        System.out.println(<span class="string">"create"</span> + t);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        System.out.println(r.toString() + <span class="string">" is discard"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义线程创建"><a href="#自定义线程创建" class="headerlink" title="自定义线程创建"></a><strong>自定义线程创建</strong></h3><p>线程池创建线程是通过 ThreadFactory接口 的 唯一方法 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当线程需要创建线程时就会调用这个方法</p>
<h3 id="线程池扩展"><a href="#线程池扩展" class="headerlink" title="线程池扩展"></a><strong>线程池扩展</strong></h3><p>ThreadPoolExecutor 提供了 beforeExecute() afterExecute() 和 rerminated()三个接口对线程池的控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"正在执行"</span> + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId() + <span class="string">",Task Name="</span> + name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"准备执行"</span>+ ((MyTask)r).name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行完成"</span>+ ((MyTask)r).name);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            MyTask task = <span class="keyword">new</span> MyTask(<span class="string">"Task"</span> + i);</span><br><span class="line">            es.execute(task);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合理的选择：优化线程池线程的数量"><a href="#合理的选择：优化线程池线程的数量" class="headerlink" title="合理的选择：优化线程池线程的数量"></a><strong>合理的选择：优化线程池线程的数量</strong></h3><p>考虑到CPU的数量，内存等因素</p>
<p>堆栈去哪里了：在线程池中寻找堆栈</p>
<p>幽灵版的错误 案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-12:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> re = a / b;</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            es.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打印的是</span><br><span class="line"><span class="number">25.0</span></span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">50.0</span></span><br></pre></td></tr></table></figure>

<p>只有4个结果，使用线程池虽然是一件好事，但还是有坑的，线程池很可能会 <strong>吃掉程序抛出的异常</strong> 导致我们对程序的错误一无所知</p>
<p>没有异常堆栈的信息</p>
<p>改进</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">es.execute(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line"></span><br><span class="line">或者在</span><br><span class="line">Future re=es.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">re.get();</span><br></pre></td></tr></table></figure>

</div><div class="post-copyright"><blockquote><p>原文作者: xiaoqiang</p><p>原文链接: <a href="https://aisnia.github.io/2019/09/07/线程池/">https://aisnia.github.io/2019/09/07/线程池/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/并发/">并发</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/09/07/fork-join框架/" class="pre">fork/join框架</a><a href="/2019/09/07/LockSupport/" class="next">LockSupport</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程复用：线程池"><span class="toc-text">线程复用：线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1、什么是线程池？"><span class="toc-text">1、什么是线程池？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK对线程池的支持"><span class="toc-text">JDK对线程池的支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#workQueue-任务队列"><span class="toc-text">workQueue 任务队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拒绝策略"><span class="toc-text">拒绝策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义线程创建"><span class="toc-text">自定义线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池扩展"><span class="toc-text">线程池扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合理的选择：优化线程池线程的数量"><span class="toc-text">合理的选择：优化线程池线程的数量</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/JDBC/">JDBC</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/监听器Listener/">监听器Listener</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/过滤器Filter/">过滤器Filter</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/Request与Response/">Request与Response</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/Cookie与Session/">Cookie与Session</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/Servlet/">Servlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/10/Web基础/">Web基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/07/原子性和CAS算法/">原子性和CAS算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/07/volatile/">volatile</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/07/锁的优化与注意事项/">锁的优化与注意事项</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/关键字/" style="font-size: 15px;">关键字</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a> <a href="/tags/常用类/" style="font-size: 15px;">常用类</a> <a href="/tags/IO/" style="font-size: 15px;">IO</a> <a href="/tags/并发/" style="font-size: 15px;">并发</a> <a href="/tags/Web核心技术/" style="font-size: 15px;">Web核心技术</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/容器/" style="font-size: 15px;">容器</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/Java基础/" style="font-size: 15px;">Java基础</a> <a href="/tags/面向对象/" style="font-size: 15px;">面向对象</a> <a href="/tags/字符串/" style="font-size: 15px;">字符串</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/Java高级/" style="font-size: 15px;">Java高级</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">xiaoqiang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>