<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌染殇雪</title>
  
  <subtitle>命运不会亏待正在努力变好的你.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://aisnia.github.io/"/>
  <updated>2019-09-10T14:41:41.295Z</updated>
  <id>https://aisnia.github.io/</id>
  
  <author>
    <name>xiaoqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDBC</title>
    <link href="https://aisnia.github.io/2019/09/10/JDBC/"/>
    <id>https://aisnia.github.io/2019/09/10/JDBC/</id>
    <published>2019-09-10T14:38:05.000Z</published>
    <updated>2019-09-10T14:41:41.295Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">测试驱动与数据库建立连接</span><br><span class="line"> *  <span class="number">1</span>:首先要加载数据库的驱动    </span><br><span class="line"> *  方法是调用 Class.forName(<span class="string">"String driverManager"</span>);</span><br><span class="line"> *  其中driverManager是固定的格式</span><br><span class="line"> *  如  MySQL数据库就是  <span class="string">" com.mysql.jdbc.Driver"</span></span><br><span class="line"> *  <span class="number">2</span>:建立连接</span><br><span class="line"> *  String url=<span class="string">"jdbc:mysql://localhost:3306/testjdbc"</span>;   URL   即地址之类的东西</span><br><span class="line"> *      默认的 IP地址             端口             数据库名称</span><br><span class="line"> *  String username=<span class="string">"root"</span>;    用户名</span><br><span class="line"> *  String password = <span class="string">"123456"</span>   密码</span><br><span class="line"> *  调用方法  获得连接对象 conn</span><br><span class="line"> *  Connection con = DriverManager.getConnection(url,username,password);</span><br><span class="line"> *  </span><br><span class="line"> *  DriverManager类的静态方法</span><br><span class="line"> *  getConnection(url,username,password);  获取数据库连接的对象</span><br><span class="line"> *  </span><br><span class="line"> *  Connections代表与数据库的 连接</span><br><span class="line"> *  之类有</span><br><span class="line"> *  Statement 向数据库 传递sql语句的连接对象   </span><br><span class="line"> *  PreparedStatement 是有预编译空能   现在都是用这个</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试驱动与数据库建立连接</span></span><br><span class="line"><span class="comment"> * 测试sql语句</span></span><br><span class="line"><span class="comment"> * Statement 是Connections的子类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 用Connections 的    </span></span><br><span class="line"><span class="comment"> * createStatement()方法创建 Statement    对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 而Statement的方法有</span></span><br><span class="line"><span class="comment"> * execute(String sql)      //向数据库传递sql语句   执行操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/*PreparedStatement 是Connections的子类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 测试PreparedStatement的基本用法</span></span><br><span class="line"><span class="comment"> *有三个方法：</span></span><br><span class="line"><span class="comment"> *execute()  执行sql语句    放回是否有结果</span></span><br><span class="line"><span class="comment"> *executeUpdate()  返回更新和影响的  记录数  （ 行数）</span></span><br><span class="line"><span class="comment"> *excuteQuery()    </span></span><br><span class="line"><span class="comment"> * 测试sql语句</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>监听器Listener</title>
    <link href="https://aisnia.github.io/2019/09/10/%E7%9B%91%E5%90%AC%E5%99%A8Listener/"/>
    <id>https://aisnia.github.io/2019/09/10/监听器Listener/</id>
    <published>2019-09-10T14:32:59.000Z</published>
    <updated>2019-09-10T14:37:25.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JavaWeb监听器概述"><a href="#1-JavaWeb监听器概述" class="headerlink" title="1　JavaWeb监听器概述"></a><strong>1　JavaWeb监听器概述</strong></h2><p>在JavaWeb被监听的事件源为：ServletContext、HttpSession、ServletRequest，即三大域对象。</p><p> 监听域对象“创建”与“销毁”的监听器；</p><p> 监听域对象“操作域属性”的监听器；</p><p> 监听HttpSession的监听器。</p><h2 id="2-创建与销毁监听器"><a href="#2-创建与销毁监听器" class="headerlink" title="2　创建与销毁监听器"></a><strong>2　创建与销毁监听器</strong></h2><p><strong>创建与销毁监听器一共有三个：</strong></p><ul><li><p><strong>ServletContextListener：Tomcat启动和关闭时调用下面两个方法</strong></p><ul><li><p>public void contextInitialized(ServletContextEvent evt)：ServletContext对象被创建后调用；</p></li><li><p>public void contextDestroyed(ServletContextEvent evt)：ServletContext对象被销毁前调用；</p></li></ul></li><li><p><strong>HttpSessionListener：开始会话和结束会话时调用下面两个方法</strong></p><ul><li><p>public void sessionCreated(HttpSessionEvent evt)：HttpSession对象被创建后调用；</p></li><li><p>public void sessionDestroyed(HttpSessionEvent evt)：HttpSession对象被销毁前调用；</p></li></ul></li><li><p><strong>ServletRequestListener：开始请求和结束请求时调用下面两个方法</strong></p><ul><li><p>public void requestInitiallized(ServletRequestEvent evt)：ServletRequest对象被创建后调用；</p></li><li><p>public void requestDestroyed(ServletRequestEvent evt)：ServletRequest对象被销毁前调用。</p></li></ul></li></ul><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><strong>事件对象</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletContextEvent：<span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">HttpSeessionEvent：HttpSession <span class="title">getSession</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">ServletRequestEvent：</span></span><br><span class="line"><span class="function">ServletRequest <span class="title">getServletRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><strong>编写测试例子：</strong></p><p>编写MyServletContextListener类，实现ServletContextListener接口；</p><p>在web.xml文件中部署监听器；</p><p>为了看到session销毁的效果，在web.xml文件中设置session失效时间为1分钟；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ServletContextListener实现类</span></span><br><span class="line"><span class="comment"> * contextDestroyed() -- 在ServletContext对象被销毁前调用</span></span><br><span class="line"><span class="comment"> * contextInitialized() --  -- 在ServletContext对象被创建后调用</span></span><br><span class="line"><span class="comment"> * ServletContextEvent -- 事件类对象</span></span><br><span class="line"><span class="comment"> *     该类有getServletContext()，用来获取ServletContext对象，即获取事件源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"销毁ServletContext对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"创建ServletContext对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HttpSessionListener实现类</span></span><br><span class="line"><span class="comment"> * sessionCreated() -- 在HttpSession对象被创建后被调用</span></span><br><span class="line"><span class="comment"> * sessionDestroyed() --  -- 在HttpSession对象被销毁前调用</span></span><br><span class="line"><span class="comment"> * HttpSessionEvent -- 事件类对象</span></span><br><span class="line"><span class="comment"> *     该类有getSession()，用来获取当前HttpSession对象，即获取事件源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpSessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"创建session对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"销毁session对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ServletRequestListener实现类</span></span><br><span class="line"><span class="comment"> * requestDestroyed() -- 在ServletRequest对象被销毁前调用</span></span><br><span class="line"><span class="comment"> * requestInitialized() -- 在ServletRequest对象被创建后调用</span></span><br><span class="line"><span class="comment"> * ServletRequestEvent -- 事件类对象</span></span><br><span class="line"><span class="comment"> *     该类有getServletContext()，用来获取ServletContext对象</span></span><br><span class="line"><span class="comment"> *     该类有getServletRequest()，用来获取当前ServletRequest对象，即事件源对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletRequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"销毁request对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"创建request对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.itcast.listener.MyServletContextListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.itcast.listener.MyHttpSessionListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>cn.itcast.listener.MyServletRequestListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>1<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-操作域属性的监听器"><a href="#3-操作域属性的监听器" class="headerlink" title="3　操作域属性的监听器"></a><strong>3　操作域属性的监听器</strong></h3><p><strong>当对域属性进行增、删、改时，执行的监听器一共有三个：</strong></p><p><strong>ServletContextAttributeListener：在ServletContext域进行增、删、改属性时调用下面方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent evt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent evt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent evt)</span></span></span><br></pre></td></tr></table></figure><p><strong>HttpSessionAttributeListener：在HttpSession域进行增、删、改属性时调用下面方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent evt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span> <span class="params">(HttpSessionBindingEvent evt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span> <span class="params">(HttpSessionBindingEvent evt)</span></span></span><br></pre></td></tr></table></figure><p><strong>ServletRequestAttributeListener：在ServletRequest域进行增、删、改属性时调用下面方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestAttributeEvent evt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span> <span class="params">(ServletRequestAttributeEvent evt)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span> <span class="params">(ServletRequestAttributeEvent evt)</span></span></span><br></pre></td></tr></table></figure><p><strong>下面对这三个监听器的事件对象功能进行介绍：</strong></p><p><strong>ServletContextAttributeEvent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>：获取当前操作的属性名；</span></span><br><span class="line"><span class="function">Object <span class="title">getValue</span><span class="params">()</span>：获取当前操作的属性值；</span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span>：获取ServletContext对象。</span></span><br></pre></td></tr></table></figure><p><strong>HttpSessionBindingEvent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>：获取当前操作的属性名；</span></span><br><span class="line"><span class="function">Object <span class="title">getValue</span><span class="params">()</span>：获取当前操作的属性值；</span></span><br><span class="line"><span class="function">HttpSession <span class="title">getSession</span><span class="params">()</span>：获取当前操作的session对象。</span></span><br></pre></td></tr></table></figure><p><strong>ServletRequestAttributeEvent</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>：获取当前操作的属性名；</span></span><br><span class="line"><span class="function">Object <span class="title">getValue</span><span class="params">()</span>：获取当前操作的属性值；</span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span>：获取ServletContext对象；</span></span><br><span class="line"><span class="function">ServletRequest <span class="title">getServletRequest</span><span class="params">()</span>：获取当前操作的ServletRequest对象。</span></span><br></pre></td></tr></table></figure><p><strong>编写测试例子：</strong></p><p>编写MyServletContextListener类，实现ServletContextListener接口；</p><p>在web.xml文件中部署监听器；</p><p>为了看到session销毁的效果，在web.xml文件中设置session失效时间为1分钟；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span>,</span></span><br><span class="line"><span class="class"><span class="title">ServletRequestAttributeListener</span>, <span class="title">HttpSessionAttributeListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionBindingEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"向session中添加属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionBindingEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"从session中移除属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionBindingEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"修改session中的属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestAttributeEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"向request中添加属性："</span></span><br><span class="line">     + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"从request中移除属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"修改request中的属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"向context中添加属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"从context中移除属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent evt)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"修改context中的属性："</span> </span><br><span class="line">    + evt.getName() + <span class="string">"="</span> + evt.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-HttpSession的监听器"><a href="#4-HttpSession的监听器" class="headerlink" title="4　HttpSession的监听器"></a><strong>4　HttpSession的监听器</strong></h3><p>还有两个与HttpSession相关的特殊的监听器，这两个监听器的特点如下：</p><p>1、不用在web.xml文件中部署；</p><p>2、两个监听器不是给session添加，而是给Bean添加。即让Bean类实现监听器接口，然后再把Bean对象添加到session域中。</p><p>下面对这两个监听器介绍一下：</p><p>1、HttpSessionBindingListener：当某个类实现了该接口后，可以感知本类对象添加到session中，以及感知从session中移除。例如让Person类实现HttpSessionBindingListener接口，那么当把Person对象添加到session中，或者把Person对象从session中移除时会调用下面两个方法：</p><p>public void valueBound(HttpSessionBindingEvent event)：当把监听器对象添加到session中会调用监听器对象的本方法；</p><p>public void valueUnbound(HttpSessionBindingEvent event)：当把监听器对象从session中移除时会调用监听器对象的本方法；</p><p>这里要注意，HttpSessionBindingListener监听器的使用与前面介绍的都不相同，当该监听器对象添加到session中，或把该监听器对象从session移除时会调用监听器中的方法。并且无需在web.xml文件中部署这个监听器。</p><h4 id="HttpSessionActivationListener"><a href="#HttpSessionActivationListener" class="headerlink" title="HttpSessionActivationListener"></a><strong>HttpSessionActivationListener</strong></h4><p>Tomcat会在session从时间不被使用时钝化session对象，所谓钝化session，就是把session通过序列化的方式保存到硬盘文件中。当用户再使用session时，Tomcat还会把钝化的对象再活化session，所谓活化就是把硬盘文件中的session在反序列化回内存。当session被Tomcat钝化时，session中存储的对象也被纯化，当session被活化时，也会把session中存储的对象活化。如果某个类实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用：</p><p>public void sessionWillPassivate(HttpSessionEvent se)：当对象感知被活化时调用本方法；</p><p>public void sessionDidActivate(HttpSessionEvent se)：当对象感知被钝化时调用本方法；</p><p>HttpSessionActivationListener监听器与HttpSessionBindingListener监听器相似，都是感知型的监听器，例如让Person类实现了HttpSessionActivationListener监听器接口，并把Person对象添加到了session中后，当Tomcat钝化session时，同时也会钝化session中的Person对象，这时Person对象就会感知到自己被钝化了，其实就是调用Person对象的sessionWillPassivate()方法。当用户再次使用session时，Tomcat会活化session，这时Person会感知到自己被活化，其实就是调用Person对象的sessionDidActivate()方法。</p><p>注意，因为钝化和活化session，其实就是使用序列化和反序列化技术把session从内存保存到硬盘，和把session从硬盘加载到内存。这说明如果Person类没有实现Serializable接口，那么当session钝化时就不会钝化Person，而是把Person从session中移除再钝化！这也说明session活化后，session中就不在有Person对象了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JavaWeb监听器概述&quot;&gt;&lt;a href=&quot;#1-JavaWeb监听器概述&quot; class=&quot;headerlink&quot; title=&quot;1　JavaWeb监听器概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;1　JavaWeb监听器概述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在Java
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>过滤器Filter</title>
    <link href="https://aisnia.github.io/2019/09/10/%E8%BF%87%E6%BB%A4%E5%99%A8Filter/"/>
    <id>https://aisnia.github.io/2019/09/10/过滤器Filter/</id>
    <published>2019-09-10T14:29:46.000Z</published>
    <updated>2019-09-10T14:32:42.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤器概述"><a href="#过滤器概述" class="headerlink" title="过滤器概述"></a><strong>过滤器概述</strong></h2><h3 id="1-什么是过滤器"><a href="#1-什么是过滤器" class="headerlink" title="1　什么是过滤器"></a><strong>1</strong>　<strong>什么是过滤器</strong></h3><p>过滤器JavaWeb三大组件之一，它与Servlet很相似！不它过滤器是用来拦截请求的，而不是处理请求的。</p><p>当用户请求某个Servlet时，会先执行部署在这个请求上的Filter，如果Filter“放行”，那么会继承执行用户请求的Servlet；如果Filter不“放行”，那么就不会执行用户请求的Servlet。</p><p>其实可以这样理解，当用户请求某个Servlet时，Tomcat会去执行注册在这个请求上的Filter，然后是否“放行”由Filter来决定。可以理解为，Filter来决定是否调用Servlet！当执行完成Servlet的代码后，还会执行Filter后面的代码。</p><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/78625a30dda041fa8d7b22b13a2085a0/wpsdde4.tmp.jpeg" alt="img"></p><h3 id="2-过滤器之hello-world"><a href="#2-过滤器之hello-world" class="headerlink" title="2　过滤器之hello world"></a><strong>2</strong>　<strong>过滤器之</strong>hello world</h3><p>　　其实过滤器与Servlet很相似，我们回忆一下如果写的第一个Servlet应用！写一个类，实现Servlet接口！没错，写过滤器就是写一个类，实现Filter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello Filter"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步也与Servlet一样，在web.xml文件中部署Filter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>helloFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.filter.HelloFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>helloFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-过滤器的生命周期"><a href="#1-过滤器的生命周期" class="headerlink" title="1　过滤器的生命周期"></a><strong>1　过滤器的生命周期</strong></h3><p>我们已经学习过Servlet的生命周期，那么Filter的生命周期也就没有什么难度了！</p><ul><li><p><strong>init(FilterConfig)</strong>：在服务器启动时会创建Filter实例，并且每个类型的Filter只创建一个实例，从此不再创建！在创建完Filter实例后，会马上调用init()方法完成初始化工作，这个方法只会被执行一次；</p></li><li><p><strong>doFilter(ServletRequest req,ServletResponse res,FilterChain chain)</strong>：这个方法会在用户每次访问“目标资源（<url->pattern&gt;index.jsp）”时执行，如果需要“放行”，那么需要调用FilterChain的doFilter(ServletRequest,ServletResponse)方法，如果不调用FilterChain的<strong>doFilter()</strong>方法，那么目标资源将无法执行；  而 ServletRequest,ServletResponse类型 通常会强制为 HttpServletRequest  和 ServletResponse类型 来处理</url-></p></li><li><p><strong>destroy()</strong>：服务器会在创建Filter对象之后，把Filter放到缓存中一直使用，通常不会销毁它。一般会在服务器关闭时销毁Filter对象，在销毁Filter对象之前，服务器会调用Filter对象的destory()方法。</p></li></ul><h3 id="2、FilterConfig"><a href="#2、FilterConfig" class="headerlink" title="2、FilterConfig"></a><strong>2、FilterConfig</strong></h3><p>你已经看到了吧，Filter接口中的init()方法的参数类型为FilterConfig类型。它的功能与ServletConfig相似，与web.xml文件中的配置信息对应。下面是FilterConfig的功能介绍：</p><p>ServletContext getServletContext()：获取ServletContext的方法； String getFilterName()：获取Filter的配置名称；与<filter-name>元素对应； String getInitParameter(String name)：获取Filter的初始化配置， 与<init-param>元素对应； Enumeration getInitParameterNames()：获取所有初始化参数的名称。 </init-param></filter-name></p><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/91323709e8d146ff8b6b47ea63a4be9e/wpsd1eb.tmp.jpeg" alt="img"></p><h3 id="3-FilterChain"><a href="#3-FilterChain" class="headerlink" title="3　FilterChain"></a><strong>3　FilterChain</strong></h3><p>doFilter()方法的参数中有一个类型为FilterChain的参数，它只有一个方法：<strong>doFilter(ServletRequest,ServletResponse)。</strong></p><p>前面我们说doFilter()方法的放行，让请求流访问目标资源！但这么说不严密，其实调用该方法的意思是，“我（当前Filter）”放行了，但不代表其他人（其他过滤器）也放行。</p><p>也就是说，一个目标资源上，可能部署了多个过滤器，就好比在你去北京的路上有多个打劫的匪人（过滤器），而其中第一伙匪人放行了，但不代表第二伙匪人也放行了，所以调用FilterChain类的doFilter()方法表示的是执行下一个过滤器的doFilter()方法，或者是执行目标资源！</p><p>如果当前过滤器是最后一个过滤器，那么调用chain.doFilter()方法表示执行目标资源，而不是最后一个过滤器，那么chain.doFilter()表示执行下一个过滤器的doFilter()方法。</p><h3 id="4-多个过滤器执行顺序"><a href="#4-多个过滤器执行顺序" class="headerlink" title="4　多个过滤器执行顺序"></a><strong>4</strong>　<strong>多个过滤器执行顺序</strong></h3><p>一个目标资源可以指定多个过滤器，过滤器的执行顺序是在web.xml文件中的部署顺序：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.filter.MyFilter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.itcast.filter.MyFilter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>myFilter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先经过myFilter1 在 经过 myFilter2</p><h3 id="5-四种拦截方式"><a href="#5-四种拦截方式" class="headerlink" title="5　四种拦截方式"></a><strong>5　四种拦截方式</strong></h3><p>我们来做个测试，写一个过滤器，指定过滤的资源为b.jsp，然后我们在浏览器中直接访问b.jsp，你会发现过滤器执行了！</p><p>但是，当我们在a.jsp中request.getRequestDispathcer(“/b.jsp”).forward(request,response)时，就不会再执行过滤器了！也就是说，默认情况下，只能直接访问目标资源才会执行过滤器，而forward执行目标资源，不会执行过滤器！</p><p><strong>其实过滤器有四种拦截方式！分别是：REQUEST、FORWARD、INCLUDE、ERROR。</strong></p><ul><li><p><strong>REQUEST</strong>：直接访问目标资源时执行过滤器。包括：在地址栏中直接访问、表单提交、超链接、重定向，只要在地址栏中可以看到目标资源的路径，就是REQUEST；</p></li><li><p><strong>FORWARD</strong>：转发访问执行过滤器。包括RequestDispatcher#forward()方法、<a href="jsp:forward" target="_blank" rel="noopener">jsp:forward</a>标签都是转发访问；</p></li><li><p><strong>INCLUDE</strong>：包含访问执行过滤器。包括RequestDispatcher#include()方法、<a href="jsp:include" target="_blank" rel="noopener">jsp:include</a>标签都是包含访问；</p></li><li><p><strong>ERROR</strong>：当目标资源在web.xml中配置为<error-page>中时，并且真的出现了异常，转发到目标资源时，会执行过滤器。</error-page></p></li></ul><p>可以在<filter-mapping>中添加0~n个<dispatcher>子元素，来说明当前访问的拦截方式。</dispatcher></filter-mapping></p><h3 id="6-过滤器的应用场景"><a href="#6-过滤器的应用场景" class="headerlink" title="6　过滤器的应用场景"></a><strong>6　过滤器的应用场景</strong></h3><p><strong>过滤器的应用场景：</strong></p><p>执行目标资源之前做预处理工作，例如设置编码，这种试通常都会放行，只是在目标资源执行之前做一些准备工作；[几乎是的Sevlet中都需要写request.setCharacterEndoing() 可以把它入到一个Filter中]</p><p>通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户IP是否已经被禁用；</p><p>在目标资源执行后，做一些后续的特殊处理工作，例如把目标资源输出的数据进行处理[回程拦截！]；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过滤器概述&quot;&gt;&lt;a href=&quot;#过滤器概述&quot; class=&quot;headerlink&quot; title=&quot;过滤器概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;过滤器概述&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;1-什么是过滤器&quot;&gt;&lt;a href=&quot;#1-什么是过滤器&quot; class=
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Request与Response</title>
    <link href="https://aisnia.github.io/2019/09/10/Request%E4%B8%8EResponse/"/>
    <id>https://aisnia.github.io/2019/09/10/Request与Response/</id>
    <published>2019-09-10T03:24:02.000Z</published>
    <updated>2019-09-10T14:28:52.171Z</updated>
    
    <content type="html"><![CDATA[<h4 id="服务器处理请求的流程"><a href="#服务器处理请求的流程" class="headerlink" title="服务器处理请求的流程"></a><strong>服务器处理请求的流程</strong></h4><p>  服务器每次收到请求时，都会为这个请求开辟一个新的线程。</p><p>  服务器会把客户端的请求数据封装到request对象中，request就是请求数据的载体！（袋子）</p><p>  服务器还会创建response对象，这个对象与客户端连接在一起，它可以用来向客户端发送响应。</p><h4 id="response：其类型为HttpServletResponse"><a href="#response：其类型为HttpServletResponse" class="headerlink" title="response：其类型为HttpServletResponse"></a><strong>response：其类型为HttpServletResponse</strong></h4><p>  ServletResponse–&gt;与协议无关的类型</p><p>  HttpServletResponse–&gt;与http协议相关的类型</p><p>　　回忆一下http协议！http协议中响应的内容包含哪些东西呢？</p><ul><li><p>状态码：200表示成功、302表示重定向、404表示客户端错（访问的资源不存在）、500表示服务器端错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    sendError(<span class="keyword">int</span> sc) <span class="comment">// 发送错误状态码，例如404、500</span></span><br><span class="line">    sendError(<span class="keyword">int</span> sc, String msg) <span class="comment">// 也是发送错误状态码，还可以带一个错误信息！</span></span><br><span class="line">setStatus(<span class="keyword">int</span> sc) <span class="comment">// 发送成功的状态码，可以用来发送302</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>响应头：Content-Type、Refresh、Location等等</li></ul><p>　　头就是一个键值对！可能会存在一个头（一个名称，一个值），也可能会存在一个头（一个名称，多个值！）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setHeader(String name, String value)：<span class="comment">//适用于单值的响应头，例如：response.setHeader("aaa", "AAA");</span></span><br><span class="line">addHeader(String name, String value)：<span class="comment">//适用于多值的响应头</span></span><br><span class="line">response.addHeader(<span class="string">"aaa"</span>, <span class="string">"A"</span>);</span><br><span class="line">response.addHeader(<span class="string">"aaa"</span>, <span class="string">"AA"</span>);</span><br><span class="line">response.addHeader(<span class="string">"aaa"</span>, <span class="string">"AAA"</span>);</span><br><span class="line">setIntHeader(String name, <span class="keyword">int</span> value)：<span class="comment">//适用于单值的int类型的响应头</span></span><br><span class="line">`response.setIntHeader(<span class="string">"Content-Length"</span>, <span class="number">888</span>);</span><br><span class="line">addIntHeader(String name, <span class="keyword">int</span> value)：<span class="comment">//适用于多值的int类型的响应头</span></span><br><span class="line">setDateHeader(String name, <span class="keyword">long</span> value)<span class="comment">//：适用于单值的毫秒类型的响应头</span></span><br><span class="line">response.setDateHeader(<span class="string">"expires"</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">addDateHeader(String name, <span class="keyword">long</span> value)<span class="comment">//：适用于多值的毫秒类型的响应头</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;meta&gt;标签可以代替响应头：</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br></pre></td></tr></table></figure><p>响应体：通常是html、也可以是图片！</p><ul><li><p><strong>response的两个流：</strong></p><ul><li>ServletOutputStream，用来向客户端发送字节数据。</li></ul><p>​        ServletOutputStream out = resopnse.getOutputStream();</p><ul><li>PrintWriter，用来向客户端发送字符数据！需要设置编码。</li></ul><p>PrintWriter writer = response.getWriter();**</p></li><li><p><strong>两个流不能同时使用！</strong></p></li></ul><p>　　　</p><p>　　* 重定向：设置302，设置Location！其中变化的只有Location，所以java提供了一个快捷方法，完成重定向！</p><p>　　　&gt; sendRedirect(String location)方法</p><h2 id="request-–-gt-封装了客户端所有的请求数据！"><a href="#request-–-gt-封装了客户端所有的请求数据！" class="headerlink" title="request –&gt; 封装了客户端所有的请求数据！"></a><strong>request –&gt; 封装了客户端所有的请求数据！</strong></h2><p>请求行</p><p>请求头</p><p>空行</p><p>请求体（GET没体）</p><p>​    回忆一下http协议！请求协议中的数据都可以通过request对象来获取！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">获取常用信息</span><br><span class="line">获取客户端IP，案例：封IP。request.getRemoteAddr()</span><br><span class="line">请求方式，request.getMethod()，可能是POST也可能是GET</span><br><span class="line">获取HTTP请求头</span><br><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String name)</span>，适用于单值头</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntHeader</span><span class="params">(String name)</span>，适用于单值<span class="keyword">int</span>类型的请求头</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getDateHeader</span><span class="params">(String name)</span>，适用于单值毫秒类型的请求头</span></span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getHeaders</span><span class="params">(String name)</span>，适用于多值请求头</span></span><br></pre></td></tr></table></figure><h3 id="获取请求URL"><a href="#获取请求URL" class="headerlink" title="获取请求URL"></a>获取请求URL</h3><p><a href="http://localhost:8080/day10_2/AServlet?username=xxx&amp;password=yyy" target="_blank" rel="noopener">http://localhost:8080/day10_2/AServlet?username=xxx&amp;password=yyy</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function">String <span class="title">getScheme</span><span class="params">()</span>：获取协议，http</span></span><br><span class="line"><span class="function">&gt; String <span class="title">getServerName</span><span class="params">()</span>：获取服务器名，localhost</span></span><br><span class="line"><span class="function">&gt; String <span class="title">getServerPort</span><span class="params">()</span>：获取服务器端口，8080</span></span><br><span class="line"><span class="function">&gt; *****String <span class="title">getContextPath</span><span class="params">()</span>：获取项目名，/day10_2</span></span><br><span class="line"><span class="function">&gt; String <span class="title">getServletPath</span><span class="params">()</span>：获取Servlet路径，/AServlet</span></span><br><span class="line"><span class="function">&gt; String <span class="title">getQueryString</span><span class="params">()</span>：</span></span><br><span class="line"><span class="function">获取参数部分，即问号后面的部分。username</span>=xxx&amp;password=yyy</span><br><span class="line">&gt; <span class="function">String <span class="title">getRequestURI</span><span class="params">()</span>：</span></span><br><span class="line"><span class="function">获取请求URI，等于项目名+Servlet路径。/day10_2/AServlet</span></span><br><span class="line"><span class="function">&gt; String <span class="title">getRequestURL</span><span class="params">()</span>：</span></span><br><span class="line"><span class="function">获取请求URL，等于不包含参数的整个请求路径。</span></span><br><span class="line"><span class="function">http:<span class="comment">//localhost:8080/day10_2/AServlet</span></span></span><br></pre></td></tr></table></figure><p>　获取请求参数：请求参数是由客户端发送给服务器的！有可能是在请求体中（POST），也可能是在URL之后（GET）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请求参数：有一个参数一个值的，还有一个参数多个值！</span><br><span class="line"><span class="function">String <span class="title">getParameter</span><span class="params">(String name)</span>：获取指定名称的请求参数值，适用于单值请求参数</span></span><br><span class="line"><span class="function">String[] <span class="title">getParameterValues</span><span class="params">(String name)</span>：获取指定名称的请求参数值，适用于多值请求参数</span></span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span>：获取所有请求参数名称</span></span><br><span class="line"><span class="function">Map&lt;String,String[]&gt; <span class="title">getParameterMap</span><span class="params">()</span>：获取所有请求参数，其中key为参数名，value为参数值。</span></span><br></pre></td></tr></table></figure><h3 id="请求转发和请求包含"><a href="#请求转发和请求包含" class="headerlink" title="请求转发和请求包含"></a><strong>请求转发和请求包含</strong></h3><p>　　　　RequestDispatcher rd = request.getRequestDispatcher(“/MyServlet”);  使用request获取RequestDispatcher对象，方法的参数是被转发或包含的Servlet的Servlet路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请求转发：rd.forward(request,response);</span><br><span class="line">请求包含：rd.include(request,response);</span><br></pre></td></tr></table></figure><p>　有时一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet跳到另一个Servlet！</p><p>　　　　&gt; 一个请求跨多个Servlet，需要使用转发和包含。</p><p>　　　　&gt; 请求转发：由下一个Servlet完成响应体！当前Servlet可以设置响应头！（留头不留体）</p><p>　　　　&gt; 请求包含：由两个Servlet共同未完成响应体！（都留）</p><p>　　　　&gt; 无论是请求转发还是请求包含，都在一个请求范围内！使用同一个request和response！</p><h3 id="request域"><a href="#request域" class="headerlink" title="request域"></a><strong>request域</strong></h3><p>　　　　<strong>Servlet中三大域对象：request、session、application，都有如下三个方法：</strong></p><p>　　　　&gt; void setAttribute(String name, Object value)</p><p>　　　　&gt; Object getAttribute(String name)</p><p>​    &gt; void removeAttribute(String name);</p><p>　　　　&gt; 同一请求范围内使用request.setAttribute()、request.getAttribute()来传值！前一个Servlet调用setAttribute()保存值，后一个Servlet调用getAttribute()获取值。</p><p>　　<strong>* 请求转发和重定向的区别</strong></p><p>　　　　&gt; 请求转发是一个请求一次响应，而重定向是两次请求两次响应</p><p>　　　　&gt; 请求转发地址栏不变化，而重定向会显示后一个请求的地址</p><p>　　　　&gt; 请求转发只能转发到本项目其他Servlet，而重定向不只能重定向到本项目的其他Servlet，还能定向到其他项目</p><p>　　　　&gt; 请求转发是服务器端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI，即包含项目名！</p><p>　　　　&gt; 请求转发和重定向效率是转发高！因为是一个请求！s</p><p>　　　　　　&lt;&gt; 需要地址栏发生变化，那么必须使用重定向！</p><p>　　　　　　&lt;&gt; 需要在下一个Servlet中获取request域中的数据，必须要使用转发！</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a><strong>编码</strong></h2><p>　　常见字符编码：<strong>iso-8859-1(不支持中文)</strong>、gb2312、<strong>gbk</strong>、gb18030(系统默认编码，中国的国标码)、<strong>utf-8(万国码，支持全世界的编码，所以我们使用这个)</strong></p><p><strong>1. 响应编码</strong></p><p>　　* 当使用response.getWriter()来向客户端发送字符数据时，如果在之前没有设置编码，那么默认使用iso，因为iso不支持中文，一定乱码</p><p>　　* 在使用response.getWriter()之前可以使用response.setCharaceterEncoding()来设置字符流的编码为gbk或utf-8，当然我们通常会选择utf-8。这样使用response.getWriter()发送的字符就是使用utf-8编码的。但还是会出现乱码！因为浏览器并不知道服务器发送过来的是什么编码的数据！这时浏览器会使用gbk来解码，所以乱码！</p><p>　　* 在使用response.getWriter()之前可以使用response.setHeader(“Content-type”,”text/html;charset=utf-8”)来设置响应头，通知浏览器服务器这边使用的是utf-8编码，而且在调用setHeader()后，还会自动执行setCharacterEncding()方法。这样浏览器会使用utf-8解码，所以就不会乱码了！</p><p>　　* setHeader(“Content-Type”, “text/html;charset=utf-8”)的快捷方法是：setContentType(“text/html;charset=utf-8)。</p><p><strong>2. 请求编码</strong></p><p>　　* 客户端发送给服务器的请求参数是什么编码：</p><p>　　　　客户端首先要打开一个页面，然后在页面中提交表单或点击超链接！在请求这个页面时，服务器响应的编码是什么，那么客户端发送请求时的编码就是什么。</p><p>　　<strong>* 服务器端默认使用什么编码来解码参数：</strong></p><p>　　　　服务器端默认使用ISO-8859-1来解码！所以这一定会出现乱码的！因为iso不支持中文！</p><p>　　* 请求编码处理分为两种：GET和POST：GET请求参数不在请求体中，而POST请求参数在请求体中，所以它们的处理方式是不同的！</p><p>　　<strong>* GET请求编码处理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; String username = <span class="keyword">new</span> String(request.getParameter(<span class="string">"iso-8859-1"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line">&gt; 在server.xml中配置URIEncoding=utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>　　<strong>* POST请求编码处理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;String username = <span class="keyword">new</span> String(request.getParameter(<span class="string">"iso-8859-1"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line">&gt; 在获取参数之前调用request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><p><strong>3. URL编码</strong></p><p>　　表单的类型：Content-Type: application/x-www-form-urlencoded，就是把中文转换成%后面跟随两位的16进制。</p><p>　　<strong>为什么要用它：在客户端和服务器之间传递中文时需要把它转换成网络适合的方式。</strong></p><p>　　<strong>* 它不是字符编码！</strong></p><p>　　<strong>* 它是用来在客户端与服务器之间传递参数用的一种方式！</strong></p><p>　　<strong>* URL编码需要先指定一种字符编码，把字符串解码后，得到byte[]，然后把小于0的字节+256，再转换成16进制。前面再添加一个%。</strong></p><p>　　* POST请求默认就使用URL编码！tomcat会自动使用URL解码！</p><p>　　* URL编码：String username = URLEncoder.encode(username, “utf-8”);</p><p>　　* URL解码：String username = URLDecoder.decode(username, “utf-8”);</p><p>　　最后我们需要把链接中的中文参数，使用url来编码！今天不行，因为html中不能给出java代码，但后面学了jsp就可以了。</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a><strong>路径</strong></h3><p>　　<strong>web.xml中<url-pattern>路径，（叫它Servlet路径！）</url-pattern></strong></p><p>　　　　要么以“*”开关，要么为“/”开头</p><p>　　<strong>转发和包含路径</strong></p><ul><li><p><strong>以“/”开头相对当前项目路径</strong>，例如：<a href="http://localhost:8080/项目名/" target="_blank" rel="noopener">http://localhost:8080/项目名/</a>　request.getRequestdispacher(“/BServlet”).for…();</p></li><li><p>不以“/”开头：相对当前Servlet路径**。 request.getRequestdispacher(“/BServlet”).for…();，</p><p>假如当前Servlet是：<a href="http://localhost:8080/项目名/servlet/AServlet，" target="_blank" rel="noopener">http://localhost:8080/项目名/servlet/AServlet，</a>　就是<a href="http://localhost:8080/项目名/servlet/BServlet" target="_blank" rel="noopener">http://localhost:8080/项目名/servlet/BServlet</a></p></li></ul><h5 id="重定向路径（客户端路径"><a href="#重定向路径（客户端路径" class="headerlink" title="　　重定向路径（客户端路径"></a>　　<strong>重定向路径（客户端路径</strong></h5><ul><li>以“/”开头：相对当前主机，例如：<a href="http://localhost:8080/，" target="_blank" rel="noopener">http://localhost:8080/，</a>　所以需要自己手动添加项目名，例如；response.sendRedirect(“/day10_1/Bservlet”);</li></ul><p>　　<strong>页面中超链接和表单路径</strong></p><ul><li>与重定向相同，都是客户端路径！需要添加项目名</li></ul><p>​    <form action="/day10_1/AServlet"></form></p><p>​    <a href="/day10_/AServlet"></a></p><p>​    <a href="AServlet">，如果不以“/”开头，那么相对当前页面所在路径。如果是http://localhost:8080/day10_1/html/form.html。　即：http://localhost:8080/day10_1/html/ASevlet</a></p><ul><li><p>建立使用以“/”开头的路径，即绝对路径！</p></li><li><p>　<strong>ServletContext获取资源路径</strong></p></li></ul><p>　　　　 相对当前项目目录，即当然index.jsp所在目录</p><ul><li><strong>ClassLoader获取资源路径</strong></li></ul><p>　　　　 相对classes目录</p><p>　　* <strong>Class获取资源路径</strong></p><p>　　　　 以“/”开头相对classes目录</p><p>　　　　 不以“/”开头相对当前.class文件所在目录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;服务器处理请求的流程&quot;&gt;&lt;a href=&quot;#服务器处理请求的流程&quot; class=&quot;headerlink&quot; title=&quot;服务器处理请求的流程&quot;&gt;&lt;/a&gt;&lt;strong&gt;服务器处理请求的流程&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;  服务器每次收到请求时，都会为这个请求开
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Cookie与Session</title>
    <link href="https://aisnia.github.io/2019/09/10/Cookie%E4%B8%8ESession/"/>
    <id>https://aisnia.github.io/2019/09/10/Cookie与Session/</id>
    <published>2019-09-10T03:22:58.000Z</published>
    <updated>2019-09-10T14:22:39.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是Cookie"><a href="#1-什么是Cookie" class="headerlink" title="1. 什么是Cookie"></a><strong>1. 什么是Cookie</strong></h3><ul><li><p><strong>Cookie是HTTP协议的规范之一，它是服务器和客户端之间传输的小数据。</strong></p></li><li><p><strong>首先由服务器通过响应头把Cookie传输给客户端，客户端会将Cookie保存起来。</strong></p></li><li><p><strong>当客户端再次请求同一服务器时，客户端会在请求头中添加该服务器保存的Cookie，发送给服务器。</strong></p></li><li><p><strong>Cookie就是服务器保存在客户端的数据！</strong></p></li><li><p><strong>Cookie就是一个键值对！！！</strong></p></li></ul><h3 id="2-Cookie规范"><a href="#2-Cookie规范" class="headerlink" title="2. Cookie规范"></a>2. Cookie规范</h3><ul><li><p>Cookie通过请求头和响应头在服务器与客户端之间传输；</p></li><li><p>ookie大小限制在4KB之内；</p></li><li><p>台服务器在一个客户端最多保存20个Cookie；</p></li><li><p>一个浏览器最多可以保存300个Cookie；</p></li></ul><p>虽然Cookie规范是如此，但在今天，浏览器厂商的竞争异常激烈，所以多少会超出Cookie规则的限制。但也不会超出过多！</p><h3 id="3-Cookie与请求头和响应头"><a href="#3-Cookie与请求头和响应头" class="headerlink" title="3.Cookie与请求头和响应头"></a>3.Cookie与请求头和响应头</h3><p>服务器向客户端发送Cookie的响应头为Set-Cookie，例如：Set-Cookie:cookiename=cookievalue</p><p>客户端向服务器发送Cookie的请求头为Cookie，例如：Cookie:cookiename=cookievalue</p><h3 id="4-Servlet中向客户端发送Cookie"><a href="#4-Servlet中向客户端发送Cookie" class="headerlink" title="4. Servlet中向客户端发送Cookie"></a><strong>4. Servlet中向客户端发送Cookie</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie1 = <span class="keyword">new</span> Cookie(<span class="string">"test1"</span>, <span class="string">"abcdefg"</span>);</span><br><span class="line"></span><br><span class="line">Cookie cookie2 = <span class="keyword">new</span> Cookie(<span class="string">"test2"</span>, <span class="string">"ABCDEFG"</span>);</span><br><span class="line"></span><br><span class="line">response.addCookie(cookie1);</span><br><span class="line"></span><br><span class="line">response.addCookie(cookie2);</span><br></pre></td></tr></table></figure><h3 id="5-Servlet中获取客户端发送过来的Cookie"><a href="#5-Servlet中获取客户端发送过来的Cookie" class="headerlink" title="5. Servlet中获取客户端发送过来的Cookie"></a>5. Servlet中获取客户端发送过来的Cookie</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cs = request.getCookies();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(c.getName() + <span class="string">"="</span> + c.getValue());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Cookie的细节"><a href="#6-Cookie的细节" class="headerlink" title="6.Cookie的细节"></a><strong>6.Cookie的细节</strong></h3><ol><li><p><strong>Cookie的maxAge</strong></p><p>当服务器创建Cookie对象后，可以调用setMaxAge()方法设置Cookie的最大生命。</p><ul><li><p>maxAge &gt; 0：表示Cookie在客户端硬盘上保存的最大时间，单位为秒；</p></li><li><p>maxAge &lt; 0：表示Cookie不会被浏览器保存到硬盘上，而只在浏览器内存中存活，一旦客户端关闭浏览器在，那么Cookie就消失；</p></li><li><p>maxAge == 0：表示删除Cookie，例如客户端硬盘已经存在名为abc的Cookie，如果服务器再向客户端发送名为abc，并且maxAge为0的Cookie，那么表示删除客户端上的名为abc的Cookie。</p></li></ul></li><li><p><strong>Cookie的path</strong></p><p> 浏览器在访问BServlet时，是否要带上AServlet保存的Cookie呢？这要看Cookie的path了。</p><p>  现有资源如下：</p></li></ol><ul><li><p><a href="http://localhost:8080/day06_2/servlet/AServlet" target="_blank" rel="noopener">http://localhost:8080/day06_2/servlet/AServlet</a></p></li><li><p><a href="http://localhost:8080/day06_2/servlet/BServlet，保存名为xxx的Cookie" target="_blank" rel="noopener">http://localhost:8080/day06_2/servlet/BServlet，保存名为xxx的Cookie</a></p></li><li><p><a href="http://loclahost:8080/day06_2/servlet/CServlet，保存名为yyy的Cookie" target="_blank" rel="noopener">http://loclahost:8080/day06_2/servlet/CServlet，保存名为yyy的Cookie</a></p></li><li><p><a href="http://loclahost:8080/day06_2/servlet/user/DServlet" target="_blank" rel="noopener">http://loclahost:8080/day06_2/servlet/user/DServlet</a>, 保存名为zzz的Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有设置Cookie的path</span></span><br><span class="line">AServlet &#123;</span><br><span class="line">   Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"xxx"</span>, <span class="string">"XXX"</span>);</span><br><span class="line">   response.addCookie(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置了Cookie的path为/day06_2</span></span><br><span class="line">CServlet &#123;</span><br><span class="line">   Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"yyy"</span>, <span class="string">"YYY"</span>);</span><br><span class="line">   c.setPath=<span class="string">"/day06_2"</span>;</span><br><span class="line">  response.addCookie(c);</span><br><span class="line">&#125;</span><br><span class="line">DServlet &#123;</span><br><span class="line">  Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"zzz"</span>, <span class="string">"ZZZ"</span>);</span><br><span class="line">  resposne.addCookie(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    在BServlet中保存的Cookie没有设置path，那么它的path默认为当前BServlet的所在路径，即“/day06_2/servlet”。</p><p>  在CServlet中保存的Cookie设置了path为/day06_2。</p><p>  在DServlet中保存的Cookie没有设置path，那么它的path默认为DServlet的所在路径，即“day06_2/servlet/user”</p></li></ul><pre><code>当访问BServlet时，是否要带上xxx这个Cookie呢？因为BServlet的访问路径为/day06_2/servlet/BServlet，它包含了xxx的path，即/day06_2/servlet，所以需要带上。当访问BServlet时，是否要带上yyy这个Cookie呢？因为BServlet的访问路径为/day06_2/servlet/BServlet，它包含了xxx的path，即/day06_2，所以需要带上。当访问BServlet时，是否要带上zzz这个Cookie呢？因为BServlet的访问路径为/day06_2/servlet/BServlet，它不包含zzz的path，即/day06_2/servlet/user，所以不会带上。</code></pre><ol start="3"><li><p><strong>Cookie的domain</strong></p><p>  Cookie的path是在同一主机中指定共享Cookie，如果主机不同那么就一定不能共享Cookie，无论path是什么。</p><p>  如果希望不同的二级域名中可以共享Cookie，那么就要设置Cookie的domain了。</p><p>  例如：news.baidu.com、tieba.baidu.com、zhidao.baidu.com，它们的域名不同，但百度希望它们之间可以共享Cookie，那么就要设置domain了。</p></li></ol><pre><code>1). 设置Cookie的path为“/”，例如：cookie.setPath(&quot;/&quot;);2). 设置Cookie的domain，例如：cookie.setDomain(&quot;.baidu.com&quot;)，其中domain中没有指定域名前缀！在news.baidu.com主机中的某个项目中保存了Cookie在tieba.baidu.com主机中某个项目中获取Cookie当然这需要配置两个虚拟主机才行。</code></pre><ol start="4"><li><p><strong>Cookie保存中文</strong></p><p>  <strong>Cookie的name和value都是不能保存中文的，但可以先把中文转换成URL编码，然后在保存到</strong>Cookie的name和value中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"姓名"</span>;</span><br><span class="line">   </span><br><span class="line">String value = <span class="string">"张三"</span>;</span><br><span class="line">   </span><br><span class="line">name = URLEncoder.encode(name, <span class="string">"utf-8"</span>);</span><br><span class="line">   </span><br><span class="line">value = URLEncoder.encode(value, <span class="string">"utf-8"</span>);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">Cookie c = <span class="keyword">new</span> Cookie(name, value);</span><br><span class="line">   </span><br><span class="line">response.addCookie(c);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment">//在获取Cookie时，再使用URL解码即可。</span></span><br><span class="line">   </span><br><span class="line">Cookie[] cs = request.getCookies();</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(cs != <span class="keyword">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">for</span>(Cookie c : cs) &#123;</span><br><span class="line">   </span><br><span class="line">    String name = URLDecoder.decode(c.getName(), <span class="string">"utf-8"</span>);</span><br><span class="line">   </span><br><span class="line">    String value = URLDecoder.decode(c.getValue(), <span class="string">"utf-8"</span>);</span><br><span class="line">   </span><br><span class="line">    System.out.println(name + <span class="string">"="</span> + value);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>在JavaWeb中提供了HttpSession类，用来表示http会话。</strong></p><ol><li><h5 id="获取HttpSession"><a href="#获取HttpSession" class="headerlink" title="获取HttpSession"></a>获取HttpSession</h5></li></ol><p>HttpSession session = request.getSession();</p><p>HttpSession session = request.getSession(false);</p><ol start="2"><li><h5 id="域功能"><a href="#域功能" class="headerlink" title="域功能"></a>域功能</h5><p>session是域对象，所以有setAttribute()和getAttribute()等方法</p><p>服务器会为每个会话创建一个session对象，所以session中的数据可供当前会话中所有servlet共享。</p></li></ol><p><strong>3. 登录案例</strong></p><p>  请求功能：</p><ol><li><p>如果登录功能，在session中保存user对象</p></li><li><p>访问index1.jsp，查看session中是否存在user对象，如果存在，说明已经登录过。</p></li><li><p>访问index2.jsp，查看session中是否存在user对象，如果存在，说明已经登录过。</p><p>如果关闭了浏览器，那么会话结束，再打开浏览器就开始了一个新会话，那么直接访问index1.jsp或index2.jsp时，session是新的，没有保存user对象，那么表示还没有登录。</p></li></ol><p><strong>4. session的原理</strong></p><p>  <strong>session是依赖Cookie实现的。</strong></p><p>  session是服务器端对象</p><ul><li><p><strong>当用户第一次使用session时（表示第一次请求服务器），服务器会创建session，并创建一个Cookie，在Cookie中保存了session的id，发送给客户端。这样客户端就有了自己session的id了。但这个Cookie只在浏览器内存中存在，也就是说，在关闭浏览器窗口后，Cookie就会丢失，也就丢失了sessionId。</strong></p></li><li><p><strong>当用户第二次访问服务器时，会在请求中把保存了sessionId的Cookie发送给服务器，服务器通过sessionId查找session对象，然后给使用。也就是说，只要浏览器容器不关闭，无论访问服务器多少次，使用的都是同一个session对象。这样也就可以让多个请求共享同一个session了。</strong></p></li><li><p><strong>当用户关闭了浏览器窗口后，再打开浏览器访问服务器，这时请求中没有了sessionId，那么服务器会创建一个session，再把sessionId通过Cookie保存到浏览器中，也是一个新的会话开始了。原来的session会因为长时间无法访问而失效。</strong></p></li><li><p><strong>当用户打开某个服务器页面长时间没动作时，这样session会超时失效，当用户再有活动时，服务器通过用户提供的sessionId已经找不到session对象了，那么服务器还是会创建一个新的session对象，再把新的sessionId保存到客户端。这也是一个新的会话开始了。</strong></p></li></ul><p>　　设置session超时时间</p><p>  web.xml文件中配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5. session与浏览器</strong></p><p> session对象是保存在服务器端的，而sessionId是通过Cookie保存在客户端的。</p><p> 因为Cookie不能在多个浏览器中共享，所以session也不能在多个浏览器中共享。也就是说，使用IE登录后，再使用FireFox访问服务器还是没有登录的状态。</p><p> 而且同时打开多个相同浏览器的窗口，是在使用同一session。如果你使用的是老浏览器，例如IE6，那么就会每个窗口一个session。</p><p><strong>6. session的API</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span>：获取sessionId</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxInactiveInterval</span><span class="params">()</span>：获取session可以的最大不活动时间（秒）**，默认为30分钟**。当session在30分钟内没有使用，那么Tomcat会在session池中移除这个session；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMaxInactiveInterval</span><span class="params">(<span class="keyword">int</span> interval)</span>：设置session允许的最大不活动时间**（秒）**，如果设置为1秒，那么只要session在1秒内不被使用，那么session就会被移除；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCreationTime</span><span class="params">()</span>：返回session的创建时间，返回值为当前时间的毫秒值；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastAccessedTime</span><span class="params">()</span>：返回session的最后活动时间，返回值为当前时间的毫秒值；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span>：让session失效！调用这个方法会被session失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中给客户端新session的sessionId；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span>：查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId响应给客户端时，这时session的状态为新。</span></span><br></pre></td></tr></table></figure><p><strong>7. URL重写</strong></p><p> session依赖Cookie，这是因为服务器需要把sessionId保存到客户端。如果用户的浏览器关闭了Cookie功能，那么session不能使用了！</p><p> 还可以在浏览器关闭了Cookie后使用URL重写的方法保存sessionId，这需要在每个URL后面都加上sessionId！这样用户的请求中就包含了sessionId，服务器就可以通过sessionId找到对应的session对象了。</p><p>  使用response.encodeURL()方法对URL进行编码，这样URL中会智能的添加sessionId。</p><p>　当浏览器支持cookie时，response.encodeURL()方法不会在URL后追加sessionId</p><p>  当浏览器不支持cookie时，response.encodeURL()方法会在URL后追加sessionId</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-什么是Cookie&quot;&gt;&lt;a href=&quot;#1-什么是Cookie&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Cookie&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 什么是Cookie&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;stron
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://aisnia.github.io/2019/09/10/Servlet/"/>
    <id>https://aisnia.github.io/2019/09/10/Servlet/</id>
    <published>2019-09-10T02:30:25.000Z</published>
    <updated>2019-09-10T03:14:40.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>​        是javaweb的三大组件之一</p><p>​        主要用于处理客户端请求的动态资源   即获取请求，处理请求，返回响应</p><ul><li><h4 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h4><p>生命周期方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span>  <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req , ServletResponse res)</span> <span class="comment">//服务，处理请求</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span>    <span class="comment">//销毁</span></span></span><br></pre></td></tr></table></figure><h5 id="1-服务器创建Servlet："><a href="#1-服务器创建Servlet：" class="headerlink" title="1. 服务器创建Servlet："></a><strong>1. 服务器创建Servlet：</strong></h5><ul><li><p>当Servlet第一次被请求时，或服务器启动时，服务器会创建Servlet实例。</p></li><li><p>服务器默认是在servlet第一次被请求时创建Servlet实例，如果希望服务器启动时就创建Servlet实现需要在web.xml中配置</p></li><li><p>服务器只为一个类型的Servlet创建一个实例对象，所以Servlet是单例的；</p></li></ul></li></ul><h5 id="2-服务器初始化Servlet："><a href="#2-服务器初始化Servlet：" class="headerlink" title="2. 服务器初始化Servlet："></a><strong>2. 服务器初始化Servlet：</strong></h5><ul><li><p>当服务器创建Servlet实例后会马上调用Servlet的init(ServletConfig)方法，完成对Servlet的初始化；</p></li><li><p>*<em>init(ServletConfig)只会被调用一次 *</em></p></li><li><p>服务器会在调用init()方法时传递ServletConfig参数</p></li></ul><h5 id="3-服务器使用Servlet处理请求："><a href="#3-服务器使用Servlet处理请求：" class="headerlink" title="3. 服务器使用Servlet处理请求："></a><strong>3. 服务器使用Servlet处理请求：</strong></h5><ul><li><p>当Servlet被请求时，服务器会调用Servlet的service(ServletRequest,ServletResponse)方法</p></li><li><p>service(ServletRequest,ServletResponse)<strong>方法每处理一次请求，就会被调用一次</strong>，所以它可能会被调用N次</p></li><li><p>因为Servlet是单例的，所以可能在同一时刻一个Servlet对象会被多个请求同时访问，所以这可能出现线程案例问题</p></li><li><p>Servlet不是线程案例的，这有助与提高效率，但不能让Servlet具有状态，以免多个线程争抢数据</p></li></ul><h5 id="4-服务器销毁Servlet"><a href="#4-服务器销毁Servlet" class="headerlink" title="4. 服务器销毁Servlet"></a>4. 服务器销毁Servlet</h5><ul><li><p>服务器通常不会销毁Servlet，通常只有在服务器关闭时才会销毁Servlet</p></li><li><p>服务器会在销毁Servlet之前调用Servlet的destory()方法</p></li><li><p>可以在destory()方法中给出释放Servlet占有的资源，但通常Servlet是没什么可要释放的，所以该方法一般都是空的</p></li></ul><p>  其他方法</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span>   <span class="comment">//返回初始化用的ServletConfig</span></span></span><br><span class="line"><span class="function">String <span class="title">getServletInfo</span><span class="params">()</span> <span class="comment">//返回改Servlet的信息</span></span></span><br></pre></td></tr></table></figure><ul><li><p>主要的子类</p><p><strong>Servlet  -&gt;  GenericServlet   -&gt;   HttpServlet</strong></p><p>一般实现Servlet都是继承HttpServlet</p></li></ul><h2 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        resp.getWriter().println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xiaoqiang.controller.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-ServletConfig"><a href="#3-ServletConfig" class="headerlink" title="3.ServletConfig"></a><strong>3.ServletConfig</strong></h2><p>ServletConfig是Servlet中的init()方法的参数类型，服务器会在调用init()方法时传递ServletConfig对象给init()方法。</p><p>  <strong>ServletConfig对象封装了Servlet在web.xml中的配置信息</strong>，它对应<servlet>元素。ServletConfig类的功能有：</servlet></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getServletName</span><span class="params">()</span>：获取Servlet配置名，即&lt;servlet-name&gt;的值；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span>：获取ServletContext对象，上下文</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getInitParameter</span><span class="params">(String name)</span>：获取初始化参数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Enumeration <span class="title">getInitParameterNames</span><span class="params">()</span>：获取所有初始化参数的名称</span></span><br></pre></td></tr></table></figure><p>在web.xml文件中，配置<servlet>时可以为<servlet>配置0~N个<strong>初始化参数</strong>，例如：</servlet></servlet></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xiaoqiang.servlet.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-ServletContext"><a href="#4-ServletContext" class="headerlink" title="4.ServletContext"></a><strong>4.ServletContext</strong></h2><p>​      ServletContext是Servlet三大域对象之一</p><p>​      <strong>ServletContext在服务器启动时创建，在服务器关闭时销毁，一个JavaWeb应用只创建一个           ServletContext对象</strong></p><h5 id="1-它的功能分类："><a href="#1-它的功能分类：" class="headerlink" title="1.它的功能分类："></a>1.它的功能分类：</h5><p>  <strong>* 存取数据</strong></p><p>  <strong>* 读取web.xml中的应用初始化参数</strong></p><p>  <strong>* 读取应用资源</strong></p><h5 id="2-获取ServletContext对象"><a href="#2-获取ServletContext对象" class="headerlink" title="2. 获取ServletContext对象"></a><strong>2. 获取ServletContext对象</strong></h5><p>  在HttpServlet中可以通过以下方法来获取ServletContext对象</p><ul><li><p><strong>ServletContext sc = this.getServletContext()</strong></p></li><li><p>ServletContext sc = this.getServletConfig().getServletContext()</p></li></ul><h5 id="3-存取数据"><a href="#3-存取数据" class="headerlink" title="3. 存取数据"></a><strong>3. 存取数据</strong></h5><p>  因为在一个JavaWeb应用中，只有一个ServletContext对象，所以在ServletContext中保存的数据可以<strong>共整个JavaWeb应用中的动态资源共享</strong></p><p>  ServletContext是Servlet三大域对象之一，<strong>域对象内部有一个Map，用来保存数据</strong></p><ul><li><p>void setAttribute(String name, Object value)：用来添加或替换ServletContext域数据</p><p>​     servletContext.setAttribute(“xxx”, “XXX”)，添加域数据</p><p>​     servletContext.setAttribute(“xxx”, “XXXX”)，覆盖域数据，因为在域中已经存在了名为xxx的数据，所以这次就是覆盖了</p></li><li><p>Object getAttribute(String name)：通过名称来获取域数据</p></li><li><p>void removeAttribute(String name)：通过名称移除域数据</p></li><li><p>Enumeration<string> getAttributeNames()：获取所有ServletContext域数据的名称</string></p></li></ul><h5 id="4-读取web-xml中配置的应用初始化参数"><a href="#4-读取web-xml中配置的应用初始化参数" class="headerlink" title="4.读取web.xml中配置的应用初始化参数"></a>4.读取web.xml中配置的应用初始化参数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>v2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">servletContext.getInitParameter(<span class="string">"p1"</span>)，返回v1</span><br><span class="line"></span><br><span class="line">servletContext.getInitParameter(<span class="string">"p2"</span>)，返回v2</span><br><span class="line"></span><br><span class="line">servletContext.getInitParameterNames()，返回Enumeration&lt;String&gt;，包含p1和p2</span><br></pre></td></tr></table></figure><h2 id="5-GenericServlet"><a href="#5-GenericServlet" class="headerlink" title="5.GenericServlet"></a><strong>5.GenericServlet</strong></h2><p>  GenericServlet是Servlet接口的实现类，但它是一个抽象类，它唯一的抽象方法就是service()方法</p><p>  GenericServlet实现了Servlet方法：</p><ul><li><p>现了String getServletInfo()方法</p></li><li><p>实现了void destory()方法，空实现</p></li><li><p>实现了void init(ServletConfig)方法，用来保存ServletConfig参数</p></li><li><p>实现了ServletConfig getServletConfig()方法</p></li></ul><p>  GenericServlet实现了ServletConfig接口：</p><ul><li><p>实现了ServletContext getServletContext()方法</p></li><li><p>实现了String getInitParameter()方法</p></li><li><p>实现了String getServletName()方法</p></li><li><p>实现了Enumeration getInitParameterNames()方法</p></li></ul><p>  GenericServlet添加了init()方法：</p><ul><li>该方法会被init(ServletConfig)方法调用</li><li>如果希望对Servlet进行初始化，那么应该覆盖init()方法，而不是init(ServletConfig)方法</li></ul><h2 id="6-HttpServlet"><a href="#6-HttpServlet" class="headerlink" title="6.HttpServlet"></a><strong>6.HttpServlet</strong></h2><p>  HttpServlet是GenericServlet的子类，它专注HTTP请求</p><p>  HttpServlet类的方法：</p><ul><li><p><strong>实现了void service(ServletRequest,ServletResponse)方法，实现内容是：</strong></p><ul><li><p><strong>把ServletRequest强转成HttpServletRequest</strong></p></li><li><p><strong>把ServletResponse强转成HttpServletResponse</strong></p></li><li><p><strong>调用本类添加的void service(HttpServletRequest,HttpServletResponse)方法 内容是：</strong></p><ul><li>调用request的getMethod()获取请求方式</li><li>如果请求方式为GET，那么调用本类添加的doGet(HttpServletRequest,HttpServletResponse)方法</li><li>如果请求方式为POST，那么调用本类添加的doPost(HttpServletRequest,HttpServletResponse)方法</li><li>添加了doGet(HttpServletRequest,HttpServletResponse)方法，默认内容是响应405，表示错误，所以我们应该去覆盖这个方法</li><li>添加了doPost(HttpServletRequest,HttpServletResponse)方法，默认内容是响应405，表示错误，所以我们应用去覆盖这个方法</li></ul></li><li><p>所以 如果是通过继承HttpServlet类来自定义Sevlet的话，那么：</p><ul><li><p>不要去覆盖void service(ServletRequest,ServletResponse)</p></li><li><p>不要去覆盖void service(HttpServletRequest, HttpServletResponse)</p></li><li><p>而应该去覆盖doGet()或doPost()方法。</p></li></ul></li></ul></li></ul><h2 id="4-获取资源"><a href="#4-获取资源" class="headerlink" title="4. 获取资源"></a>4. 获取资源</h2><h4 id="获取项目资源"><a href="#获取项目资源" class="headerlink" title="获取项目资源"></a>获取项目资源</h4><ul><li><p><strong>String getRealPath(String path)：获取资源的真实名称</strong></p><p>String path = servletContext.getRealPath(“/WEB-INF/a.jpg”);</p><p>返回值为/WEB-INF/a.jpg真实路径，即磁盘路径：C:/tomcat6/wabapps/hello/WEB-INF/a.jpg</p></li></ul><ul><li><p><strong>InputStream getResourceAsStream(String path)：获取资源的输入流</strong></p><p>InputStream in = servletContext.getResourceAsStream(“/WEB-INF/a.jpg”);</p><p>返回的是a.jpg的输入流对象，可以从流中得到a.jpg的数据</p></li></ul><ul><li><p><strong>Set<string> getResourcePaths(String path)：获取指定目录下的所有资源路径</string></strong></p><p>Set<string> paths = servletContext.getResourcePaths(“/WEB-INF”);</string></p><p>返回的Set中包含如下字符串：</p></li></ul><p>​    &gt; /WEB-INF/lib/</p><p>​    &gt; /WEB-INF/classes/</p><p>​    &gt; /WEB-INF/web.xml</p><p>​    &gt; /WEB-INF/a.jpg</p><h4 id="获取类路径资源"><a href="#获取类路径资源" class="headerlink" title="获取类路径资源"></a>获取类路径资源</h4><p>  可以通过Class类的对象来获取类路径下的资源，对应JavaWeb应用的类路径就是classes目录下的资源</p><p>  例如：</p><p>  <strong>InputStream in = com.xiaoqiang.servlet.MyServlet.class.getResourceAsStream(“a.jpg”);</strong></p><p>  获取的是：/WEB-INF/classes/com/xiaoqiang/servlet/a.jpg，即与MyServlet.class同目录下的资源</p><p>  例如：</p><p>  <strong>InputStream in =  com.xiaoqiang.servlet.MyServlet.class.getResourceAsStream(“/a.jpg”);</strong></p><p>  获取的是：/WEB-INF/classes/a.jpg，即类路径的根目录下的资源，类路径的根目录就是/classes目录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h2&gt;&lt;p&gt;​        是javaweb的三大组件之一&lt;/p&gt;
&lt;p&gt;​        主要用于处理客户端请求的动态资源   即获
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Web基础</title>
    <link href="https://aisnia.github.io/2019/09/10/Web%E5%9F%BA%E7%A1%80/"/>
    <id>https://aisnia.github.io/2019/09/10/Web基础/</id>
    <published>2019-09-10T02:18:33.000Z</published>
    <updated>2019-09-10T02:30:13.839Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-常见软件系统体系结构-B-S、C-S"><a href="#1-常见软件系统体系结构-B-S、C-S" class="headerlink" title="1        常见软件系统体系结构**B/S、C/S**"></a><strong>1</strong>        <strong>常见软件系统体系结构**</strong>B/S<strong><strong>、</strong></strong>C/S**</h4><ul><li><p><strong>C/S   客户端服务器</strong></p></li><li><p><strong>BS即 浏览器服务器</strong></p></li></ul><h4 id="2-Web资源"><a href="#2-Web资源" class="headerlink" title="2    Web资源"></a><strong>2    Web资源</strong></h4><ul><li><p><strong>静态资源：html</strong></p></li><li><p><strong>动态资源：</strong>JSP/Servlet 先转变为静态资源</p></li></ul><h4 id="3-访问Web资源"><a href="#3-访问Web资源" class="headerlink" title="3    访问Web资源"></a><strong>3</strong>    访问Web资源</h4><p>​    打开浏览器，输入URL：</p><p>​    协议名://域名:端口/路径，   <a href="http://www.baidu.com:80/index.heml" target="_blank" rel="noopener">http://www.baidu.com:80/index.heml</a></p><p>​    域名对应 一个IP地址 对应个服务器</p><h4 id="4-Web服务器"><a href="#4-Web服务器" class="headerlink" title="4　Web服务器"></a><strong>4</strong>　<strong>Web</strong>服务器</h4><p>​    <strong>Web服务器的作用是接收客户端的请求，给客户端作出响应。</strong></p><p>对于JavaWeb程序而已，还需要有<strong>JSP/Servlet容器</strong>，JSP/Servlet容器的基本功能是把动态资源转换成静态资源，当然JSP/Servlet容器不只这些功能，我们会在后面一点一点学习。</p><p>我们需要使用的是Web服务器和JSP/Servlet容器，通常这两者会集于一身。下面是对JavaWeb服务器：</p><ul><li><p>Tomcat（Apache）：当前应用最广的JavaWeb服务器；</p></li><li><p>JBoss（Redhat红帽）：支持JavaEE，应用比较广；EJB容器</p></li><li><p>GlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广；</p></li><li><p>Resin（Caucho）：支持JavaEE，应用越来越广；</p></li><li><p>Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目；</p></li><li><p>Websphere（IBM）：要钱的！支持JavaEE，适合大型项目；</p></li></ul><h3 id="5-tomcat目录结构"><a href="#5-tomcat目录结构" class="headerlink" title="5. tomcat目录结构"></a><strong>5. tomcat目录结构</strong></h3><ul><li><p>bin：二进制可执行文件，例如startup.bat和shutdown.bat</p></li><li><p>conf：配置文件，例如：server.xml、context.xml、web.xml、tomcatusers.xml</p></li><li><p>lib：tomcat所需jar包</p></li><li><p>logs：日志文件</p></li><li><p>temp：存放tomcat运行时产生的临时文件，当tomcat关闭后，这个目录中的文件可以删除</p></li><li><p>webapps：这个目录下的每个文件夹对应一个JavaWeb应用程序</p></li><li><p>work：webapps下的应用程序在运行时会自动生成文件，就在work目录下。work目录删除了也没问题，但再次运行应用程序还要再生成work目录和文件</p></li></ul><h4 id="6：http协议："><a href="#6：http协议：" class="headerlink" title="6：http协议："></a><strong>6：http协议：</strong></h4><p>就是 客户端和服务器的协议，双方通信的协议</p><p><strong>请求协议</strong>：客户端</p><p>格式：</p><p>​    请求首行</p><p>​    请求头信息</p><p>​    空行</p><p>​    请求体</p><p>请求方法有许多中，其中最常见的是get和post请求</p><ul><li><p>GET请求：没有请求体</p></li><li><p>POST请求：一般是配合表单的提交使用 method=“post”：</p></li></ul><p><strong>响应协议</strong>： 服务器</p><p>​    格式：</p><p>​    响应首行；</p><p>​    响应头信息；</p><p>​    空行；</p><p>​    响应体。</p><h4 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a><strong>常见请求头</strong></h4><ul><li><p><strong>Host</strong>：请求的服务器主机名</p></li><li><p><strong>User-Agent</strong>：客户端浏览器与操作系统相关信息</p></li><li><p><strong>Accept-Encoding</strong>：客户端支持的数据压缩格式</p></li><li><p><strong>Connection</strong>：客户端支持的连接方式</p></li><li><p><strong>Cookie</strong>：客户端发送给服务器的“小甜点”，它服务器寄存在客户端的。如果当前访问的服务器没有在客户端寄存东西，那么就不会存在它！</p></li><li><p><strong>Content-Length</strong>：请求体的长度</p></li><li><p><strong>Referer</strong>：当前发出请求的地址，例如在浏览器地址栏直接访问服务器，那么没有这个请求头。如果是在<a href="http://www.baidu.com页面上点击链接访问的服务器，那么这个头的值就是www.baidu.com" target="_blank" rel="noopener">www.baidu.com页面上点击链接访问的服务器，那么这个头的值就是www.baidu.com</a></p></li></ul><p>​        &gt; 作用1：统计来源</p><p>​        &gt; 作用2：防盗链</p><ul><li><strong>Content-Type</strong>：如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码。</li></ul><h4 id="响应码："><a href="#响应码：" class="headerlink" title="响应码："></a>响应码：</h4><ul><li><p><strong>200</strong>：请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中；</p></li><li><p><strong>404</strong>：请求的资源没有找到，说明客户端错误的请求了不存在的资源；</p></li><li><p>500：请求资源找到了，但<strong>服务器内部出现了错误；</strong></p></li><li><p><strong>302</strong>：重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个                                              响应头Location，它指定了新请求的URL地址</p></li><li><p><strong>304</strong>：当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第二     次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html</p></li></ul><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/cfc55c793bc74ac1a0f9073a57d3831e/ip_image002.jpeg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-常见软件系统体系结构-B-S、C-S&quot;&gt;&lt;a href=&quot;#1-常见软件系统体系结构-B-S、C-S&quot; class=&quot;headerlink&quot; title=&quot;1        常见软件系统体系结构**B/S、C/S**&quot;&gt;&lt;/a&gt;&lt;strong&gt;1&lt;/stron
      
    
    </summary>
    
    
      <category term="Web核心技术" scheme="https://aisnia.github.io/tags/Web%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>原子性和CAS算法</title>
    <link href="https://aisnia.github.io/2019/09/07/%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8CCAS%E7%AE%97%E6%B3%95/"/>
    <id>https://aisnia.github.io/2019/09/07/原子性和CAS算法/</id>
    <published>2019-09-07T07:23:41.000Z</published>
    <updated>2019-09-07T07:25:45.703Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、i-原子性的问题"><a href="#1、i-原子性的问题" class="headerlink" title="1、i++原子性的问题"></a><strong>1、i++原子性的问题</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">i=i++;  <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">底层是这样子的 </span><br><span class="line"><span class="keyword">int</span> temp=i;</span><br><span class="line">i=i+<span class="number">1</span>;</span><br><span class="line">返回的是 temp;</span><br><span class="line"></span><br><span class="line">i=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/e3fe52eba4c349df8ffaa0d8c5766d72/clipboard.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26-16:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicDemo atomicDemo = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(atomicDemo).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + getSerialNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">Thread-<span class="number">6</span>: <span class="number">4</span></span><br><span class="line">Thread-<span class="number">4</span>: <span class="number">3</span></span><br><span class="line">Thread-<span class="number">5</span>: <span class="number">5</span></span><br><span class="line">Thread-<span class="number">0</span>: <span class="number">2</span></span><br><span class="line">Thread-<span class="number">3</span>: <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span>: <span class="number">0</span></span><br><span class="line">Thread-<span class="number">2</span>: <span class="number">0</span></span><br><span class="line">Thread-<span class="number">8</span>: <span class="number">7</span></span><br><span class="line">Thread-<span class="number">7</span>: <span class="number">6</span></span><br><span class="line">Thread-<span class="number">9</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>输出有相同的</strong></p><h4 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a><strong>原子变量</strong></h4><p>jdk1.5后java.util.concurent.atomic 包下面提供了常用的原子变量</p><p>​        <strong>1、有volatile 的 内存可见性特性</strong></p><p>​        <strong>2、用CAS(Compare and Swap)算法保证了数据的原子性</strong></p><h4 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a><strong>CAS算法</strong></h4><p>是硬件对于并发共享数据的支持</p><p>包含了三个操作数</p><p>内存值 V</p><p>预估值 A</p><p>更新值 B</p><p>当且仅当 V==A 时 才把 B的值赋值给 V ，否则将不做任何的操作</p><p>例如</p><p>还是之前的 i++</p><p> 分为两步</p><p>int temp=sn;</p><p>sn=sn+1;</p><p>现在在主存中 i=0</p><p>线程1 操作 先共享(获取)内存值 是   V1=0</p><p>当你执行 I++ 操作 或者修改操作 时     先拿到 这时主存中的值   A1=0;   然后你要修改后的更新值 B=1 这时其他线程没有改变其值，  然后先比较  V1是否等于 A1 是的话就执行 更新操作 修改i为 1  </p><p>线程2 操作 在获取主存中的值时，假设线程1还未修改完成，拿到的内存值是 V2=0;</p><p>这时线程2也要执行 修改的操作时  这时线程1已经将主存中的值修改为了 1</p><p>所以 A1=1   修改值B1=1  这时比较 V1！=A1  所有不执行任何的操作</p><p>这时线程2 不会阻塞 不会放弃CPU给的资源，会来第二次操作</p><p>所以效率方面是比 synchronized 锁要高</p><p><strong>模拟CAS算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26-19:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompareAndSwap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompareAndSwap cas = <span class="keyword">new</span> CompareAndSwap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> expectValue = cas.get();</span><br><span class="line">                    <span class="keyword">boolean</span> b = cas.compareAndSet(expectValue, (<span class="keyword">int</span>) (Math.random() * <span class="number">101</span>));</span><br><span class="line">                    System.out.println(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    获取内存值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span> (expectValue == oldValue) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expectValue == compareAndSwap(expectValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、i-原子性的问题&quot;&gt;&lt;a href=&quot;#1、i-原子性的问题&quot; class=&quot;headerlink&quot; title=&quot;1、i++原子性的问题&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、i++原子性的问题&lt;/strong&gt;&lt;/h4&gt;&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="https://aisnia.github.io/2019/09/07/volatile/"/>
    <id>https://aisnia.github.io/2019/09/07/volatile/</id>
    <published>2019-09-07T07:22:18.000Z</published>
    <updated>2019-09-07T07:23:11.642Z</updated>
    
    <content type="html"><![CDATA[<p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/a577e1bdafbc442091255afcac143c45/clipboard.png" alt="img"></p><p><strong>1：volatile</strong></p><p>当多个线程进行操作共享数据时，可以保证内存中数据的可见性</p><p>相较于 synchronized (ˈsɪŋkrənaɪzd)是一种较为轻量级的同步策略</p><p>注意：1、volatile 不具有 “互斥性”</p><p>​    2、 volatile 不能保证变量的 “原子性”  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26-16:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo threadDemo = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadDemo).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threadDemo.isFlag()) &#123;  <span class="comment">//一直卡着 明明是true了  为什么</span></span><br><span class="line">                System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//           一 同步锁 可以解决该问题  但是效率特别的低，因为锁的 占用和释放问题</span></span><br><span class="line">          <span class="comment">/*    (threadDemo) &#123;</span></span><br><span class="line"><span class="comment">                if (threadDemo.isFlag()) &#123;  //一直卡着 明明是true了  为什么</span></span><br><span class="line"><span class="comment">                    System.out.println("------------");</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    第二种解决方法  加volatile 增加可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag="</span> + isFlag());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/a577e1bdafbc442091255afcac143c45/clipboard.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>锁的优化与注意事项</title>
    <link href="https://aisnia.github.io/2019/09/07/%E9%94%81%E7%9A%84%E4%BC%98%E5%8C%96%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://aisnia.github.io/2019/09/07/锁的优化与注意事项/</id>
    <published>2019-09-07T07:07:17.000Z</published>
    <updated>2019-09-07T07:16:14.984Z</updated>
    
    <content type="html"><![CDATA[<p>锁是最常用的同步方法之一，但是在高并发的环境下，激烈的锁竞争会导致程序性能的下降，所有有一些有关锁的优化和注意事项</p><p>在多核的时代，使用多线程可以明显的提高系统的性能，但事实上，使用多线程的方式会增加系统额外的开销，对应多线程来说，除了处理功能外，还需要维护多线程华金的特有信息，如线程本身的元数据，线程的调度，线程上下文的切换，因此合理的并发，才能将多核CPU的性能发挥到极致</p><h3 id="有助于提高锁性能的几点建议"><a href="#有助于提高锁性能的几点建议" class="headerlink" title="有助于提高锁性能的几点建议"></a><strong>有助于提高锁性能的几点建议</strong></h3><h4 id="减少锁的持有时间"><a href="#减少锁的持有时间" class="headerlink" title="减少锁的持有时间"></a><strong>减少锁的持有时间</strong></h4><p>​        比如能下同步代码块的就可以写同步代码块，把需要同步的地方锁起来，而不是同步整个方法，只是必要时进行同步，这样就能明显减少线程持有锁的时间，提高系统的吞吐量</p><p>​        减少锁的持有时间有助于降低锁冲突的可能性，进而提高系统的并发能力</p><h4 id="减小锁力度"><a href="#减小锁力度" class="headerlink" title="减小锁力度"></a><strong>减小锁力度</strong></h4><p>​        比如ConcurrentHashMap这个类，它内部进一步的细分了若干个小的HashMap，称之段(Segment) 默认是16个段，如果要在ConcurrentHashMap里添加一个表项，并不是将整个的HashMap加上，而是根据hashcode得到该表项应该存放到那个段中，然后对该段加锁，并完成put操作，所以当多线程put数据到不同段的时候，就不会发生锁冲突，实现真正的并行</p><p>但是会有一个新的问题，即系统需要获取全局锁时，其消化的资源会比较多，比如size()方法，则需要获取每个段的锁才能顺利执行，但事实上jdk采用的是一种无锁的方式CAS来求和</p><p>所谓减少锁粒度，就是缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力</p><h4 id="读写分离锁来替换独占锁"><a href="#读写分离锁来替换独占锁" class="headerlink" title="读写分离锁来替换独占锁"></a><strong>读写分离锁来替换独占锁</strong></h4><p>​    使用ReadWriteLock读写锁来提高系统的性能，也是减小锁粒度的一种方式，上一节是通过数据结构实现的，这次读写锁则是通过系统功能点的分割</p><p>​    在读多写少的场合，使用读写锁可以有效的提升系统的并发能力</p><h4 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a><strong>锁分离</strong></h4><p>​    如果将读写锁的思想进一步的延伸，就是锁分离，读写锁根据操作功能的不同，进行了锁分离，利用类似的思想，也可以进行锁的分离，比如在LinkedBlockingQueue阻塞队列的实现,它的take()和put方法分别是对 队尾出队和队首入队，从理论上来说它们两个并不冲突，如果使用独占锁的话那么它们的操作就会相互影响，需要等待对方是否锁资源，锁竞争激烈</p><p>​    而使用两把不同的锁，分离take和put操作，则两个函数彼此独立，互补影响，不存在锁的竞争关系，提高了系统的并发能力</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h4><p>​    虚拟机在遇到一连串的对同一个锁不断进行请求和释放时，便会把所有的锁操作整合成对锁的一次请求从而减少对锁同步次数，叫做锁粗化，因为对同一个锁不同的进行请求，，同步释放，其也会消耗系统的资源</p><p>比如下面代码的转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(tlock)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变成锁一次</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java虚拟机对锁优化做出的努力"><a href="#java虚拟机对锁优化做出的努力" class="headerlink" title="java虚拟机对锁优化做出的努力"></a><strong>java虚拟机对锁优化做出的努力</strong></h4><h4 id="锁偏向"><a href="#锁偏向" class="headerlink" title="锁偏向"></a><strong>锁偏向</strong></h4><p>核心思想是：如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，这样就减少了大量有关锁请求的操作，从而提高了系统性能，偏向锁对于几乎没有锁竞争的场合，有较好的优化效果，而对于每次都是不同的线程来请求相同的锁，这种锁竞争激烈的场合，其效果不佳，还不如不用</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h4><p>如果偏向锁失败，虚拟机不会立即挂起线程，它还会使用轻量级锁的优化手段，它只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁，如果线程获取轻量级锁成功，则可以顺利的进入临界区，如果轻量级加锁失败，则表示其他的线程夺到了锁，那么当前线程的锁请求将会膨胀为重量级锁</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a><strong>自旋锁</strong></h4><p>锁膨胀后，虚拟机为了避免线程真实的在操作系统层面挂起，虚拟机还会做最后的努力-自旋锁，由于当前线程暂时无法获得锁，但是上面时候获取锁是一个未知数，也许在几个CPU周期后，就可以得到锁，如果这样，简单粗暴的挂起线程是一种得不偿失的操作，因此，系统会进行一次赌注：它假设在不就的将来，线程可以得到这把锁，因此，虚拟机会让当前线程做几次空循环(这也就是自旋的含义)，在经过若干循环后，如果可以得到锁，那么久顺利的进入临界区，如果还不能获得锁，那么才会真实的在操作系统层面挂起改线程</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h4><p>java在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过锁消除，可以节省毫无意义的请求锁的时间</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] createStrings()&#123;</span><br><span class="line">    Vector&lt;String&gt; v=<span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        v.add(Integer.toString(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v.toArray(<span class="keyword">new</span> String[]&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，Vector只是一个局部变量，并且没有传递到外面去，它一定是线程私有的，所以Vector内部所有的加锁同步都是没有必要的，如果虚拟机检测到这种情况，就会将这些无用的锁操作去除</p><p>锁消除涉及到 逃逸分析这一关键技术，所谓的逃逸分析就是观察某一个变量是否会逃逸出当前的作用域，在本例中 变量v是没有逃逸出这个 createStrings函数的，所有虚拟机可以大胆的将Vector的锁全部取出，否则就不能</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a><strong>ThreadLocal</strong></h4><p>这是一个线程的局部变量，也就是说，只有当前线程可以访问，所以自然是线程安全的</p><p>原理看 ThreadLocal的 set()方法 和 get()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程的对象</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//拿到线程的ThreadLocalMap </span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//key 为ThreadLocal的当前对象 </span></span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是有一个问题就是，线程不退出那么对象的引用一直都在，只有当线程退出时，Thread类会进行清理工作其中包括清理ThreadMap</p><p>但是我们使用线程时，线程一直没有退出清理，所以若一些大的对象还存在ThreadMap中，无法被回收，则会出现内存泄漏等问题，这时可以使用 ThreadLocal.remove()方法将这个变量异常移除，当然若手动的设置 ThreadLocal的引用为 null，那么ThreadMap也会被回收，，</p><p>其实ThreadMap类似于 WeakHashMap 其中key的外部强引用被回收时，ThreadMap中的key也会自动的变成null</p><p><strong>对性能有何帮助</strong></p><p>为每个线程分配一个独立的对象对系统性能也许是有帮助的，但也不一定，这完全取决于共享变量的内部逻辑，如果共享对象对于竞争的处理容易引起性能的损失，我们还是应该考虑使用ThreadLocal为每个线程分配单独的对象，比如随机数 Random对象</p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a><strong>无锁</strong></h2><p>对于并发的控制而言，锁是一种悲观的策略，它总是假设每一次临界区操作会产生冲突，造成并发问题，因此每次操作都小心翼翼的，如果有多个线程同时需要访问临界区的资源，就宁可牺牲性能让线程等待，所以锁会阻塞线程的执行，</p><p>无锁是一种乐观的策略，它会加锁资源之间没有冲突，所以不需要等待，所以所有的线程都可以在不停顿的状态下执行，当遇到冲突的时候，无锁会采用一种叫做比较交换的技术，（CAS Compare And Swap)来监控线程的冲突，一旦遇到冲突的产生，就重试当前的操作指导没有冲突为止 </p><p><strong>与众不同的并发策略，比较交换(CAS)</strong></p><p>程序看起来会更加的复杂，但其非阻塞性对死锁问题天生免疫，线程间的互相影响也比锁的方式要小，更重要的是，无锁的方式完全没有锁的竞争带来的系统的开销，也咩有线程间频繁的调度带来的开销，所有性能比锁好</p><p>CAS算法过程是这样子的，包含三个参数 CAS(V，E，N),V表示要更新的变量，E表示预期值，N表示新值，当且仅当 V值 等于 E值时，才会将V值设为N，若V 和 E不相等，则说明已经有其他的线程做了更新，当前线程说明都不做，最后CAS返回的是V值，并且允许再次的尝试</p><p><strong>无锁的线程安全整数：AtomicInteger</strong></p><p>也叫做原子类，是基于CAS算法来实现线程安全的，有如下的常见方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>   <span class="comment">//取得当前值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> newValue)</span> <span class="comment">//设置当前值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> <span class="comment">//  设置新值，获取旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect,<span class="keyword">int</span> u)</span>   <span class="comment">//如果当前值为expect，设置为u</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span>   <span class="comment">// i++ 当前值加1返回旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span>   <span class="comment">// i-- </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">// 当前值 加上 delta 返回旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span>    <span class="comment">//  ++i</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span>    <span class="comment">// --i</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span>   <span class="comment">//当前值 加上 delta 返回新值</span></span></span><br></pre></td></tr></table></figure><p>与之类似的类还有 AtomicLong,AtomicBoolean,AtomicReference </p><p>CAS算法的不足之处：当你获得对象当前的数据时，在准备为其修改为新值的时候，对象的值被其他线程修改了两次，而且进过这两次修改后，对象的值有恢复成了旧值，所有当前的线程无法判断这个对象是否被修改过，</p><p><strong>解决方法是 AtomicStampedReference 带有时间戳的对象引用</strong></p><p>它的内部不仅维护的对象的值，还维护了一个时间戳，在数组修改时，除了更新对象本身的数据，还要修改时间戳，当修改时，必须满足期望值还有时间戳，才能写入成功</p><p><strong>还有无锁的数组</strong></p><p>AtomicIntegerArray ， AtomicLongArray ， AtomicReferenceArray 常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/获取数组第i个下标元素</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取数组长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//将数组下标 i 设置为 newValue 并返回旧值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> newValue)</span></span></span><br><span class="line"><span class="function"><span class="comment">//进行CAS操作，如果第i个元素等于except，则设置为update，设置成功返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将第i个下标元素 加1   i++</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将第i个下标元素 减1  i--</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将第i个下标元素 加 delta</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> delta)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>让普通变量也可以成为原子变量 AtomicIntegerFieldUpdate</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-22:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Candidate</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">"score"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    检查 Update是否工作正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger allScore = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Candidate stu = <span class="keyword">new</span> Candidate();</span><br><span class="line">        Thread[] t = <span class="keyword">new</span> Thread[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i]=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">                        scoreUpdater.incrementAndGet(stu);</span><br><span class="line">                        allScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"score="</span> + stu.score);</span><br><span class="line">        System.out.println(<span class="string">"allScore="</span> + allScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>1、Updater只修改可见范围的变量，private就不行</p><p>2、确保变量被正确的读取，必须是volatile类型的</p><p>3、不支持static字段</p><p><strong>让线程之间互相帮助：细看SynchronousQueue的实现</strong></p><blockquote><p><a href="https://my.oschina.net/anxiaole/blog/768315" target="_blank" rel="noopener">https://my.oschina.net/anxiaole/blog/768315</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;锁是最常用的同步方法之一，但是在高并发的环境下，激烈的锁竞争会导致程序性能的下降，所有有一些有关锁的优化和注意事项&lt;/p&gt;
&lt;p&gt;在多核的时代，使用多线程可以明显的提高系统的性能，但事实上，使用多线程的方式会增加系统额外的开销，对应多线程来说，除了处理功能外，还需要维护多线
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>fork/join框架</title>
    <link href="https://aisnia.github.io/2019/09/07/fork-join%E6%A1%86%E6%9E%B6/"/>
    <id>https://aisnia.github.io/2019/09/07/fork-join框架/</id>
    <published>2019-09-07T07:04:35.000Z</published>
    <updated>2019-09-07T07:06:20.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分而治之：fork-join框架"><a href="#分而治之：fork-join框架" class="headerlink" title="分而治之：fork/join框架"></a><strong>分而治之：fork/join框架</strong></h2><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/f91db573de0346c2b664294931a6f4df/clipboard.png" alt="img"></p><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/686da4cf1bd44707b7d98d34a75047d2/clipboard.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.LongStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Instant start = Instant.now();</span><br><span class="line">      </span><br><span class="line">      ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">      </span><br><span class="line">      ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">50000000000L</span>);</span><br><span class="line">      </span><br><span class="line">      Long sum = pool.invoke(task);</span><br><span class="line">      </span><br><span class="line">      System.out.println(sum);</span><br><span class="line">      </span><br><span class="line">      Instant end = Instant.now();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//166-1996-10590</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Instant start = Instant.now();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt;= <span class="number">50000000000L</span>; i++) &#123;</span><br><span class="line">         sum += i;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      System.out.println(sum);</span><br><span class="line">      </span><br><span class="line">      Instant end = Instant.now();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//35-3142-15704</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//java8 新特性</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Instant start = Instant.now();</span><br><span class="line">      </span><br><span class="line">      Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">50000000000L</span>)</span><br><span class="line">                      .parallel()</span><br><span class="line">                      .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">      </span><br><span class="line">      System.out.println(sum);</span><br><span class="line">      </span><br><span class="line">      Instant end = Instant.now();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//1536-8118</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">259195479995561737L</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THURSHOLD = <span class="number">10000L</span>;  <span class="comment">//临界值</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.start = start;</span><br><span class="line">      <span class="keyword">this</span>.end = end;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> length = end - start;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(length &lt;= THURSHOLD)&#123;</span><br><span class="line">         <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">         </span><br><span class="line">         ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle); </span><br><span class="line">         left.fork(); <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line">         </span><br><span class="line">         ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle+<span class="number">1</span>, end);</span><br><span class="line">         right.fork(); <span class="comment">//</span></span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分而治之：fork-join框架&quot;&gt;&lt;a href=&quot;#分而治之：fork-join框架&quot; class=&quot;headerlink&quot; title=&quot;分而治之：fork/join框架&quot;&gt;&lt;/a&gt;&lt;strong&gt;分而治之：fork/join框架&lt;/strong&gt;&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程池</title>
    <link href="https://aisnia.github.io/2019/09/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://aisnia.github.io/2019/09/07/线程池/</id>
    <published>2019-09-07T06:51:00.000Z</published>
    <updated>2019-09-07T07:04:16.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程复用：线程池"><a href="#线程复用：线程池" class="headerlink" title="线程复用：线程池"></a><strong>线程复用：线程池</strong></h3><p>在实际的生产环境中，线程的数量必须得到控制，盲目的大量创建线程对系统性能是有伤害的</p><h3 id="1、什么是线程池？"><a href="#1、什么是线程池？" class="headerlink" title="1、什么是线程池？"></a><strong>1、什么是线程池？</strong></h3><p>线程池中，总有那么几个活跃的线程，当你需要使用线程时，可以从池子中随便拿一个线程，当完成工作时不必关闭线程，而是将这个线程归还到池子中，回到空闲的状态</p><h4 id="JDK对线程池的支持"><a href="#JDK对线程池的支持" class="headerlink" title="JDK对线程池的支持"></a><strong>JDK对线程池的支持</strong></h4><p>架构图</p><p>​    <img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/44032e19ad9a4a55873c9395c33e0b2f/clipboard.png" alt="img"></p><p>Executor框架提供了各种类型的线程池，主要有以下工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThread)</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个固定线程数量的线程池，该线程池的数量始终不变，当有一个新的任务提交时</span></span><br><span class="line"><span class="comment">    线程池中若有空闲的线程就立即执行，没有则新的任务会放在一个任务队列中，待有空闲</span></span><br><span class="line"><span class="comment">    的线程时在执行*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingelThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个只有一个线程的线程池，若多于一个任务提交到线程池中，任务会保存到一个任务</span></span><br><span class="line"><span class="comment">    队列中，待线程空闲，会按照先入先出的顺序执行队列中的任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个可根据实际情况调整线程数量的线程池，若有空闲的线程，则任务优先分配空闲</span></span><br><span class="line"><span class="comment">    的可复用的线程，否则会创建新的线程处理任务，线程在当前任务完成后，将返回线程池*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newSingleThreadScheduledExecutor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*返回一个ScheduledExecutorService的线程池 大小为1，在ExecutorService 接口上扩展</span></span><br><span class="line"><span class="comment">    了接受定时执行任务的功能，周期执行*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> nThread)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回ScheduledExecutorService 可指定线程数量的线程池</span></span></span><br></pre></td></tr></table></figure><p><strong>计划任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay,</span><br><span class="line">                                    TimeUnit unit);</span><br><span class="line">   <span class="comment">// 给定时间，对任务进行一次调度</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                            <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                            <span class="keyword">long</span> period,</span><br><span class="line">                                            TimeUnit unit);</span><br><span class="line">       <span class="comment">//创建一个任务，任务开始于给定的初始延迟，后序任务按照周期执行，比如第一个任务</span></span><br><span class="line">       <span class="comment">//将在 initialDelay+period 时执行，而第二个任务将在 initialDelay+2*period</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                <span class="keyword">long</span> delay,</span><br><span class="line">                                                TimeUnit unit)</span><br><span class="line">  <span class="comment">//  创建并执行一个周期性任务，任务开始于初始延迟，第二个任务在第一个任务</span></span><br><span class="line">   <span class="comment">// 执行完成后的delay时间后执行</span></span><br></pre></td></tr></table></figure><p><strong>刨根究底：核心线程池的内部实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThread)</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingelThreadExecutor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>三个线程的实现方式其实都是一样的即 返回一个 return new ThreadPoolExecutor(……)对象</p><p>其构造方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>其中每个参数的意义</p><table><thead><tr><th>corePoolSize</th><th>指定线程池中线程的数量</th></tr></thead><tbody><tr><td>maximumPoolSize</td><td>线程池中最大线程数量</td></tr><tr><td>keepAliveTime</td><td>当线程池数量超过corePoolSize时，多余线程的存活时间</td></tr><tr><td>unit</td><td>keepAliveTime 的时间单位</td></tr><tr><td>workQueue</td><td>任务队列，被提交但尚未被执行的任务</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，一般用默认的即可</td></tr><tr><td>handler</td><td>拒绝策略，当任务太多来不及处理，如何拒绝任务</td></tr></tbody></table><h4 id="workQueue-任务队列"><a href="#workQueue-任务队列" class="headerlink" title="workQueue 任务队列"></a><strong>workQueue</strong> 任务队列</h4><p>指被提交但是为执行的任务队列，是一个BlockingQueue对象，只能存放Runnable对象，其中可以使用以下几种对象</p><ul><li><p>直接提交的队列：该功能有SynchronousQueue 对象提供，它是一个特殊的BlockingQueue，没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待一个插入操作，如果是同SynchronousQueue，提交的任务不会被真实的保存，而总是将新任务提交给线程执行，如果没有空闲的线程则尝试创建新的线程，如果线程数量已经达到了最大值，则执行拒绝策略，因此使用SynchronousQueue 队列，通常设置很大的maximumPoolSize，否则很容易执行拒绝策略。</p></li><li><p>有界的任务队列：使用ArrayBlockingQueue实现，带有一个容量参数<code>public ArrayBlockingQueue(int capacity)</code>当使用有界的任务队列时，若有新的任务需要执行，如果线程的实际线程数小于corePoolSize，则优先创建新的线程，若大于corePoolSize，则会将新的任务加入到等待队列，若队列已满，无法加入，则在总线程数不大于maximumPoolSize的前提下，创建新的线程执行任务，若大于maximumPoolSize，则执行拒绝策略</p></li><li><p>无界的任务队列，通过LinkedBlockingQueue类实现的，与有界的队列相比，除非系统的资源耗尽，否则不会出现任务入队失败的情况，当有新的任务来到，系统的线程小于corePoolSize时，线程池会生成新的线程执行任务，若线程数达到corePoolSize时，就不会继续增加，若后续仍有新的任务加入，而有没有空闲的线程，则任务直接加入等待队列，若任务创建和处理的速度相差很大则无界队列会快速增长，直到耗尽系统的内存。</p></li><li><p>优先任务队列：优先任务队列是带有执行优先级的队列，通过PriorityBlockingQueue实现，可以控制任务的执行先后顺序，它是一特殊的无界队列</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*其中用的是LinkedBlockingQueue队列，corePoolSize和maximumPoolSize相等，无界队列存放无法立即执行的任务</span></span><br><span class="line"><span class="comment">当任务提交非频繁时，改队列会迅速膨胀，从而耗尽系统资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单线程线程池，是newFixedThreadPool的一种简化，将线程数量设置为1了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">corePoolSize为0，最大容量为无限大，这意味着没有任务执行时，改线程内是没有线程的，当任务被提交时，该线程会使用空闲的线程执行任务，</span></span><br><span class="line"><span class="comment">若无空闲的线程，则将任务加入到SynchronousQueue 队列，而SynchronousQueue 队列是一种直接提交的队列，它会迫使线程池增加新的线程</span></span><br><span class="line"><span class="comment">执行任务，当线程执行完毕后，由于corePoolSize为0，因此空闲的线程有会在指定的时间内（60）秒回收</span></span><br><span class="line"><span class="comment">但当有大量的任务被提交时，而任务不能执行太快时，那么系统会开启大量的线程，而使系统的资源消耗过快*/</span></span><br></pre></td></tr></table></figure><p><strong>ThreadPoolExecutor 线程池的核心调度代码，冲分体现了上诉线程池的工作逻辑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">   <span class="comment">/*分三步进行：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      * 1.如果正在运行少于corePoolSize的线程，请尝试</span></span><br><span class="line"><span class="comment">      *首先使用给定命令启动一个新线程</span></span><br><span class="line"><span class="comment">      *任务。 对addWorker的调用以原子方式检查runState和</span></span><br><span class="line"><span class="comment">      * workerCount，因此可以防止会添加的错误警报</span></span><br><span class="line"><span class="comment">      *线程何时不应该，返回false。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      * 2.如果任务可以成功排队，那么我们仍然需要</span></span><br><span class="line"><span class="comment">      *仔细检查我们是否应该添加一个帖子</span></span><br><span class="line"><span class="comment">      *（因为现有的自上次检查后死亡）或那</span></span><br><span class="line"><span class="comment">      *自进入此方法后，池关闭。 所以我们</span></span><br><span class="line"><span class="comment">      *重新检查状态，如有必要，回滚入队if</span></span><br><span class="line"><span class="comment">      *停止，或者如果没有则启动新线程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      * 3.如果我们无法排队任务，那么我们尝试添加新的</span></span><br><span class="line"><span class="comment">      *线程。 如果失败，我们知道我们已关闭或饱和</span></span><br><span class="line"><span class="comment">      *等等拒绝任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码第24行的workerCountOf()函数取得了当前线程池的线程总数，当线程总数小于coreSize时通过addWork()方法直接创建分配线程执行该任务，否则，则会在第29行的 workQueue.offer()</p><p>方法进入等待对列，若进入队列失败(比如当有界队列到达上限，或者是直接提交队列SynchronousQueue），则会执行第36行，交给线程池，如果当前线程数达到了max则提交失败，进行37行的拒绝策略，否则分配线程执行任务</p><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/ab50147f40b84096bf98a6c3a74e0401/clipboard.png" alt="img"></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a><strong>拒绝策略</strong></h3><p>ThreadPoolExecutor的最后一个参数RejectedExecutionHandler handler指定了拒绝的策略，拒绝策略可以说是系统超负荷运行时的不就措施通常由于压力太大引起的，也就是线程池中的线程已经用完，同时队列中也已经排满了，再也塞不下新的任务了，我们就需要一套机制，合理的处理这个问题，JDK提供了4中拒绝策略</p><ol><li><p>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常的工作</p></li><li><p>CallerRunsPolicy策略：只要线程池为关闭，该策略直接在调用者线程中，运行当前被丢弃的任务，显然这样做不会真的丢弃任务，但是任务提交线程的性能可能会急剧下降</p></li><li><p>DisCardOledestPolicy策略：改策略将丢弃最老的请求，也就是即将被执行的一个任务，并尝试再次提交当前任务</p></li><li><p>DisCardPolicy策略：改策略默默的丢弃无法处理的任务，不予任何的处理，</p></li></ol><p>以上的策略均实现了 RejectExecutionHandler接口，自定义拒绝策略可以实现这个接口自己扩展</p><p>自定义线程池与拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-10:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        MyTask task = <span class="keyword">new</span> MyTask();</span><br><span class="line">        <span class="comment">//定义线程池  初始为5个  最大也为5个，最大的等待队列为10个，拒绝策略不做任何处理 就打印一下信息记录或记录日志</span></span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">0L</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">                <span class="comment">//自定义 线程工厂 在创建后可以设置为 守护线程，还可以记录线程的创建</span></span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line">                        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">                        System.out.println(<span class="string">"create"</span> + t);</span><br><span class="line">                        <span class="keyword">return</span> t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        System.out.println(r.toString() + <span class="string">" is discard"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            es.submit(task);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义线程创建"><a href="#自定义线程创建" class="headerlink" title="自定义线程创建"></a><strong>自定义线程创建</strong></h3><p>线程池创建线程是通过 ThreadFactory接口 的 唯一方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br></pre></td></tr></table></figure><p>当线程需要创建线程时就会调用这个方法</p><h3 id="线程池扩展"><a href="#线程池扩展" class="headerlink" title="线程池扩展"></a><strong>线程池扩展</strong></h3><p>ThreadPoolExecutor 提供了 beforeExecute() afterExecute() 和 rerminated()三个接口对线程池的控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-10:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"正在执行"</span> + <span class="string">":Thread ID:"</span> + Thread.currentThread().getId() + <span class="string">",Task Name="</span> + name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"准备执行"</span>+ ((MyTask)r).name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"执行完成"</span>+ ((MyTask)r).name);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            MyTask task = <span class="keyword">new</span> MyTask(<span class="string">"Task"</span> + i);</span><br><span class="line">            es.execute(task);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合理的选择：优化线程池线程的数量"><a href="#合理的选择：优化线程池线程的数量" class="headerlink" title="合理的选择：优化线程池线程的数量"></a><strong>合理的选择：优化线程池线程的数量</strong></h3><p>考虑到CPU的数量，内存等因素</p><p>堆栈去哪里了：在线程池中寻找堆栈</p><p>幽灵版的错误 案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/15-12:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DivTask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> re = a / b;</span><br><span class="line">        System.out.println(re);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">0L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            es.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打印的是</span><br><span class="line"><span class="number">25.0</span></span><br><span class="line"><span class="number">33.0</span></span><br><span class="line"><span class="number">100.0</span></span><br><span class="line"><span class="number">50.0</span></span><br></pre></td></tr></table></figure><p>只有4个结果，使用线程池虽然是一件好事，但还是有坑的，线程池很可能会 <strong>吃掉程序抛出的异常</strong> 导致我们对程序的错误一无所知</p><p>没有异常堆栈的信息</p><p>改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用</span><br><span class="line">es.execute(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line"></span><br><span class="line">或者在</span><br><span class="line">Future re=es.submit(<span class="keyword">new</span> DivTask(<span class="number">100</span>, i));</span><br><span class="line">re.get();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程复用：线程池&quot;&gt;&lt;a href=&quot;#线程复用：线程池&quot; class=&quot;headerlink&quot; title=&quot;线程复用：线程池&quot;&gt;&lt;/a&gt;&lt;strong&gt;线程复用：线程池&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在实际的生产环境中，线程的数量必须得到控制，盲目的大量创建
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport</title>
    <link href="https://aisnia.github.io/2019/09/07/LockSupport/"/>
    <id>https://aisnia.github.io/2019/09/07/LockSupport/</id>
    <published>2019-09-07T06:49:38.000Z</published>
    <updated>2019-09-07T06:50:39.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程阻塞的工具类：LockSupport"><a href="#线程阻塞的工具类：LockSupport" class="headerlink" title="线程阻塞的工具类：LockSupport"></a><strong>线程阻塞的工具类：LockSupport</strong></h3><p>LockSupport.park(),允许在线程内任意位置让线程阻塞，并不需要像wait方法要先获取对象的锁，而且也没有中断的异常产生，在使用LockSupport.unpark()来恢复</p><p>其实就和信号量一样的，只不过它允许的信号量只有1个</p><p>当然如果被中断了不会抛出中断的异常，但还是会 设置中断标记为true的</p><p>他也可以设置 阻塞对象的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如 LockSupport.park(Object obj);</span><br><span class="line">当然在恢复时 也要带上 LockSupport.unpark(Object obj)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/skywang12345/p/3505784.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3505784.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程阻塞的工具类：LockSupport&quot;&gt;&lt;a href=&quot;#线程阻塞的工具类：LockSupport&quot; class=&quot;headerlink&quot; title=&quot;线程阻塞的工具类：LockSupport&quot;&gt;&lt;/a&gt;&lt;strong&gt;线程阻塞的工具类：LockSuppo
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier循环栅栏</title>
    <link href="https://aisnia.github.io/2019/09/07/CyclicBarrier%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F/"/>
    <id>https://aisnia.github.io/2019/09/07/CyclicBarrier循环栅栏/</id>
    <published>2019-09-07T06:43:55.000Z</published>
    <updated>2019-09-07T07:04:36.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="循环栅栏：CyclicBarrier"><a href="#循环栅栏：CyclicBarrier" class="headerlink" title="循环栅栏：CyclicBarrier"></a><strong>循环栅栏：CyclicBarrier</strong></h3><p>和CountDownLatch非常类似，比如：司令下达命令，要求10个士兵一起去执行任务，这时要求10个士兵先集合报道，接着，在一起去执行任务，当10个士兵把自己的任务都完成了，司令才对外宣布任务完成，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3-16:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(String name, CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                等待所有士兵到齐  直到计数达到10个才执行一次 司令的run方法 否则一直等待</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                doWork();</span><br><span class="line"><span class="comment">//                等待所有士兵完成任务</span></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">2</span>)*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">":任务完成!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag;</span><br><span class="line">            <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.flag = flag;</span><br><span class="line">                N = n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"司令：[士兵"</span> + N + <span class="string">"个，完成任务!]"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"司令：[士兵"</span> + N + <span class="string">"个，集合完毕!]"</span>);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">                ExecutorService executorService = Executors.newFixedThreadPool(N);</span><br><span class="line">                <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                司令的线程 BarrierRun 在</span></span><br><span class="line">                CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"集合队伍"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"士兵"</span> + i+<span class="string">"报道"</span>);</span><br><span class="line">                    executorService.submit(<span class="keyword">new</span> Soldier(<span class="string">"士兵"</span> + i, cyclicBarrier));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CyclicBarrier.await()有两个异常</p><p> 一个是中断的异常 InterruptedException 这是等待常见的异常</p><p>另一个是BrokenBarrierException 异常表示 CyclicBarrier已经受损了，系统无法等待所有的线程到齐，如果继续等待是徒劳无功的</p><p>比如上述代码中一个士兵线程被中断了，它会抛出中断的异常，而其他九个会抛出BrokenBarrierException 异常</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;循环栅栏：CyclicBarrier&quot;&gt;&lt;a href=&quot;#循环栅栏：CyclicBarrier&quot; class=&quot;headerlink&quot; title=&quot;循环栅栏：CyclicBarrier&quot;&gt;&lt;/a&gt;&lt;strong&gt;循环栅栏：CyclicBarrier&lt;/stro
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch闭锁</title>
    <link href="https://aisnia.github.io/2019/09/07/CountDownLatch%E9%97%AD%E9%94%81/"/>
    <id>https://aisnia.github.io/2019/09/07/CountDownLatch闭锁/</id>
    <published>2019-09-07T06:41:43.000Z</published>
    <updated>2019-09-07T06:43:16.569Z</updated>
    
    <content type="html"><![CDATA[<h3 id="倒计时器：CountDownLatch-闭锁"><a href="#倒计时器：CountDownLatch-闭锁" class="headerlink" title="倒计时器：CountDownLatch 闭锁"></a><strong>倒计时器：CountDownLatch 闭锁</strong></h3><p>只有其他线程所有的运算全部完成，当前运算才会继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>火箭倒计时</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3-15:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        模拟检查任务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>) * <span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"Check complete"</span>);</span><br><span class="line">            end.countDown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService exec = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.submit(demo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        等待检查</span></span><br><span class="line">        end.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        发射火箭</span></span><br><span class="line">        System.out.println(<span class="string">"Fire!"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟多个线程的计时操作"><a href="#模拟多个线程的计时操作" class="headerlink" title="模拟多个线程的计时操作"></a><strong>模拟多个线程的计时操作</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26-20:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        LatchDemo latchDemo = <span class="keyword">new</span> LatchDemo(countDownLatch);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(latchDemo).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"耗时为:"</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LatchDemo</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.latch = latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//            计数器递减一</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;倒计时器：CountDownLatch-闭锁&quot;&gt;&lt;a href=&quot;#倒计时器：CountDownLatch-闭锁&quot; class=&quot;headerlink&quot; title=&quot;倒计时器：CountDownLatch 闭锁&quot;&gt;&lt;/a&gt;&lt;strong&gt;倒计时器：CountDo
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReadWriterLock读写锁</title>
    <link href="https://aisnia.github.io/2019/09/07/ReadWriterLock%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>https://aisnia.github.io/2019/09/07/ReadWriterLock读写锁/</id>
    <published>2019-09-07T06:38:23.000Z</published>
    <updated>2019-09-07T06:39:12.520Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ReadWriterLock读写锁</strong></p><p>也叫读写分离锁，可以有效的帮助减少锁竞争，以提升系统的性能</p><p>读-读 不互斥：读读之间不会阻塞</p><p>读-写 互斥：读阻塞写，写也会阻塞读</p><p>写-写互斥 ：写写阻塞</p><p>如果系统中，读操作次数远远大于写操作，则读写锁可以发挥最大的功效，提示系统的性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/3-15:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handeRead</span><span class="params">(Lock lock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleWrite</span><span class="params">(Lock lock, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value = index;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReadWriteLockDemo demo = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">        Runnable readRunnable=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    demo.handeRead(readLock);</span><br><span class="line">                    demo.handeRead(lock);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeRunnable=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   demo.handleWrite(writeLock,<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">                   demo.handleWrite(lock,<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(readRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">18</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(writeRunnable).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;ReadWriterLock读写锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也叫读写分离锁，可以有效的帮助减少锁竞争，以提升系统的性能&lt;/p&gt;
&lt;p&gt;读-读 不互斥：读读之间不会阻塞&lt;/p&gt;
&lt;p&gt;读-写 互斥：读阻塞写，写也会阻塞读&lt;/p&gt;
&lt;p&gt;写-写互斥 ：写
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>信号量Semaphore</title>
    <link href="https://aisnia.github.io/2019/09/07/%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/"/>
    <id>https://aisnia.github.io/2019/09/07/信号量Semaphore/</id>
    <published>2019-09-07T06:32:40.000Z</published>
    <updated>2019-09-07T06:37:18.754Z</updated>
    
    <content type="html"><![CDATA[<p><strong>允许多个线程同时访问：信号量(Semaphore)</strong></p><p>信号量为多线程协作提供了更为强大的控制方法，可以指定多个线程，同时访问某一个资源</p><p>主要的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits,<span class="keyword">boolean</span> fair)</span> <span class="comment">//第二个参数指定是否公平</span></span></span><br></pre></td></tr></table></figure><p>构造信号量时，必须指定信号量的准入数，即同时能申请多少个许可，主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquir</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquirUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>其实和锁差不多，只不过这里可以控制多个线程，可以一次让多个线程进入，当慢了其他线程就不能进了，相当于锁了，可以控制访问线程的个数不至于太多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;允许多个线程同时访问：信号量(Semaphore)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;信号量为多线程协作提供了更为强大的控制方法，可以指定多个线程，同时访问某一个资源&lt;/p&gt;
&lt;p&gt;主要的构造函数&lt;/p&gt;
&lt;figure class=&quot;highlight ja
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock重入锁</title>
    <link href="https://aisnia.github.io/2019/09/07/ReentrantLock%E9%87%8D%E5%85%A5%E9%94%81/"/>
    <id>https://aisnia.github.io/2019/09/07/ReentrantLock重入锁/</id>
    <published>2019-09-07T06:19:58.000Z</published>
    <updated>2019-09-07T06:32:51.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、synchronized的功能扩展：重入锁"><a href="#1、synchronized的功能扩展：重入锁" class="headerlink" title="1、synchronized的功能扩展：重入锁"></a><strong>1、synchronized的功能扩展：重入锁</strong></h3><p><strong>重入锁使用java.util.concurrent.locks.ReentrantLock类来实现</strong></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLockReentrantLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">reentrantLock.lock();</span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//要同步的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始lock()方法加上锁，到后面一定要释放锁，所有unlock()方法必须放置finally里面</p><p>为什么叫可重入锁？</p><p>因为就像上面的代码一样，一个线程可以连续获得同一把锁，当天在释放的时候也要释放两次，除了这些，还提供了中断的功能</p><h4 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a><strong>中断响应</strong></h4><p>对应synchronized 来锁，一个线程在等待锁，其结果只有两种可能，一是获得锁从而继续执行，二是保持等待。而使用重入锁，可以对线程中断，也就是说，在请求锁的过程中，程序可以根据需求取消对锁的请求，对于解决死锁有一定的帮助</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-22:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock1 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock2 = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntLock</span><span class="params">(<span class="keyword">int</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="number">1</span>) &#123;</span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lock2.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                lock1.lockInterruptibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock1.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock1.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (lock2.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock2.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getId() + <span class="string">":线程退出"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        IntLock r1 = <span class="keyword">new</span> IntLock(<span class="number">1</span>);</span><br><span class="line">        IntLock r2 = <span class="keyword">new</span> IntLock(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">944</span>)</span><br><span class="line">at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="number">1263</span>)</span><br><span class="line">at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="number">317</span>)</span><br><span class="line">at com.xiaoqiang.juc.book1.IntLock.run(IntLock.java:<span class="number">34</span>)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:<span class="number">834</span>)</span><br><span class="line"><span class="number">13</span>:线程退出</span><br><span class="line"><span class="number">14</span>:线程退出</span><br></pre></td></tr></table></figure><p>一开始，t1 获取了 lock1，在请求lock2 ，  而t2获取了 lock2，再请求lock1，从而导致了死锁 其中 <strong>ReentrantLock.lockInterruptibly()</strong>方法 也是获取锁，不过是可以被打断的</p><h4 id="锁申请等待限时"><a href="#锁申请等待限时" class="headerlink" title="锁申请等待限时"></a><strong>锁申请等待限时</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-22:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get lock success"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get lock failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeLock t = <span class="keyword">new</span> TimeLock();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryLock()有两个重载的方法</p><p>一个是无参数的，这这这情况下，当前线程会尝试的获取锁，如果锁未被其他线程占用，则会申请锁成功，并立即返回true，如果锁被其他线程占用，则当前线程不会进行等待，而是立即的返回false</p><p>另一个是有两个参数的 一个表示等待时长long  timeout   一个代表计时的单位 TimeUtil里面有常量，上面代码里表示，正在线程请求锁的过程中最多请求5秒，如果超过五秒就返回 false，如果成功获得锁就返回true</p><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h3><p>在大多数情况下，锁的申请都是非公平的，也就是说，线程1首先请求了锁A，接着线程2也请求了锁A，那么当锁A可用时，是线程1获得锁，还是线程2获得锁呢？这是不一定的，系统只会从这个锁的等待队列中随机的挑选一个，而不能保证其公平性，</p><p>而公平的锁会按照时间的先后顺序，保证先到者先得到，后到者后得到。</p><p>公平锁的一大特点是：他不会产生饥饿现象，只要你排队就最终还是可以获得到资源</p><p>默认的ReentrantLock 和 synchronized 都是非公平的锁</p><p>但ReentrantLock  有个构造方法可以进行设置</p><p><code>public ReentrantLock(boolean fair)</code></p><p>当fair为true时，表示锁是公平的。虽然公平锁看上去很优美，但其实现比如要求系统维护一个有序的队列，因此成本比较高，性能也相对低下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock方法整理</span><br><span class="line">lock(): 获得锁，如果锁已经被占用，则等待</span><br><span class="line">lockInterruptibly(): 获得锁，如果锁被占用也会等待，但是可以被响应中断</span><br><span class="line">tryLock(): 尝试获得锁，如果成功，返回<span class="keyword">true</span>，失败返回<span class="keyword">false</span>，改方法不等待，立即返回</span><br><span class="line">tryLock(<span class="keyword">long</span> time , TimeUnit unit):在给定的时间内尝试获取锁</span><br><span class="line">unlock() 释放锁，放在<span class="keyword">finally</span>语句中</span><br></pre></td></tr></table></figure><h3 id="重入锁的好搭档Condition条件"><a href="#重入锁的好搭档Condition条件" class="headerlink" title="重入锁的好搭档Condition条件"></a><strong>重入锁的好搭档Condition条件</strong></h3><p> 如果说Object.wait() 和 Object.notify() 是和 synchronized关键字结合使用的话，</p><p>那么Condition就是和重入锁绑定的对象，利用它，也可以控制线程，让他在适合的时间等待，或者唤醒</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock 接口的 <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>; 方法可以生成一个与Lock绑定的Condition</span><br><span class="line"></span><br><span class="line">Condition的基本方法</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedExpection</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedExpetion</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedExpection</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>await()方法会是当前线程等待，同时释放当前锁，当其他线程使用 signal()或者signalAll()方法时，线程会重新获取锁，并继续执行，或者当前线程被中断时，也能跳出等待</p></li><li><p>awaitUninterruptibly();方法与 await方法基本相同，不过它并不会再等待过程中响应中断</p></li><li><p>singal()方法，用于唤醒一个等待的线程，而singalAll方法会唤醒所有等待中的线程</p></li></ul><h3 id="生产者与消费者案例"><a href="#生产者与消费者案例" class="headerlink" title="生产者与消费者案例"></a>生产者与消费者案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/27-12:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorAndConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Productor productor = <span class="keyword">new</span> Productor(clerk);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(productor, <span class="string">"生产者A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">"消费者B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(productor, <span class="string">"生产者C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">"消费者D"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//店员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    进货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (product &gt;= <span class="number">1</span>) &#123;     <span class="comment">//避免虚假唤醒问题wait用在 循环中</span></span><br><span class="line">            System.out.println(<span class="string">"产品已满"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//else &#123;</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+ ++product);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">      <span class="comment">//  &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    卖货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"缺货"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// else &#123;</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+ --product);</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition-的线程控制"><a href="#Condition-的线程控制" class="headerlink" title="Condition 的线程控制"></a><strong>Condition 的线程控制</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/27-12:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorAndConsumerForLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Productor productor = <span class="keyword">new</span> Productor(clerk);</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(productor, <span class="string">"生产者A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">"消费者B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(productor, <span class="string">"生产者C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer, <span class="string">"消费者D"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//店员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">//    进货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (product &gt;= <span class="number">1</span>) &#123;     <span class="comment">//避免虚假唤醒问题wait用在 循环中</span></span><br><span class="line">                System.out.println(<span class="string">"产品已满"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    this.wait();</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">//else &#123;</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+ ++product);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            this.notifyAll();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">//  &#125;</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    卖货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"缺货"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    this.wait();</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">// else &#123;</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+ --product);</span><br><span class="line"><span class="comment">//            this.notifyAll();</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程的交替执行"><a href="#线程的交替执行" class="headerlink" title="线程的交替执行"></a>线程的交替执行</h3><p><strong>题目：</strong></p><p>编写一个程序，开启三个线程，这三个线程 ID分别为A,B,C，没个线程将自己的ID在屏幕上打印10遍，要求输入的结果必须按顺序显示</p><p>若ABCABCABC依次递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/27-15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABCAlternate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AlternateDemo ad = <span class="keyword">new</span> AlternateDemo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ad.loopA(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ad.loopB(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ad.loopC(i);</span><br><span class="line">                    System.out.println(<span class="string">"------------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlternateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    当前执行线程的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//totalLoop 循环第几轮</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopA</span><span class="params">(<span class="keyword">int</span> totalLoop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            1.判断 标记是否为1</span></span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition1.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            唤醒</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopB</span><span class="params">(<span class="keyword">int</span> totalLoop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            1.判断 标记是否为1</span></span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition2.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            唤醒</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopC</span><span class="params">(<span class="keyword">int</span> totalLoop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            1.判断 标记是否为1</span></span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition3.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            唤醒</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、synchronized的功能扩展：重入锁&quot;&gt;&lt;a href=&quot;#1、synchronized的功能扩展：重入锁&quot; class=&quot;headerlink&quot; title=&quot;1、synchronized的功能扩展：重入锁&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、synchro
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程基础</title>
    <link href="https://aisnia.github.io/2019/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://aisnia.github.io/2019/09/06/并发编程基础/</id>
    <published>2019-09-06T06:34:00.000Z</published>
    <updated>2019-09-07T07:23:03.953Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程和线程</strong></h3><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.，进程是程序的实体，是线程的容器</p><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p><h3 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a><strong>线程的基本操作</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getname</span><span class="params">()</span> 获取线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span>  将该线程标记成守护线程或用户线程</span></span><br><span class="line"><span class="function"> *  当正在运行的线程读书守护线程时，Java虚拟机退出，该方法必须在线程启动前调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  Thread <span class="title">join</span><span class="params">()</span>  等待线程结束   别人才能抢</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> 中断线程 把线程状态终止，并抛出InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span> 暂停当前正在执行的线程对象，并执行其他线程</span></span><br></pre></td></tr></table></figure><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a><strong>新建线程</strong></h4><p>​    继承 Thread类，或者实现 Runable，Callable接口实现run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Oerride</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>调用线程的start方法就会 新建一个线程并让它去执行 run()方法</p><p>注意不要用run()来开启新线程，它只会在当前线程中串行的执行代码，相当于一个方法了，而不是另开线程</p><p>此外Thread()还有一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>;</span><br></pre></td></tr></table></figure><p>这个构造方法在调用start时就会自动新建线程并调用 Runnable.run()方法</p><h4 id="创建执行线程的方式三："><a href="#创建执行线程的方式三：" class="headerlink" title="创建执行线程的方式三："></a>创建执行线程的方式三：</h4><p>实现Callable方法，相较于实现Runnable 接口的方式，方法可以有返回值，并且可以抛出异常</p><p><strong>执行Callable方式 需要 FutureTask 实现类来支持，用于接受运算的结果，是实现了Future的接口的实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/26-20:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallDemo cd = <span class="keyword">new</span> CallDemo();</span><br><span class="line">        <span class="comment">//    执行Callable方式 需要 FutureTask 实现类来支持，用于接受运算的结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; res = <span class="keyword">new</span> FutureTask&lt;&gt;(cd);</span><br><span class="line">        <span class="keyword">new</span> Thread(res).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        接受线程运算的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        当上面的线程 执行完 才会 执行get()方法  说明FutureTask 也可用于闭锁的操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = res.get();</span><br><span class="line">            System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a><strong>终止线程</strong></h3><p>Thread.stop()方法可以立即将一个线程终止，但是已经被废止，因为stop()方法过于暴力，强行将程序停止，并立即释放这个线程所持有的锁，而导致一些问题</p><p><strong>一般是用一个Boolean量 flag来标记是否结束线程</strong> 而在run方法里面是 死循环的，当flag发生变化时跳出，即结束了线程，而使用下面的中断机制更好处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a><strong>中断线程</strong></h3><p><strong>严格来讲，线程中断并不会使线程立即退出，而是给线程发送一个通知，告诉目标线程，有人希望你退出啦!，至于目标线程接受到通知后处理，则由他自己决定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt();  <span class="comment">//中断线程,设置中断标记</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted();  <span class="comment">//判断是否被中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted();<span class="comment">//判断是否被中断，并清除当前的中断状</span></span><br></pre></td></tr></table></figure><h4 id="Thread-sleep-函数"><a href="#Thread-sleep-函数" class="headerlink" title="Thread.sleep()函数"></a>Thread.sleep()函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InrerruptedExpection</span></span><br></pre></td></tr></table></figure><p>让当前线程休眠若干时间(毫秒),并且会抛出InrerruptedExpection 中断异常，所有当线程在sleep()休眠时，被中断了，这个异常就会产生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="comment">//这里处理判断是否被中断了，还会清除标记</span></span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interrupted!"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedExpection e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Interrupted where Sleep"</span>);</span><br><span class="line">                <span class="comment">//重新设置中断状态</span></span><br><span class="line">                Thread.currentThread().interrupte();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：Thread.sleep()方法由于中断而抛出异常，此时它会清除中断的标记，为了下一次循环还是有标记，所以需要重新设置 如上16行代码</strong></p><h3 id="等待-wait-和-通知-notify"><a href="#等待-wait-和-通知-notify" class="headerlink" title="等待(wait) 和 通知(notify)"></a><strong>等待(wait) 和 通知(notify)</strong></h3><p>这两个方法不在Thread类中，而是Object中，也就意味着任何对象对可以掉用着两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedExpection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWN</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":T1 start! "</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">":T1 wait for object! "</span>);</span><br><span class="line">                    obj.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":T1 end! "</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":T2 start! notify one Thread"</span>);</span><br><span class="line">                obj.notify();</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":T2 end! "</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> T1();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> T2();</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1564730340787</span>:T1 start! </span><br><span class="line"><span class="number">1564730340827</span>:T1 wait <span class="keyword">for</span> object! </span><br><span class="line"><span class="number">1564730340827</span>:T2 start! notify one Thread</span><br><span class="line"><span class="number">1564730340828</span>:T2 end! </span><br><span class="line"><span class="number">1564730342832</span>:T1 end!</span><br></pre></td></tr></table></figure><p>当一个对象调用 wait()方法后，当前线程就会在这个对象上等待，比如线程A中，调用了 obj.wati()方法，那么线程A就会停止继续执行，而转为等待状态。 一直等待其他的线程调用了obj.notify()方法为止</p><p>工作原理：在一个线程调用 obj.wait()方法后，它就会进入object对象的等待队列，在这个队列中可能会有多个其他的线程，因为有可能其他的对象也在同时等待这个对象，当 obj.notify()被调用时，它就会从这个等待队列，<strong>随机</strong>选择一个线程，将其唤醒，</p><p>当然Object对象还有一个类似的方法，<strong>notifyAll()</strong>唤醒队列中所有等待的线程</p><h4 id="强调一点"><a href="#强调一点" class="headerlink" title="强调一点"></a><strong>强调一点</strong></h4><p>Object.wait()和notify()并不是可以随便调用的，必须先获取目标对象的锁（监听器），必须包含在对应的synchronized语句块中</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a><strong>图解</strong></h3><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/ffe11e89145648008e652cacdf6ce4c3/clipboard.png" alt="img"></p><p>注意：Object.wait()和Thread.sleep()方法都可以让线程等待若干时间，除了wait()可以被唤醒外，<strong>**另一个区别是 wait()会释放锁资源，而sleep()不会释放</strong></p><p><strong>挂起(suspend)和继续执行(resume)线程</strong></p><p>这与 wait和notify差不多，不过 suspend不会释放锁资源，不安全，已经弃用了</p><p><strong>等待线程结束(join) 和谦让(yield)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> <span class="title">InterruptedException</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>第一个join方法表示无限等待，她会一直阻塞当前线程，直到目标线程执行完毕，第二了方法给给出了最大的等待时间，如果超过了，也不会等了</p><p>补充一点：join的本质是 调用线程的wait()方法在当前线程对象上，而当目标线程执行完后会调用notifyAll()方法，所有在用join这些方法时，不要用wait和notify类似的方法，因为有影响的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>对于Thread.yield()方法，一旦执行会让出当前线程的CPU资源，但还是和其他线程一起抢CPU的资源</p><p><strong>线程组</strong></p><p>ThreadGroup</p><h3 id="驻守后台：守护线程-Daemon"><a href="#驻守后台：守护线程-Daemon" class="headerlink" title="驻守后台：守护线程(Daemon)"></a><strong>驻守后台：守护线程(Daemon)</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-19:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonT</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"I am alive"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> DaemonT();</span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意设置后台（守护）线程必须在线程 start之前 执行setDaemon(true)方法，在被守护的线程结束时，后台（守护）线程也会结束，如上面的代码 在main线程 结束后 t也会随之结束</p><p><strong>先干重要的事情：线程的优先级</strong></p><p>Java中的线程可以有自己的优先级，优先级越高的线程在竞争资源时候更有优势，更可能抢占资源，当然这只是一个概率问题，运气不好的话，优先级高的线程也可能抢占失败</p><p>在java中 1-10 表示线程的优先级，一般可以使用内置的三个静态标量表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.setPriority(Thread.NORM_PRIORITY);     <span class="number">5</span></span><br><span class="line">t.setPriority(Thread.MAX_PRIORITY);      <span class="number">10</span></span><br><span class="line">t.setPriority(Thread.MIN_PRIORITY);      <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>线程安全和synchronize</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-19:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountingVol</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AccountingVol a = <span class="keyword">new</span> AccountingVol();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(a.i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile只是保证了可见性，但不保证原子性，比如下面的i++操作就不是原子性的，就会出现并发安全问题</p><p>关键字synchronize的作用就是实现线程间的同步，它的工作是对同步的代码加锁，使得每一次，只能有一个线程进入同步块，从而保证线程的安全性</p><p>用法</p><p>1、给指定对象加锁</p><p>2、给实例方法加锁，获取的是当前实例对象的锁 即this</p><p>3、给静态方法加锁，获取的是当前类的锁，即Class对象</p><p><strong>并发下的ArrayList</strong> <a href="https://www.jianshu.com/p/41be1efe5d65" target="_blank" rel="noopener">https://www.jianshu.com/p/41be1efe5d65</a></p><p>测试如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-20:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListMultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">                al.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(al.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有三种情况：</p><p>1、程序正常的结束最后大小是2000000，说明并行的程序有问题，但不会每次都显示出来</p><p>2、程序抛出异常，ArrayIndexOutofBoundsException：数组越界异常</p><p>3、ArrayList的大小 小于 2000000</p><p><a href="https://www.jianshu.com/p/41be1efe5d65" target="_blank" rel="noopener">https://www.jianshu.com/p/41be1efe5d65</a></p><p><strong>并发下的诡异的HashMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.juc.book1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2-20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapMultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="number">10000</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(Integer.toString(i), Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">0</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>也有三种情况</strong></p><p>1、程序正常结束，大小为100000。 </p><p>2、程序正常结束，但结果是 小于 100000 的数，因为和ArrayList差不多的情况</p><p>3、程序无法结束， 链表变成了循环链表了</p><p>原因：<a href="https://blog.csdn.net/eson_15/article/details/51543812" target="_blank" rel="noopener">https://blog.csdn.net/eson_15/article/details/51543812</a></p><p><a href="https://blog.csdn.net/eson_15/article/details/51543812" target="_blank" rel="noopener">https://blog.csdn.net/eson_15/article/details/51543812</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;&lt;strong&gt;进程和线程&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发常见用语</title>
    <link href="https://aisnia.github.io/2019/09/06/%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E7%94%A8%E8%AF%AD/"/>
    <id>https://aisnia.github.io/2019/09/06/并发常见用语/</id>
    <published>2019-09-06T06:20:51.000Z</published>
    <updated>2019-09-06T06:33:31.687Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、同步和异步"><a href="#1、同步和异步" class="headerlink" title="1、同步和异步"></a><strong>1、同步和异步</strong></h3><p>同步和异步通常是用来形容一次方法的调用</p><p>同步的方法一旦被调用，必须等待调用的返回，才能进行后续的行为</p><p>异步方法更像一个消息的传递，一旦开始，方法会立即返回，可以做其他的事情，而另一个线程就正在执行这个方法，不会阻碍继续后续的执行</p><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/fc509607cc3a4abe92b8ab867c7ecddf/clipboard.png" alt="img"></p><p>打个比方，你去超市购物，买一个空调，当你下了单，催促着售货员帮你送回家，直到商家把你和空调一起送回家，中间你只能在那等着，这就是同步</p><p>如果你是在家网购的话，只需要在网上下个单支付完后，这时对于你来说购物已经结束了，虽然空调还未到家，但是你的任务已经完成了，商家的出货配送已经与你没有关系，这段时你想干嘛就干嘛做自己的事情，等送货上门时，只需要签收就行</p><h3 id="2、并行与并发"><a href="#2、并行与并发" class="headerlink" title="2、并行与并发"></a><strong>2、并行与并发</strong></h3><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/dba41f40ef574fb88787ca4a1ed43d72/clipboard.png" alt="img"></p><p>并行是真正意义上的同时执行，即多个线程在同一时刻同时执行某一任务</p><p><strong>并发是交替的执行，</strong></p><h3 id="3、临界区"><a href="#3、临界区" class="headerlink" title="3、临界区"></a><strong>3、临界区</strong></h3><p>临界区用来表示一种公共资源或者说是共享的数据，它可以被多个线程使用，但每一次，只有一个线程使用它，一旦临界区资源被占用，其他线程想要使用这个资源没救必须等待</p><h3 id="4、阻塞-Blocking-和非阻塞-Non-Blocking"><a href="#4、阻塞-Blocking-和非阻塞-Non-Blocking" class="headerlink" title="4、阻塞(Blocking)和非阻塞(Non-Blocking)"></a><strong>4、阻塞(Blocking)和非阻塞(Non-Blocking)</strong></h3><p>阻塞和非阻塞是形容多线程之间的相互影响</p><p>阻塞：比如一个线程占用了临界区的资源，那么另一个请求这个资源的线程就必须等待，而导致线程的挂起</p><p>非阻塞：强调没有一个线程可以妨碍其他线程的执行，所有的线程都会尝试不断的向前执行</p><h3 id="5、死锁-DeadLock-，饥饿-Starvation-，活锁-Livelock"><a href="#5、死锁-DeadLock-，饥饿-Starvation-，活锁-Livelock" class="headerlink" title="5、死锁(DeadLock)，饥饿(Starvation)，活锁(Livelock)"></a><strong>5、死锁(DeadLock)，饥饿(Starvation)，活锁(Livelock)</strong></h3><ul><li><p><strong>死锁</strong>：当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，我们称为死锁。</p></li><li><p><strong>饥饿</strong>：我们知道多线程执行中有线程优先级这个东西，优先级高的线程能够插队并优先执行，这样如果<strong>优先级高的线程一直抢占优先级低线程的资源，导致低优先级线程无法得到执行</strong>，这就是饥饿。当然还有一种饥饿的情况，一个线程一直占着一个资源不放而导致其他线程得不到执行，与死锁不同的是饥饿在以后一段时间内还是能够得到执行的，如那个占用资源的线程结束了并释放了资源。</p></li><li><p><strong>活锁</strong>：活锁这个概念大家应该很少有人听说或理解它的概念，而在多线程中这确实存在。活锁恰恰与死锁相反，死锁是大家都拿不到资源都占用着对方的资源，而活锁是拿到资源却又相互释放不执行。当多线程中出现了相互谦让，都主动将资源释放给别的线程使用，这样这个资源在多个线程之间跳动而又得不到执行，这就是活锁。比如生活中的让路，你向左，它向右有碰到一起了</p></li><li><p><strong>无锁</strong>：即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。之前的文章我介绍过JDK的CAS原理及应用即是无锁的实现。</p></li></ul><h3 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a><strong>并发级别</strong></h3><p><strong>1、阻塞(Blocking)</strong></p><p>一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行，当用sychronized 关键字 或者 重入锁，会有线程阻塞</p><p><strong>2、无饥饿(Starvation-Free)</strong></p><p>线程是公平的，没有优先级的比较，所有线程想要获取资源机会是一样的，这个取决于线程之间是否有优先级的存在，如果系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。</p><p><strong>3、无障碍(Obnstruction-Free)</strong></p><p>无障碍是一种最弱的非阻塞调度。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。换言之，大家都进入临界区了。那么如果一起修改共享数据，把数据改坏了可怎么办呢？<strong>对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。如果说阻塞的控制方式是悲观策略，相对来说非阻塞的调度就是一种乐观的策略。</strong>从这个策略中也可以看到，当临界区中存在严重的冲突时，所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。</p><p>一种可行的无障碍实现可以依赖一个“一致性标记”来实现,即版本控制)，比如modCount。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。</p><p>Obstruction-free 是指在任何时间点，一个孤立运行线程的每一个操作可以在有限步之内结束。<strong>只要没有竞争，线程就可以持续运行，一旦共享数据被修改，Obstruction-free 要求中止已经完成的部分操作，并进行回滚。</strong></p><p><strong>4、无锁（Lock-freedom）</strong></p><p>在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，无锁的并发保证必然有一个线程能够<strong>在有限步内完成操作离开临界区</strong>，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果修改成功，程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程是可以胜出的。至于临界区中竞争失败的线程，它们则不断重试，直到自己获胜。如果总是尝试不成功，则会出现类似饥饿的现象，线程会停止不前。</p><p>Lock-freedom 指的是<strong>整个系统作为一个整体一直运行下去</strong>，系统内部单个线程某段时间内可能会饥饿，这是比wait-freedom弱的并发级别，但系统整体上看依然是没有阻塞的。所有wait-free的算法显然都满足lock-free的要求。<strong>Lock-free算法通常可以通过循环+同步原语CAS实现。</strong></p><p><strong>5、无等待(Wait-Free)</strong></p><p><strong>无锁只要求有一个线程可以在有限步内完成操作</strong>，而无等待则在无锁的基础上更进一步进行扩展。<strong>它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题</strong>。如果限制这个步骤上限，还可以进一步分解为有界无等待和线程数无关的无等待几种，它们之间的区别只是对循环次数的限制不同。</p><p>一种典型的无等待结构就是RCU(Read-Copy-Update)。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据(这就是为什么读可以不加控制)，修改完成后，在合适的时机回写数据。</p><p><strong>一：原子性(Atomicity)</strong></p><p>不可分割，一个操作是不可中断的，一定会执行，</p><p>不然int类型赋值和读取操作，当然long和double就不一定了，因为对于32位系统的来说（long和double是64位的）他们的读写不是原子的</p><p><strong>二：可见性（Visibility）</strong></p><p>可见性是指当一个线程修改了某一个共享的变量，其他线程是否能够立即知道这个修改</p><p><strong>三：有序性(Ordering)</strong></p><p>就是写在前面的代码，可能会在后面执行</p><p>原因是：在程序执行是，可能会进行指令重排，重排后后的指令可能与原来的顺序不一样，下面有个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=a+<span class="number">1</span>;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入A线程首先执行 writer()方法，紧接着B执行执行reader()方法，加入B执行到了第10行进入了if语句，这时不一定能看到 a已经被赋值为1了，因为可能发生了指令重排，先执行的是 flag=true；这个指令</p><p>指令重排不会让逻辑发生变化的，上面两个赋值的操作相互之间没有影响，调换位置也没关系，所有可能发生指令重排序，总之指令重排序的结果是不会改变的</p><p><strong>为什么要指令重排？</strong></p><p> 主要还是编译器以及CPU为了优化代码或者执行的效率而执行的优化操作；应用条件是单线程场景下，对于并发多线程场景下，指令重排会产生不确定的执行效果。</p><p><a href="http://mageek.cn/archives/99/" target="_blank" rel="noopener">http://mageek.cn/archives/99/</a></p><p><strong>那些指令不能重排序(happens-before原则（先行发生原则）</strong></p><p>1、程序顺序原则：一个线程内保证语义的串行，</p><p>2、volatile规则：volatile变量的写，先发生于读，保证了可见性</p><p>3、锁规则：解锁必然在加锁前</p><p>4：传递性：A先与B。B先于C，A一定先于C</p><p>5、线程的start方法，先于它的每一个动作</p><p>6、线程的所有操作先于线程的终结</p><p>7、线程的中断先于被中断的代码</p><p>8、对象的构造函数执行，结束先于先于finalize()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、同步和异步&quot;&gt;&lt;a href=&quot;#1、同步和异步&quot; class=&quot;headerlink&quot; title=&quot;1、同步和异步&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、同步和异步&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;同步和异步通常是用来形容一次方法的调用&lt;/p&gt;
&lt;p&gt;同步的方法一
      
    
    </summary>
    
    
      <category term="并发" scheme="https://aisnia.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
