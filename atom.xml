<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陌染殇雪</title>
  
  <subtitle>命运不会亏待正在努力变好的你.</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://cxqiang.gitee.io/blog/"/>
  <updated>2019-08-31T03:13:08.799Z</updated>
  <id>http://cxqiang.gitee.io/blog/</id>
  
  <author>
    <name>xiaoqiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/System/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/System/</id>
    <published>2019-08-31T02:56:42.147Z</published>
    <updated>2019-08-31T03:13:08.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、System类的定义"><a href="#一、System类的定义" class="headerlink" title="一、System类的定义"></a><strong>一、System类的定义</strong></h3><ul><li>System类为Java的系统类，位于 java.lang 包中</li><li>System类的构造方法由 private 进行修饰，因此无法被实例化</li><li>System类提供了标准输入流、标准输出流和错误输出流； </li></ul><p>此外还提供了访问操作系统环境变量，访问虚拟机环境变量，复制数组，垃圾回收等一系列实用方法</p><h3 id="二、System类的常用方法"><a href="#二、System类的常用方法" class="headerlink" title="二、System类的常用方法"></a><strong>二、System类的常用方法</strong></h3><p>  <strong>1、System.currentTimeMillis()</strong></p><ul><li>获取当前时间戳，单位为秒</li></ul><p><strong>2、System.nanoTime()</strong></p><ul><li><p>获取当前时间戳，单位为纳秒</p><p><strong>3、System.lineSeparator()</strong></p></li><li><p>行分隔符，等同于 System.getProperty(“line.separator”)</p><p><strong>4、System.arraycopy()</strong></p></li><li><p>拷贝数组，有五个参数，System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) </p></li><li><p>src：源数组</p></li><li><p>srcPos：源数组开始截取的位置，从0开始</p></li><li><p>dest：目标数组</p></li><li><p>destPos：目标数组开始拷贝的位置，从0开始</p></li><li><p>length：截取长度</p></li></ul><p><strong>5、System.gc()</strong></p><ul><li>相当于调用了 Runtime.getRuntime().gc()， </li></ul><p>在回收之前会调用对象的finalize()方法，用于负责回收无用对象占据的内存资源</p><ul><li>告诉垃圾收集器准备进行垃圾收集，但垃圾收集器不一定会马上执行， </li></ul><p>这是因为 垃圾回收只与内存有关，根据虚拟机的各种算法来计算得到执行垃圾回收的时间</p><p>  <strong>6、System.runFinalization()</strong></p><ul><li>调用已失去引用的对象的finalize()方法，但不能保证其一定执行</li></ul><p><strong>7、System.load(String filepath)</strong></p><ul><li>用于加载库文件，参数为 库文件的绝对路径</li><li>库文件：动态链接库(ddl)，Dynamic Link Library， </li></ul><p>是一个包含可由多个程序同时使用的代码和数据的库,实现程序模块化</p><p>  <strong>8、System.loadLibrary(String libname)</strong></p><ul><li>用于加载库文件，参数为 库文件名</li><li>该库文件必须在 java.library.path 所指向的路径中</li></ul><p><strong>9、System.mapLibraryName(String libname)</strong></p><ul><li>将库名称映射到特定的字符串中</li></ul><p><strong>10、System.exit(int status)</strong></p><ul><li><p>终止目前正在运行的Java虚拟机</p></li><li><p>参数为0：正常终止</p></li><li><p>参数非0：异常终止</p><p><strong>11、System.getenv()</strong></p></li><li><p>获取操作系统的环境变量（即本地系统中的环境变量）</p></li><li><p>参数为空：获取操作系统的所有环境变量</p></li><li><p>参数不为空：获取操作系统的指定环境变量（例如：参数为“path”）</p><p><strong>12、System.getProperties()</strong></p></li><li><p>获取虚拟机（JVM）的所有环境变量</p><p><strong>13、System.getProperty(String key)</strong></p></li></ul><p>获取虚拟机（JVM）的指定环境变量</p><p>System.getProperty(“java.version”)：获取java运行环境版本</p><p>System.getProperty(“java.vendor”)：获取java运行环境供应商</p><p>System.getProperty(“java.vendor.url”)：获取java运行环境供应商的URL</p><p>System.getProperty(“java.home”)：获取java安装路径</p><p>System.getProperty(“java.vm.specification.version”)：获取java虚拟机规范版本</p><p>System.getProperty(“java.vm.specification.vendor”)：获取java虚拟机规范供应商</p><p>System.getProperty(“java.vm.specification.name”)：获取java虚拟机规范名称</p><p>System.getProperty(“java.vm.version”)：获取java虚拟机实现版本</p><p>System.getProperty(“java.vm.vendor”)：获取java虚拟机实现供应商</p><p>System.getProperty(“java.vm.name”)：获取java虚拟机实现名称</p><p>System.getProperty(“java.specification.version”)：获取java运行时环境规范版本</p><p>System.getProperty(“java.specification.vender”)：获取java运行时环境规范供应商</p><p>System.getProperty(“java.specification.name”)：获取java运行时环境规范名称</p><p>System.getProperty(“java.class.version”)：获取java类格式版本号</p><p>System.getProperty(“jjava.class.path”)：获取java类路径</p><p>System.getProperty(“java.library.path”)：获取加载库时搜索的路径列表</p><p>System.getProperty(“java.io.tmpdir”)：获取默认的临时文件路径</p><p>System.getProperty(“java.ext.dirs”)：获取一个或多个扩展目录的路径</p><p>System.getProperty(“os.name”)：获取操作系统的名称</p><p>System.getProperty(“os.arch”)：获取操作系统的构架</p><p>System.getProperty(“os.version”)：获取操作系统的版本</p><p>System.getProperty(“file.separator”)：获取文件分隔符</p><p>System.getProperty(“path.separator”)：获取路径分隔符</p><p>System.getProperty(“line.separator”)：获取行分隔符</p><p>System.getProperty(“user.name”)：获取用户名称</p><p>System.getProperty(“user.home”)：获取用户主目录</p><p>System.getProperty(“user.dir”)：获取用户当前工作目录</p><p><strong>14、System.setProperties(Properties props)</strong></p><ul><li>设置虚拟机(JVM)的环境变量（批量）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">prop.setProperty(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>);</span><br><span class="line">System.setProperties(prop);</span><br><span class="line">System.out.println(System.getProperty(<span class="string">"aaa"</span>));</span><br></pre></td></tr></table></figure><p><strong>15、System.setProperty(String key, String value)</strong></p><ul><li>设置虚拟机(JVM)的环境变量（单个）</li></ul><p> <strong>16、System.clearProperty(String key)</strong></p><ul><li>清除设置的虚拟机(JVM)的环境变量</li></ul><p><strong>17、System.console()</strong></p><ul><li>从控制台设备读取字符信息,只能通过命令执行,在IDE中会报错</li></ul><p> <strong>18、System.setIn(InputStream in)</strong></p><ul><li>重新分配标准输入流</li></ul><p><strong>19、System.setErr(PrintStream err)</strong></p><ul><li>重新分配标准错误输出流</li></ul><p>  <strong>20、System.setOut(PrintStream out)</strong></p><ul><li>重新分配标准输出流</li></ul><p><strong>21、err</strong></p><ul><li>标准错误输出流，没有缓存，会立即输出</li></ul><p>  <strong>22、out</strong></p><ul><li><p>标准输出流，有缓存，不一定会立即输出</p><p><strong>23、System.identityHashCode(Object obj)</strong></p></li><li><p>根据对象内存地址来计算得到哈希值</p></li><li><p>注意，这里需要与 hashCode() 方法进行区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于Apple并没有覆盖hashCode()方法，所以两方法得到的哈希值相等</span></span><br><span class="line">Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">System.out.println(apple.hashCode()); <span class="comment">// 21685669</span></span><br><span class="line">System.out.println(System.identityHashCode(apple)); <span class="comment">// 21685669</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于String类覆盖了hashCode()方法，所以两方法得到的哈希值不相等</span></span><br><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line">System.out.println(str.hashCode()); <span class="comment">// 48690</span></span><br><span class="line">System.out.println(System.identityHashCode(str)); <span class="comment">// 21685669</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于"123"会存在常量池中，str1和str2两者指向的是常量池中的同一对象，所以两方法得到的哈希值相等</span></span><br><span class="line">String str1 = <span class="string">"123"</span>;</span><br><span class="line">String str2 = <span class="string">"123"</span>;</span><br><span class="line">System.out.println(System.identityHashCode(str1)); <span class="comment">// 21685669</span></span><br><span class="line">System.out.println(System.identityHashCode(str2)); <span class="comment">// 21685669</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// str1和str2是两个不同对象，所以两方法得到的哈希值不相等</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(System.identityHashCode(str1)); <span class="comment">// 21685669</span></span><br><span class="line">System.out.println(System.identityHashCode(str2)); <span class="comment">// 2133927002</span></span><br></pre></td></tr></table></figure></li></ul><p> <strong>24、System.setSecurityManager(SecurityManager securityManager)</strong></p><ul><li><p>设置安全管理器，接收一个 SecurityManager 类型的参数</p><p><strong>25、System.getSecurityManager()</strong></p></li><li><p>获取安全管理器</p></li></ul><p><strong>26、System.inheritedChannel()</strong></p><ul><li>返回从创建此Java虚拟机的实体继承得到的channel</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、System类的定义&quot;&gt;&lt;a href=&quot;#一、System类的定义&quot; class=&quot;headerlink&quot; title=&quot;一、System类的定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、System类的定义&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;System类
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Random</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/Random/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/Random/</id>
    <published>2019-08-31T02:56:32.000Z</published>
    <updated>2019-08-31T03:11:07.049Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Random类的定义"><a href="#一、Random类的定义" class="headerlink" title="一、Random类的定义"></a>一、Random类的定义</h3><p>Random类位于 java.util 包中，主要用于生成伪 随机数</p><p>Random类将 种子数 作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关</p><p>创建Random实例时，若没有指定种子数，则会以 当前时间 作为种子数，来计算生成伪随机数</p><p><strong>拥有 相同种子 的Random实例，在相同次数下，生成的伪随机数完全相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random1 = <span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">Random random2 = <span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">System.out.println(random1.nextInt()); <span class="comment">// -1157793070</span></span><br><span class="line">System.out.println(random2.nextInt()); <span class="comment">// -1157793070</span></span><br></pre></td></tr></table></figure><h3 id="二、Random类的常用方法"><a href="#二、Random类的常用方法" class="headerlink" title="二、Random类的常用方法"></a><strong>二、Random类的常用方法</strong></h3><p>  <strong>1、random.nextBoolean()</strong></p><ul><li>用于从该随机数生成器的序列中得到下一个伪均匀分布的boolean值</li></ul><p><strong>2、random.nextBytes()</strong></p><ul><li><p>用于生成随机字节并将其放入用户提供的byte数组中</p><p><strong>3、random.nextDouble()</strong></p></li><li><p>用于从该随机数生成器的序列中得到下一个伪均匀分布在0.0到1.0之间的double值，[0.0, 1.0)</p><p><strong>4、random.nextFloat()</strong></p></li><li><p>用于从该随机数生成器的序列中得到下一个伪均匀分布在0.0到1.0之间的float值，[0.0, 1.0)</p><p><strong>5、random.nextInt()</strong></p></li><li><p>random.nextInt()</p></li><li><p>用于从该随机数生成器的序列中得到下一个伪均匀分布的int值</p></li></ul><ul><li>random.nextInt(int bound)</li><li>用于从该随机数生成器的序列中得到下一个0到结束值之间伪均匀分布的int值，[0, 结束值)</li></ul><p><strong>6、random.nextGaussian()</strong></p><ul><li>用于从该随机数生成器的序列中得到下一个伪均匀分布的double值</li><li>生成的double值符合均值为0，方差为1的正态分布(高斯分布)</li></ul><p> <strong>7、random.setSeed(long seed)</strong></p><ul><li>设置随机种子</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Random类的定义&quot;&gt;&lt;a href=&quot;#一、Random类的定义&quot; class=&quot;headerlink&quot; title=&quot;一、Random类的定义&quot;&gt;&lt;/a&gt;一、Random类的定义&lt;/h3&gt;&lt;p&gt;Random类位于 java.util 包中，主要用于生成伪
      
    
    </summary>
    
    
      <category term="常用类" scheme="http://cxqiang.gitee.io/blog/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Date</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/Date/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/Date/</id>
    <published>2019-08-31T02:56:22.000Z</published>
    <updated>2019-08-31T03:09:36.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Date类的定义"><a href="#一、Date类的定义" class="headerlink" title="一、Date类的定义"></a><strong>一、Date类的定义</strong></h3><ul><li><p>Date类位于 java.util 包中，主要用来封装当前的日期和时间， Date 类提供两个构造函数来实例化 Date 对象 </p></li><li><ul><li>Date()：使用当前日期和时间来初始化对象</li><li>Date(long milliseconds)：接收一个long类型的参数，该参数是从1970-01-01 00:00:00.000到当前时间的毫秒数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="comment">// 打印Date对象</span></span><br><span class="line"><span class="comment">// Sat：表示周六</span></span><br><span class="line"><span class="comment">// Aug：表示八月</span></span><br><span class="line"><span class="comment">// GMT：格林威治标准时间</span></span><br><span class="line"><span class="comment">// GMT+08:00：东八区即标准北京时间</span></span><br><span class="line">System.out.println(date); <span class="comment">// Sat Aug 11 17:03:32 GMT+08:00 2018</span></span><br></pre></td></tr></table></figure><p><strong>二、Date类的常用方法</strong></p><p>  <strong>1、getTime()</strong></p><ul><li><p>得到时间毫秒数</p><p><strong>2、setTime(long milliseconds)</strong></p></li><li><p>设置时间毫秒数</p><p><strong>3、equals(Object obj)</strong></p></li><li><p>比较两个时间是否相等</p><p><strong>4、after(Date when)</strong></p></li><li><p>测试目标日期是否在参数日期之后</p><p><strong>5、before(Date when)</strong></p></li><li><p>测试目标日期是否在参数日期之前</p><p><strong>6、compareTo(Date anotherDate)</strong></p></li><li><p>对两个Date对象进行比较</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date date1 = sdf.parse(<span class="string">"2018-08-10 08:08:123"</span>);</span><br><span class="line">Date date2 = sdf.parse(<span class="string">"2018-08-10 08:08:123"</span>);</span><br><span class="line">System.out.println(date1.compareTo(date2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><p>如果目标日期在参数日期之后，则返回1</p></li><li><p>如果目标日期在参数日期之前，则返回-1</p><p><strong>7、toInstant()</strong> </p></li></ul><p>注意：Instant输出的是标准时间，即格林威治标准时间，而Date输出的是北京时间，两者相差8个小时</p><ul><li>返回一个时间线上与此日期相同的一个点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Date类的定义&quot;&gt;&lt;a href=&quot;#一、Date类的定义&quot; class=&quot;headerlink&quot; title=&quot;一、Date类的定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、Date类的定义&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Date类位于 java
      
    
    </summary>
    
    
      <category term="常用类" scheme="http://cxqiang.gitee.io/blog/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Collections</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/Collections/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/Collections/</id>
    <published>2019-08-31T02:56:11.000Z</published>
    <updated>2019-08-31T03:08:36.033Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-排序操作（主要针对List接口相关）"><a href="#1-排序操作（主要针对List接口相关）" class="headerlink" title="1. 排序操作（主要针对List接口相关）"></a><strong>1. 排序操作（主要针对List接口相关）</strong></h4><ul><li>reverse(List list)：反转指定List集合中元素的顺序</li><li>shuffle(List list)：对List中的元素进行随机排序（洗牌）</li><li>sort(List list)：对List里的元素根据自然升序排序</li><li>sort(List list, Comparator c)：自定义比较器进行排序</li><li>swap(List list, int i, int j)：将指定List集合中i处元素和j出元素进行交换</li><li>rotate(List list, int distance)：将所有元素向右移位指定长度</li></ul><h4 id="2-查找和替换（主要针对Collection接口相关）"><a href="#2-查找和替换（主要针对Collection接口相关）" class="headerlink" title="2. 查找和替换（主要针对Collection接口相关）"></a><strong>2. 查找和替换（主要针对Collection接口相关）</strong></h4><ul><li><p>binarySearch(List list, Object key)：使用二分搜索法，以获得指定对象在List中的索引，前提是集合已经排序</p></li><li><p>max(Collection coll)：返回最大元素</p></li><li><p>max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素</p></li><li><p>min(Collection coll)：返回最小元素</p></li><li><p>min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素</p></li><li><p>fill(List list, Object obj)：使用指定对象填充</p></li><li><p>frequency(Collection Object o)：返回指定集合中指定对象出现的次数</p></li></ul><h4 id="3-同步控制"><a href="#3-同步控制" class="headerlink" title="3. 同步控制"></a><strong>3. 同步控制</strong></h4><p>Collections工具类中提供了多个synchronizedXxx方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。HashSet、ArrayList、HashMap都是线程不安全的，如果需要考虑同步，则使用这些方法。这些方法主要有：synchronizedSet、synchronizedSortedSet、synchronizedList、synchronizedMap、synchronizedSortedMap。</p><p>特别需要指出的是，在使用迭代方法遍历集合时需要手工同步返回的集合。</p><h4 id="4-设置不可变集合"><a href="#4-设置不可变集合" class="headerlink" title="4. 设置不可变集合"></a><strong>4. 设置不可变集合</strong></h4><p>Collections有三类方法可返回一个不可变集合：</p><ul><li>emptyXxx()：返回一个空的不可变的集合对象</li><li>singletonXxx()：返回一个只包含指定对象的，不可变的集合对象。</li><li>unmodifiableXxx()：返回指定集合对象的不可变视图</li></ul><h4 id="5、其他"><a href="#5、其他" class="headerlink" title="5、其他"></a>5、其他</h4><ul><li><p>disjoint(Collection<?> c1, Collection<?> c2) - 如果两个指定 collection 中没有相同的元素，则返回 true。</p></li><li><p>addAll(Collection&lt;? super T&gt; c, T… a) - 一种方便的方式，将所有指定元素添加到指定 collection 中。示范： </p></li></ul><p>Collections.addAll(flavors, “Peaches ‘n Plutonium”, “Rocky Racoon”);</p><ul><li>Comparator<t> reverseOrder(Comparator<t> cmp) - 返回一个比较器，它强行反转指定比较器的顺序。如果指定比较器为 null，则此方法等同于 reverseOrder()（换句话说，它返回一个比较器，该比较器将强行反转实现 Comparable 接口那些对象 collection 上的自然顺序）。</t></t></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-排序操作（主要针对List接口相关）&quot;&gt;&lt;a href=&quot;#1-排序操作（主要针对List接口相关）&quot; class=&quot;headerlink&quot; title=&quot;1. 排序操作（主要针对List接口相关）&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. 排序操作（主要针对List接
      
    
    </summary>
    
    
      <category term="常用类" scheme="http://cxqiang.gitee.io/blog/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Arrays</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/Arrays/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/Arrays/</id>
    <published>2019-08-31T02:55:55.000Z</published>
    <updated>2019-08-31T03:01:05.327Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Arrays类的定义"><a href="#一、Arrays类的定义" class="headerlink" title="一、Arrays类的定义"></a><strong>一、Arrays类的定义</strong></h2><ul><li>Arrays类位于 java.util 包中，主要包含了操纵数组的各种方法</li></ul><h2 id="二、Arrays类的常用方法"><a href="#二、Arrays类的常用方法" class="headerlink" title="二、Arrays类的常用方法"></a>二、Arrays类的常用方法</h2><p> <strong>1、Arrays.asList(T… data)</strong> </p><p>注意：该方法返回的是Arrays内部静态类ArrayList，<strong>而不是我们平常使用的ArrayList</strong>,，<strong>该静态类ArrayList没有覆盖父类的add, remove等方法</strong>，所以如果直接调用，会报UnsupportedOperationException异常</p><p>可接受可变参数，数组等</p><p> <strong>2、Arrays.fill()</strong></p><ul><li><p>Arrays.fill(Object[] array, Object obj)</p><p>用指定元素填充整个数组（会替换掉数组中原来的元素）</p></li><li><p>Arrays.fill(Object[] array, int fromIndex, int toIndex, Object obj)</p><p>用指定元素填充数组，从起始位置到结束位置，取头不取尾（会替换掉数组中原来的元素）   左闭右开原则</p></li></ul><p><code>Integer[] data = {1, 2, 3, 4}; Arrays.fill(data, 0, 2, 9); System.out.println(Arrays.toString(data)); // [9, 9, 3, 4]</code></p><p><strong>3、Arrays.sort()</strong></p><ul><li><p>Arrays.sort(Object[] array)</p><p>对数组元素进行排序（串行排序）</p></li><li><p>Arrays.sort(T[] array, Comparator&lt;? super T&gt; comparator)</p><p>使用自定义比较器，对数组元素进行排序（串行排序）</p></li><li><p>Arrays.sort(Object[] array, int fromIndex, int toIndex)</p><p>对数组元素的指定范围进行排序（串行排序）</p></li></ul><p> <strong>4、Arrays.parallelSort()</strong> </p><p>注意：其余重载方法与 sort() 相同</p><ul><li><p>Arrays.parallelSort(T[] array)</p><p>对数组元素进行排序（并行排序），当数据规模较大时，会有更好的性能</p></li></ul><p><strong>5、Arrays.binarySearch()</strong>  二分查找</p><p>注意：在调用该方法之前，必须先调用sort()方法进行排序，如果数组没有排序， </p><p>那么结果是不确定的，此外如果数组中包含多个指定元素，则无法保证将找到哪个元素</p><p>Arrays.binarySearch(Object[] array, Object key)</p><p>使用 二分法 查找数组内指定元素的索引值</p><p>Arrays.binarySearch(Object[] array, int fromIndex, int toIndex, Object obj)</p><p>使用 二分法 查找数组内指定范围内的指定元素的索引值</p><p><strong>6、Arrays.copyOf()</strong></p><ul><li><p>Arrays.copyOf(T[] original, int newLength)</p><p>拷贝数组，其内部调用了 System.arraycopy() 方法，从下标0开始，如果超过原数组长度，会用null进行填充</p></li></ul><p> <strong>7、Arrays.copyOfRange(T[] original, int from, int to)</strong></p><p>拷贝数组，指定起始位置和结束位置，如果超过原数组长度，会用null进行填充</p><p><strong>8、Arrays.equals(Object[] array1, Object[] array2)</strong></p><ul><li>判断两个数组是否相等，实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2)</li></ul><p> <strong>9、Arrays.deepEquals(Object[] array1, Object[] array2)</strong></p><ul><li>判断两个多维数组是否相等，实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2)</li></ul><p>  <strong>10、Arrays.hashCode(Object[] array)</strong></p><ul><li>返回数组的哈希值</li></ul><p> <strong>11、Arrays.deepHashCode(Object[] array)</strong></p><ul><li>返回多维数组的哈希值</li></ul><p> <strong>12、Arrays.toString(Object[] array)</strong></p><ul><li>返回数组元素的字符串形式</li></ul><p> <strong>13、Arrays.deepToString(Object[] array)</strong></p><ul><li>返回多维数组元素的字符串形式</li></ul><p><strong>14、Arrays.setAll(T[] array, IntFunction</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] data = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 第一个元素2不变，将其与第二个元素3一起作为参数x, y传入，得到乘积6，作为数组新的第二个元素</span></span><br><span class="line"><span class="comment">// 再将6和第三个元素4一起作为参数x, y传入，得到乘积24，作为数组新的第三个元素，以此类推</span></span><br><span class="line">Arrays.parallelPrefix(data, (x, y) -&gt; x * y);</span><br><span class="line">System.out.println(Arrays.toString(data)); <span class="comment">// [2, 6, 24, 120]</span></span><br></pre></td></tr></table></figure><p><strong>16、Arrays.spliterator(T[] array)</strong></p><ul><li>返回数组的分片迭代器，用于并行遍历数组</li></ul><p><strong>17、Arrays.stream(T[] array)</strong></p><ul><li>返回数组的流Stream，然后我们就可以使用Stream相关的许多方法了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Arrays类的定义&quot;&gt;&lt;a href=&quot;#一、Arrays类的定义&quot; class=&quot;headerlink&quot; title=&quot;一、Arrays类的定义&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、Arrays类的定义&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Arrays类
      
    
    </summary>
    
    
      <category term="常用类" scheme="http://cxqiang.gitee.io/blog/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/正则表达式/</id>
    <published>2019-08-31T02:37:46.000Z</published>
    <updated>2019-08-31T02:42:50.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a><strong>正则表达式</strong></h2><p>正则表达式就是以某种方式来描述字符串</p><p>可以用来匹配字符串来找到你需要的</p><p>String类的分隔<strong>split</strong> 和 <strong>replace</strong>方法可以放入正则表达式的参数</p><p><strong>matches</strong> 匹配正则表达式的方法</p><h2 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a><strong>符号定义</strong></h2><h4 id="基本书写符号"><a href="#基本书写符号" class="headerlink" title="基本书写符号"></a><strong>基本书写符号</strong></h4><table><thead><tr><th>符号</th><th>符号</th><th>示例</th><th>解释</th><th>匹配输入</th></tr></thead><tbody><tr><td>\</td><td>转义符</td><td>*</td><td>符号“*”</td><td>*</td></tr><tr><td>[  ]</td><td>可接收的字符列表</td><td>[efgh]</td><td>e、f、g、h中的任意1个字符</td><td>e、f、g、h</td></tr><tr><td>[^]</td><td>不接收的字符列表</td><td>[^abc]</td><td>除a、b、c之外的任意1个字符，包括数字和特殊符号</td><td>m、q、5、*</td></tr><tr><td>|</td><td>匹配“|”之前或之后的表达式</td><td>ab|cd</td><td>ab或者cd</td><td>ab、cd</td></tr><tr><td>(  )</td><td>将子表达式分组</td><td>(abc)</td><td>将字符串abc作为一组</td><td>abc</td></tr><tr><td>-</td><td>连字符</td><td>A-Z</td><td>任意单个大写字母</td><td>大写字母</td></tr></tbody></table><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a><strong>限定符</strong></h3><p>限定符将可选数量的数据添加到正则表达式，下表为常用限定符：</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>示例</th><th>匹配输入</th><th>不匹配输入</th></tr></thead><tbody><tr><td>*</td><td>指定字符重复0次或n次</td><td>(abc)*</td><td>仅包含任意个abc的字符串，等效于\w*</td><td>abc、abcabcabc</td><td>a、abca</td></tr><tr><td>+</td><td>指定字符重复1次或n次</td><td>m+(abc)*</td><td>以至少1个m开头，后接任意个abc的字符串</td><td>m、mabc、mabcabc</td><td>ma、abc</td></tr><tr><td>?</td><td>指定字符重复0次或1次</td><td>m+abc?</td><td>以至少1个m开头，后接ab或abc的字符串</td><td>mab、mabc、mmmab、mmabc</td><td>ab、abc、mabcc</td></tr><tr><td>{n}</td><td>只能输入n个字符</td><td>[abcd]{3}</td><td>由abcd中字母组成的任意长度为3的字符串</td><td>abc、dbc、adc</td><td>a、aa、dcbd</td></tr><tr><td>{n,}</td><td>指定至少 n 个匹配</td><td>[abcd]{3,}</td><td>由abcd中字母组成的任意长度不小于3的字符串</td><td>aab、dbc、aaabdc</td><td>a、cd、bb</td></tr><tr><td>{n,m}</td><td>指定至少 n 个但不多于 m 个匹配</td><td>[abcd]{3,5}</td><td>由abcd中字母组成的任意长度不小于3，不大于5的字符串</td><td>abc、abcd、aaaaa、bcdab</td><td>ab、ababab、a</td></tr><tr><td>^</td><td>指定起始字符</td><td>^[0-9]+[a-z]*</td><td>以至少1个数字开头，后接任意个小写字母的字符串</td><td>123、6aa、555edf</td><td>abc、aaa、a33</td></tr><tr><td>$</td><td>指定结束字符</td><td>^[0-9]-[a-z]+$</td><td>以1个数字开头后接连字符“–”，并以至少1个小写字母结尾的字符串</td><td>2-a、3-ddd、5-efg</td><td>33a、8-、7-Ab</td></tr></tbody></table><h3 id="匹配字符集"><a href="#匹配字符集" class="headerlink" title="匹配字符集"></a><strong>匹配字符集</strong></h3><p>匹配字符集是预定义的用于正则表达式中的符号集。如果字符串与字符集中的任何一个字符相匹配，它就会找到这个匹配项。</p><p>正则表达式中的部分匹配字符集:</p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>示例</th><th>匹配输入</th><th>不匹配输入</th></tr></thead><tbody><tr><td>.</td><td>匹配除 \n 以外的任何字符</td><td>a..b</td><td>以a开头，b结尾，中间包括2个任意字符的长度为4的字符串</td><td>aaab、aefb、a35b、a#*b</td><td>ab、aaaa、a347b</td></tr><tr><td>\d</td><td>匹配单个数字字符，相当于[0-9]</td><td>\d{3}(\d)?</td><td>包含3个或4个数字的字符串</td><td>123、9876</td><td>123、9876</td></tr><tr><td>\D</td><td>匹配单个非数字字符，相当于[^0-9]</td><td>\D(\d)*</td><td>以单个非数字字符开头，后接任意个数字字符串</td><td>a、A342</td><td>aa、AA78、1234</td></tr><tr><td>\w</td><td>匹配单个数字、大小写字母字符，相当于[0-9a-zA-Z]</td><td>\d{3}\w{4}</td><td>以3个数字字符开头的长度为7的数字字母字符串</td><td>234abcd、12345Pe</td><td>58a、Ra46</td></tr><tr><td>\W</td><td>匹配单个非数字、大小写字母字符，相当于[^0-9a-zA-Z]</td><td>\W+\d{2}</td><td>以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td><td>#29、#?@10</td><td>23、#?@100</td></tr></tbody></table><h3 id="分组构造"><a href="#分组构造" class="headerlink" title="分组构造"></a><strong>分组构造</strong></h3><p>常用分组构造形式:</p><table><thead><tr><th>常用分组构造形式</th><th>说明</th></tr></thead><tbody><tr><td>()</td><td>非命名捕获。捕获匹配的子字符串（或非捕获组）。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。</td></tr><tr><td>(?<name>)</name></td><td>命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如 (?’name’)</td></tr></tbody></table><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a><strong>字符转义</strong></h3><p>如果你想查找元字符本身的话，比如你查找.,或者<em>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用.和\</em>。当然，要查找\本身，你也得用\</p><p>例如：deerchao.net匹配deerchao.NET，C:\Windows匹配C:\Windows。注意在Java中: (<a href="https://github\\.com/[\\w\\-]" target="_blank" rel="noopener">https://github\\.com/[\\w\\-]</a>) 用”\.”配备”.”。</p><p><strong>常用正则表达式举例</strong></p><p>非负整数：“^\d+$ ”</p><p>正整数： “ ^[0-9]<em>[1-9][0-9]</em>$” </p><p>非正整数： “ ^((-\d+)|(0+))$” </p><p>整数： “ ^-?\d+$” </p><p>英文字符串： “ ^[A-Za-z]+$” </p><p>英文字符数字串： “ ^[A-Za-z0-9]+$” </p><p>英数字加下划线串： “^\w+$” </p><p>E-mail地址：“^[\w-]+(.[\w-]+)*@[\w-]+(.[\w-]+)+$” </p><p>URL：“^[a-zA-Z]+://(\w+(-\w+)<em>)(.(\w+(-\w+)</em>))<em>(?\s</em>)?$”</p><h3 id="Petteren-和-Matcher"><a href="#Petteren-和-Matcher" class="headerlink" title="Petteren    和    Matcher"></a><strong>Petteren    和    Matcher</strong></h3><p>Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可</p><p>以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, </p><p>CharSequence 接口有 CharBuffer,String,StringBuilder,StringBuffer</p><p><strong>Pattern类详解</strong></p><p>Pattern表示编译后的正则表达式</p><p><strong>Pattern</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将给定的正则表达式编译并赋予给Pattern类</span></span></span><br><span class="line"><span class="function">2. <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex, <span class="keyword">int</span> flags)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//同上，但增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ </span></span></span><br><span class="line"><span class="function">3. <span class="keyword">int</span> <span class="title">flags</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回当前Pattern的匹配flag参数. </span></span></span><br><span class="line"><span class="function">4. String[] <span class="title">split</span><span class="params">(CharSequence input)</span>  分隔字符串 </span></span><br><span class="line"><span class="function"><span class="comment">//快速判断匹配 </span></span></span><br><span class="line"><span class="function">5.Pattern.<span class="title">matcher</span><span class="params">(String regex,CharSequence input)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个Matcher对象</span></span></span><br><span class="line"><span class="function">6.Pattern.<span class="title">matcher</span><span class="params">(CharSequence input)</span></span></span><br></pre></td></tr></table></figure><p><strong>Matcher对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">matches()</span><br><span class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </span><br><span class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </span><br><span class="line">m.matches();<span class="comment">//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. </span></span><br><span class="line">Matcher m2=p.matcher(<span class="string">"2223"</span>); </span><br><span class="line">m2.matches();<span class="comment">//返回true,因为\d+匹配到了整个字符串</span></span><br><span class="line"><span class="number">1</span>. Pattern.matcher(String regex,CharSequence input),它与下面这段代码等价 </span><br><span class="line">Pattern.compile(regex).matcher(input).matches()</span><br><span class="line"><span class="number">2</span>. matches是整个匹配，只有整个字符序列完全匹配成功，</span><br><span class="line">才返回True，否则返回False。但如果前部分匹配成功，将移动下次匹配的位置。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.lookingAt()</span><br><span class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </span><br><span class="line">m.lookingAt();<span class="comment">//返回true,因为\d+匹配到了前面的22 </span></span><br><span class="line">Matcher m2=p.matcher(<span class="string">"aa2223"</span>); </span><br><span class="line">m2.lookingAt();<span class="comment">//返回false,因为\d+不能匹配前面的aa </span></span><br><span class="line">lookingAt是部分匹配，总是从第一个字符进行匹配,</span><br><span class="line">匹配成功了不再继续匹配，匹配失败了,也不继续匹配。</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.compile(expression); <span class="comment">// 正则表达式 </span></span><br><span class="line">Matcher m = p.matcher(text); <span class="comment">// 操作的字符串 </span></span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">    matcher.start();</span><br><span class="line">    matcher.end();</span><br><span class="line">    matcher.group(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. find()是部分匹配，从当前位置开始匹配，找到一个匹配的子串，</span><br><span class="line">将移动下次匹配的位置。</span><br><span class="line"><span class="number">2</span>. find()从匹配器区域的开头开始，</span><br><span class="line">如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，</span><br><span class="line">则从以前匹配操作没有匹配的第一个字符开始。如果匹配成功，</span><br><span class="line">则可以通过 start、end 和 group 方法获取更多信息。</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.cnblogs.com/ggjucheng/p/3423731.html" target="_blank" rel="noopener">https://www.cnblogs.com/ggjucheng/p/3423731.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;&lt;strong&gt;正则表达式&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;正则表达式就是以某种方式来描述字符串&lt;/p&gt;
&lt;p&gt;可以用来匹配字符串来找到你需要
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://cxqiang.gitee.io/blog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/泛型/</id>
    <published>2019-08-31T01:34:09.000Z</published>
    <updated>2019-08-31T02:35:00.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型是什么？"><a href="#泛型是什么？" class="headerlink" title="泛型是什么？"></a>泛型是什么？</h2><p>一般的类和方法，只能使用具体的类型，要么是自定义的类，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大,所有要使代码应用于“某种不具体的类型”，</p><p>于是引入了泛型</p><p>泛型实现了参数化类型的概念，<strong>使代码可以应用于多种类型</strong></p><p><strong>“泛型”意思就是适用于许多类型</strong></p><p>一般我们是用Object类来存储任何类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">Object value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用,只不过要的到具体类型时，需要强制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo.setValue(<span class="number">111</span>);   <span class="comment">//自动装箱成Integer类型</span></span><br><span class="line"><span class="keyword">int</span> value = (<span class="keyword">int</span>) demo.getValue();</span><br><span class="line">demo.setValue(<span class="string">"123"</span>);</span><br><span class="line">String s = (String) demo.getValue();</span><br></pre></td></tr></table></figure><p>泛型却给我们带来了全新的编程体验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo&lt;Integer&gt; demo = <span class="keyword">new</span> Demo&lt;Integer&gt;();</span><br><span class="line">        demo.setValue(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">int</span> value = demo.getValue();</span><br><span class="line"></span><br><span class="line">        Demo&lt;String&gt; demo1 = <span class="keyword">new</span> Demo&lt;String&gt;();</span><br><span class="line">        demo1.setValue(<span class="string">"123"</span>);</span><br><span class="line">        String value1 = demo1.getValue();</span><br><span class="line">        <span class="comment">// demo1.setValue(123);  错误 编译无法通过</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型除了可以将类型参数化外，而参数一旦确定好，如果类似不匹配，编译器就不通过。</strong></p><p>所以，综合上面信息，我们可以得到下面的结论。</p><ol><li>与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。</li><li>当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。</li><li>泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 Cache<string>这个类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。</string></li></ol><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>原则：无论何时，只要你能做的，就尽可能使用泛型方法</p><p><strong>要定义泛型方法,只需将泛型参数列表置于返回值之前</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;; 这是泛型方法；</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> f（T a）&#123;&#125;；这不是泛型方法，返回值前无泛型。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;泛型是什么？&quot;&gt;&lt;a href=&quot;#泛型是什么？&quot; class=&quot;headerlink&quot; title=&quot;泛型是什么？&quot;&gt;&lt;/a&gt;泛型是什么？&lt;/h2&gt;&lt;p&gt;一般的类和方法，只能使用具体的类型，要么是自定义的类，如果要编写可以应用于多种类型的代码，这种刻板的限制对代
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://cxqiang.gitee.io/blog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/31/%E5%BC%82%E5%B8%B8/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/31/异常/</id>
    <published>2019-08-31T01:21:07.000Z</published>
    <updated>2019-08-31T01:31:12.195Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JAVA的基本理念是结构不佳的代码不能运行</strong></p><h4 id="1：概念"><a href="#1：概念" class="headerlink" title="1：概念"></a><strong>1：概念</strong></h4><p>程序在运行时出现的错误</p><p>使用异常的好处<strong>能够降低错误处理代码的复杂度,只需要异常机制来捕获这个错误，然后处理，而且把正常的情况和非正常的处理代码相互隔离</strong></p><h4 id="2：基本异常"><a href="#2：基本异常" class="headerlink" title="2：基本异常"></a><strong>2：基本异常</strong></h4><p>异常情形是指阻止当前方法或者作用域继续执行的问题</p><p>抛出异常指：当前不解决问题，将问题交给上一级</p><p>throw new NullPointerException()</p><p><strong>抛出异常后发生的事情</strong></p><p>1）会在堆上 new 异常对象</p><p>2）当前的执行路径会终止，并且弹出异常的引用</p><p>3）异常处理机制会接管程序</p><p>4）异常处理程序会在特定的地方执行 使程序能从错误中恢复，或者以另一种方式运行或继续运行下去</p><p>异常会让我们（如果没有其他手段）强制程序（当前线程）停止，并告诉我们出现了什么问题，或者处理异常，并返回稳定状态</p><p><strong>异常参数：</strong></p><p>异常对象与其他对象一样，有两个构造器，<strong>默认构造器和字符串为参数的构造器</strong></p><p>throw new NullPointerException(“t = null”)</p><p>其中throw 相当于”放回“这个异常对象</p><p>能够抛出任意类型的Throwable对象，它是异常类型的根类</p><h4 id="3：捕获异常"><a href="#3：捕获异常" class="headerlink" title="3：捕获异常"></a><strong>3：捕获异常</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type1 id1 )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try块</strong></p><p>捕获抛出的异常</p><p><strong>catch</strong></p><p>异常处理程序 可以有多个来处理不同的异常</p><p>对捕获的对应的异常Type1  id1进行处理</p><h4 id="4：创建自定义的异常"><a href="#4：创建自定义的异常" class="headerlink" title="4：创建自定义的异常"></a><strong>4：创建自定义的异常</strong></h4><p>继承Exception异常类</p><p>有默认的构造器和 字符串参数的构造器就行</p><p>*<em>异常以及记录日志 *</em></p><h4 id="5：异常的说明"><a href="#5：异常的说明" class="headerlink" title="5：异常的说明"></a><strong>5：异常的说明</strong></h4><p> 属于方法声明的一种 在方法后面 throws 异常列表   (相当于抛出异常将该方法的异常让别人理)</p><h4 id="6：捕获所有的异常"><a href="#6：捕获所有的异常" class="headerlink" title="6：捕获所有的异常"></a><strong>6：捕获所有的异常</strong></h4><p><strong>在catch(Exception e)   捕获异常的基类</strong></p><p>放在最后一个catch，防止抢在其他具体异常处理前面</p><p><strong>栈轨迹</strong></p><p>printStackTrace（） 返回一个轨迹栈中元素所构成的数组，每个元素对应栈的一个栈帧第一</p><p>个方法在栈顶，最后在栈低，捕获后，重新抛出异常 throw Exception()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Throwable的方法</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span>  获取详细信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">getLocalMessage</span><span class="params">()</span>   用本地语言描述的详细信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span>简单描述</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">fillInStackTrace</span><span class="params">()</span>,原来异常点消失，只剩下新的抛出点信息（比如你捕获一个异常 然后从新把它抛出 可以调用这个方法）</span></span><br></pre></td></tr></table></figure><p><strong>异常链</strong></p><p>在捕获一个异常后，抛出另一个异常，并且把原始异常信息保存下来，Throwable的子类在构造中可以接受一个 cause对象（原始的异常也是Throwable类）这样就可以将元素的异常传递个新的异常，可以通过最新的异常来递归的跟踪到原始的异常</p><h4 id="7-JAVA标准异常"><a href="#7-JAVA标准异常" class="headerlink" title="7:JAVA标准异常"></a>7:JAVA标准异常</h4><p><img src="D:/Program%20Files%20%28x86%29/youdao/xiaoqiang20000523@163.com/214cdb3fe1d3462e96df2a7b701f7634/clipboard.png" alt="img"></p><p><strong>Throwable</strong>：任何可以作为异常抛出的类</p><p><strong>Error</strong>：编译和系统错误</p><p><strong>Exception</strong>，可抛出的基本类型</p><p>特例<strong>RuntimeException</strong></p><p>运行时异常，不需要再声明方法中抛出，也被称为 不受检查异常，这种异常属于错误，将自</p><p>动捕获</p><p>务必记住：只能在代码中忽略RuntimeException及其子类的异常，其他类型的异常由编译器</p><p>强制实施的，究其原因，RuntimeException代表编程错误，无法预料的错误，</p><h4 id="8：使用finally进行清理"><a href="#8：使用finally进行清理" class="headerlink" title="8：使用finally进行清理"></a><strong>8：使用finally进行清理</strong></h4><p><em>在运行完try 或者 catch 后必须执行的操作，一定执行的操作</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码返回的是 -1，因为finally中的return 会覆盖掉之前的</p><p>可以用来释放资源  如关闭一些流，即使在前面有return，finally也会执行，除非是 exit(0)</p><p>缺憾：异常丢失：前一个异常还没处理就抛出了下一个异常</p><h4 id="9：异常的匹配"><a href="#9：异常的匹配" class="headerlink" title="9：异常的匹配"></a><strong>9：异常的匹配</strong></h4><p><strong>系统会自动的找到最近的处理程序 catch块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>（Type1 id1）&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Type2 id2)&#123;</span><br><span class="line"></span><br><span class="line">&#125;...</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在try捕获到异常会自上到下逐一的匹配 异常然后执行相应的catch，就结束执行finally了</p><p><strong>把最大的放在后面 Exception ,如果放前面 会覆盖后面的 从而不知道具体的异常了</strong></p><h4 id="10：其他可选方式"><a href="#10：其他可选方式" class="headerlink" title="10：其他可选方式"></a><strong>10：其他可选方式</strong></h4><p>把异常给控制台 在main 抛出异常 throws </p><p>把被检查异常，转换成 不检查异常</p><p>将抛出了异常 e 用RuntimeException封装并且抛出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JAVA的基本理念是结构不佳的代码不能运行&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;1：概念&quot;&gt;&lt;a href=&quot;#1：概念&quot; class=&quot;headerlink&quot; title=&quot;1：概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;1：概念&lt;/strong&gt;&lt;/h4&gt;&lt;p
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://cxqiang.gitee.io/blog/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/30/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/30/内部类/</id>
    <published>2019-08-30T14:27:30.000Z</published>
    <updated>2019-08-30T16:19:46.178Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类：将一个类定义在另一个类的定义内部"><a href="#内部类：将一个类定义在另一个类的定义内部" class="headerlink" title="内部类：将一个类定义在另一个类的定义内部"></a><strong>内部类：将一个类定义在另一个类的定义内部</strong></h3><h4 id="1：创建内部类"><a href="#1：创建内部类" class="headerlink" title="1：创建内部类"></a>1：创建内部类</h4><p>也是用class 关键字在类的内部创建个class类</p><p>不过，如果想从外部类的非静态方法之外的任意位置创建某个内部类对象，必须指明这个对象的</p><p>类型 OuterClassName<strong>.</strong>InnerClassName</p><h4 id="2-链接到外部类"><a href="#2-链接到外部类" class="headerlink" title="2:链接到外部类"></a>2:链接到外部类</h4><p>当生成一个内部类对象时，<strong>此对象能访问外围对象的所有成员</strong></p><p>指明做到的：某个外围累的对象创建一个内部类时，内部类的对象会秘密的获取外部类对象的一</p><p>个引用</p><h4 id="3：使用-this-和-new"><a href="#3：使用-this-和-new" class="headerlink" title="3：使用.this   和  .new"></a>3：使用<strong>.</strong>this   和  <strong>.</strong>new</h4><p>当你需要<strong>使用外部对象的引用</strong>时，可以用外部类的名称加   <strong>.</strong>this</p><p>当你<strong>创建外部类的对象</strong>的时候 可以用外部类的引用来调用 .new 加内部类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Inner i= <span class="keyword">new</span> Outer().new Inner();</span><br><span class="line"></span><br><span class="line">即</span><br><span class="line">Outer o=<span class="keyword">new</span> Outer();</span><br><span class="line"></span><br><span class="line">Inner i= o.new Inner();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态内部类可以直接访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xiaoqiang.day10;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/7/13-15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">        i.f();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>必须使用外部类的对象来创建内部类的对象</strong></p><p><strong>但是静态内部类，可直接访问</strong></p><h4 id="4：内部类向上转型"><a href="#4：内部类向上转型" class="headerlink" title="4：内部类向上转型"></a>4：内部类向上转型</h4><p>当内部类被声明为 private时  除了在<strong>外部类的方法内部和它自己，没人访问他</strong></p><p><strong>设为protected 则只有子类和同包的能访问</strong></p><h4 id="5：在方法和作用域中的内部类"><a href="#5：在方法和作用域中的内部类" class="headerlink" title="5：在方法和作用域中的内部类"></a>5：在方法和作用域中的内部类</h4><p>场景：你实现了某个接口，想要返回这个类型</p><p>  需要解决复杂的问题，需要用到这个类但不希望它是公共的</p><ul><li><strong>成员内部类</strong>：有权限修饰符,也可以是静态的，但是不能访问外部类中非静态的成员</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*static*/</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>局部内部类</strong>：<em>在方法里面的类，类是方法的一部分，在方法（域）之外是不能访问的，当然你可以return这个类的基类引用</em>，在方法内 定义的类，不能有修饰访问符，public等，可以访问外部内所有成员</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法外就无法访问到了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>匿名内部类</strong>：就是在方法返回时   return new Content(){   （可以是带有参数的构造器）</li></ul><p>//定义者个类</p><p>};</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        Object x = <span class="keyword">new</span> Object();</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//                i++;      不想修改,默认为为final </span></span><br><span class="line">                System.out.println(i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们经常使用的 创建线程任务的时候就经常用到匿名内部类</p><p><strong>在匿名内部类中，希望它使用一个在外部定义的对象，那么要求 方法的参数必须为final的</strong></p><p>即使（JAVA8）已经不强制添写final，但当你修改的时候回报错。</p><ul><li><p>为什么加final，防止外部类的引用改变了，而内部类中的没改变，</p><p><strong>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。</strong></p></li></ul><p>​      <strong>故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</strong></p><p>在匿名内部类中使用 则参数 要为 final   在匿名内部类中的基类使用 不要</p><p>匿名内部类中没有构造器（因为它没有名字），一般用构造代码块来初始类 { 。。。}</p><p>匿名内部类为扩展类可以实现接口和继承类  ，但也只能实现一个接口</p><p>匿名内部类中不能存在任何的静态成员变量和静态方法</p><h4 id="6：工厂方法"><a href="#6：工厂方法" class="headerlink" title="6：工厂方法"></a>6：工厂方法</h4><p>我们可以用匿名内部类来返回实例</p><h4 id="7：嵌套类（静态内部类）"><a href="#7：嵌套类（静态内部类）" class="headerlink" title="7：嵌套类（静态内部类）"></a>7：嵌套类（静态内部类）</h4><p><strong>如果不需要让内部类对象与外围类对象有关联的话，可以将内部类声明为static，这就称为嵌套类</strong></p><p><strong>1）要创建嵌套类的对象，并不需要访问外部类对象</strong></p><p><strong>2）不能访问非静态的外围类成员</strong></p><p><strong>普通内部类的字段和方法不能声明为 static，不能包含嵌套类</strong></p><p><strong>而嵌套类可以</strong></p><p>接口内部类；默认也是 static public ，在创建某些公共代码，使他们被某个接口的不同实现来使用</p><h4 id="8：为什么需要内部类："><a href="#8：为什么需要内部类：" class="headerlink" title="8：为什么需要内部类："></a><strong>8：为什么需要内部类：</strong></h4><p>1）内部类提供了进入其外围类的窗口</p><p>2）内部类能独立的继承某个类（接口的）实现，无论外围类怎么样，对内部类没影响</p><p> <strong>特性：</strong></p><p>1）内部类可以多个实例，每个实例可以有自己的状态信息，并且与外围类相互独立的</p><p>2）在单个外围类中可以让多个内部类以不同的方式实现同一个接口</p><p>3）内部类对象创建的时候不依赖外围类对象的创建</p><p>4）是一个独立的实体</p><p>闭包和回调</p><p>闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域</p><p>.内部类和控制框架</p><p>控制框架的完整实现是有单个创建的，从而使的实现的细节被封装起来</p><p>内部类能容易的访问外围类的任意成员</p><h4 id="9-内部类的继承"><a href="#9-内部类的继承" class="headerlink" title="9:内部类的继承"></a>9:内部类的继承</h4><p>因为内部类的构造器必须连接其他外围类的对象引用，所以继承内部类，必须把外围类对象的引</p><p>用初始化用外围类的参数传递，调用  Outer.super()</p><h4 id="10-内部类可以被覆盖吗？"><a href="#10-内部类可以被覆盖吗？" class="headerlink" title="10:内部类可以被覆盖吗？"></a>10:内部类可以被覆盖吗？</h4><p><strong>不会，每个内部类都是个独立的存在</strong></p><p>#### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内部类：将一个类定义在另一个类的定义内部&quot;&gt;&lt;a href=&quot;#内部类：将一个类定义在另一个类的定义内部&quot; class=&quot;headerlink&quot; title=&quot;内部类：将一个类定义在另一个类的定义内部&quot;&gt;&lt;/a&gt;&lt;strong&gt;内部类：将一个类定义在另一个类的定义
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://cxqiang.gitee.io/blog/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>面向对象与面向过程</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/面向对象与面向过程/</id>
    <published>2019-08-29T13:43:52.000Z</published>
    <updated>2019-08-30T14:03:02.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1：面向对象编程-OOP-Object-oriented-Programming"><a href="#1：面向对象编程-OOP-Object-oriented-Programming" class="headerlink" title="1：面向对象编程 OOP  Object-oriented Programming"></a><strong>1：面向对象编程 OOP  Object-oriented Programming</strong></h4><ol><li>万物皆对象</li><li>程序是对象的集合，它们通过发送消息来告知彼此所要做的</li><li>每个对象都有自己的有其他对象所构成的存储</li><li>每个对象都有其类型</li><li>某一特定类型的所有对象都可以接受同样的消息</li></ol><p><strong>对象具有自己的状态（内部数据）， 行为（方法），标识（内存地址）</strong></p><h4 id="2：面向对象与面向过程"><a href="#2：面向对象与面向过程" class="headerlink" title="2：面向对象与面向过程"></a><strong>2：面向对象与面向过程</strong></h4><p><strong>面向过程：</strong>你拿扫帚去打扫房间，主体是你，取扫帚，大扫地，一系列动作都需要你自己完成；</p><p><strong>面向对象：</strong>把扫地机器人当成主体对象，相当于个活物，机器人主动去打扫卫生，至于如何打扫完，跟你没关系。</p><p>因此，面向过程，是人在干活。面向对象，相当于人创造机器人去干活。</p><p>站在计算机程序角度来讲，面向过程和面向对象的本质理解为：</p><ul><li>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</li><li>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</li></ul><p>总的来说：面向对象是将事物高度抽象化，面向对象必须先建立抽象模型，之后直接使用模型就行了；面向过程是一种自顶向下的编程</p><h4 id="3、面向对象的特征"><a href="#3、面向对象的特征" class="headerlink" title="3、面向对象的特征"></a><strong>3、面向对象的特征</strong></h4><p><strong>封装</strong>:  隐藏对象属性和实现的细节，仅向外提供公共访问的接口</p><p><strong>继承</strong>：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。</p><p><strong>多态</strong>：一个对象在程序不同运行时刻有多个不同状态，父类或者接口的引用指向子类对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1：面向对象编程-OOP-Object-oriented-Programming&quot;&gt;&lt;a href=&quot;#1：面向对象编程-OOP-Object-oriented-Programming&quot; class=&quot;headerlink&quot; title=&quot;1：面向对象编程 OOP
      
    
    </summary>
    
    
      <category term="面对对象" scheme="http://cxqiang.gitee.io/blog/tags/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/%E5%A4%9A%E6%80%81/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/多态/</id>
    <published>2019-08-29T13:43:26.000Z</published>
    <updated>2019-08-30T14:26:24.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态："><a href="#多态：" class="headerlink" title="多态："></a><strong>多态：</strong></h2><h5 id="同一个行为具有多个不同表现形式或形态的能力"><a href="#同一个行为具有多个不同表现形式或形态的能力" class="headerlink" title="同一个行为具有多个不同表现形式或形态的能力"></a><strong>同一个行为具有多个不同表现形式或形态的能力</strong></h5><h4 id="1：向上转型"><a href="#1：向上转型" class="headerlink" title="1：向上转型"></a>1：向上转型</h4><p>对象可以作为它自己本身的类型使用,也可以作为它的基类类型使用，而将某个对象的引用视为对</p><p>其基类型的引用的做法，被称为向上转型 <strong>（子类-&gt;基类）</strong></p><p>忘记对象类型:用基类来传参</p><h4 id="2：转机"><a href="#2：转机" class="headerlink" title="2：转机"></a>2：转机</h4><p>将一个方法调用和一个方法主体关联起来叫做绑定</p><p><strong>前期绑定</strong>：程序执行前进行绑定（由编译器和连接程序实现 如 C）</p><p><strong>后期绑定</strong>：在运行时根据对象的类型进行绑定，也叫动态绑定或运行时绑定</p><p><strong>JAVA中除了static和final方法都是后期绑定</strong></p><p><em>因此将方法定义为 final 即private的可以关闭动态绑定产生正确的行为</em></p><p><strong>若导出类覆盖了基类的接口，由于后期绑定的机制即时是基类的引用但对象是导出类的还是会调用导出类的方法，所以编写代码可以与只基类打交道</strong></p><p>可扩展性：只与基类接口通信，这样可以覆盖然后不用管新有什么类型，就可以<strong>通过基类的引用调用子类的覆盖的方法</strong>，那些操纵基类的方法接口不需要做任何的改动</p><p>缺陷：“覆盖”私有方法：  对于私有的方法是不能覆盖的</p><pre><code>域与静态方法和字段域不具有多态，**如果某个方法是静态的，它是行为不具有多态性**</code></pre><h4 id="3：构造器与多态"><a href="#3：构造器与多态" class="headerlink" title="3：构造器与多态"></a>3：构造器与多态</h4><p>构造器实际上是static方法，不过声明是隐形的</p><p><strong>构造器的调用顺序</strong></p><ol><li><p>调用基类的构造器</p></li><li><p>按声明顺序调用成员的初始化方法</p></li><li><p>调用构造器的主体</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaoqiang.day_7_11;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaoqiang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Glyph.draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Glyph() &#123;   <span class="comment">//1  先初始化父类 调用父类构造器   </span></span><br><span class="line">        System.out.println(<span class="string">"Glyph() before draw()"</span>);    <span class="comment">//2 </span></span><br><span class="line">        draw();   <span class="comment">//因为多态 调用的是子类覆盖的方法   即子类的draw  3</span></span><br><span class="line">        System.out.println(<span class="string">"Glyph() after draw()"</span>);   <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radiu = <span class="number">1</span>;   <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">        radiu = r;    <span class="comment">//6</span></span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.RoundGlyph(),radius = "</span>+ radiu);<span class="comment">//7 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;   <span class="comment">//3   在父类构造器中调用了，此时radiu还为被初始化，所有为0</span></span><br><span class="line">        System.out.println(<span class="string">"RoundGlyph.draw(),radius = "</span> + radiu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出是</span><br><span class="line">Glyph() <span class="function">before <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">RoundGlyph.<span class="title">draw</span><span class="params">()</span>,radius </span>= <span class="number">0</span></span><br><span class="line">Glyph() <span class="function">after <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">RoundGlyph.<span class="title">RoundGlyph</span><span class="params">()</span>,radius </span>= <span class="number">5</span></span><br></pre></td></tr></table></figure><h5 id="构造器内部多态方法的行为"><a href="#构造器内部多态方法的行为" class="headerlink" title="构造器内部多态方法的行为"></a>构造器内部多态方法的行为</h5><p><strong>初始化的顺序是</strong></p><ol><li><p>在其他任何事物都没有发生之前，讲分配给对象存储空间初始化为二进制的0     <strong>赋初值</strong></p></li><li><p>如前所诉那样先调用基类构造器，此时，<strong>调用被覆盖后</strong>的draw（）方法（<strong>会在导出类构造方法</strong></p></li></ol><p><strong>之前调用</strong>），会由于步骤1的原因，会发现 变量radius为0</p><ol start="3"><li><p>按声明的顺序调用成员的初始化方法</p></li><li><p>调用用导出类的构造器</p></li></ol><p><em>所以在构造器中尽可能的避免调用其他的方法</em>，唯一能安全调用的是final（private）方法，因为</p><p>这些方法是不能被覆盖的</p><h4 id="4：协变返回类型-方法中可以返回它与其子类"><a href="#4：协变返回类型-方法中可以返回它与其子类" class="headerlink" title="4：协变返回类型 方法中可以返回它与其子类"></a>4：协变返回类型 方法中可以返回它与其子类</h4><h4 id="5：用继承来进行设计"><a href="#5：用继承来进行设计" class="headerlink" title="5：用继承来进行设计"></a>5：用继承来进行设计</h4><p><strong>用继承表达行为间的差异，并用字段表达状态上的变化</strong></p><h4 id="6：纯继承以扩展"><a href="#6：纯继承以扩展" class="headerlink" title="6：纯继承以扩展"></a>6：纯继承以扩展</h4><p>导出类与基类有着相同的接口</p><p>缺点:导出类中的接口的扩展部分不能被基类访问，因此我们一旦向上转型，就不能调用导出类的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多态：&quot;&gt;&lt;a href=&quot;#多态：&quot; class=&quot;headerlink&quot; title=&quot;多态：&quot;&gt;&lt;/a&gt;&lt;strong&gt;多态：&lt;/strong&gt;&lt;/h2&gt;&lt;h5 id=&quot;同一个行为具有多个不同表现形式或形态的能力&quot;&gt;&lt;a href=&quot;#同一个行为具有多个不同
      
    
    </summary>
    
    
      <category term="面向对象" scheme="http://cxqiang.gitee.io/blog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/%E7%BB%A7%E6%89%BF/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/继承/</id>
    <published>2019-08-29T13:43:19.000Z</published>
    <updated>2019-08-30T14:13:35.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a><strong>1、概念：</strong></h3><p>继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。</p><p>即导出类继承了 父类（基类）的所有成员与接口（尽管private但是不能访问和使用）</p><p>当继承现有类时，也就是创造了新的类型，这个新的类型（导出类具有和基类相同的类型）</p><h3 id="2：继承语法"><a href="#2：继承语法" class="headerlink" title="2：继承语法"></a><strong>2：继承语法</strong></h3><p><strong>关键词</strong>： extends  </p><p>​                会自动的得到基类中所有的域和方法（尽管private但是不能访问和使用）</p><p>​                super 基类（父类）的引用</p><p><strong>初始化基类</strong></p><p>构造过程是从基类向外扩散的，所以是先初始化基类然后是子类</p><p>当父类有带参数的构造器时，用super调用  super(参数)</p><h3 id="3：特点"><a href="#3：特点" class="headerlink" title="3：特点"></a><strong>3：特点</strong></h3><p><strong>单根继承结构</strong></p><p><strong>所有都继承与一个终极基类 Object</strong></p><p><strong>好处</strong></p><ul><li>可以在每个对象上执行某些基本操作   tostring等方法</li><li>所有对象都很容易在堆上创建 </li><li>参数的传递也得到了极大的简化   </li><li>使垃圾回收器的实现变得容易得多</li><li>由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局，这对于系统级操作（如异常处理）显得尤为重要</li></ul><h3 id="4、继承的好处："><a href="#4、继承的好处：" class="headerlink" title="4、继承的好处："></a><strong>4、继承的好处：</strong></h3><p>  <strong>继承提高了代码的复用性</strong></p><p>  <strong>继承的出现让类与类产生了关联，提供了多态的前提</strong></p><h3 id="5、父子类中成员的关系"><a href="#5、父子类中成员的关系" class="headerlink" title="5、父子类中成员的关系"></a><strong>5、父子类中成员的关系</strong></h3><p><strong>成员变量</strong></p><p><strong>成员方法</strong></p><p><strong>构造方法</strong></p><p>子类实例化时，必须先实例化父类对象(默认是调用父类的无参构造器即 super（）),而且是在子类构造器 第一行代码 写上 super（） 若是有参构造器,则 super(2）带上对应的参数</p><p><strong>重写与重载</strong></p><p><strong>重载</strong>：<em>同一个类中</em>，方法名相同，参数列表不同，重载可以改变返回类型</p><p><strong>重写/覆盖</strong> ： <em>在不同类中(子父类）</em>,方法的名称，参数，返回值都相同</p><p><strong>6、this和super关键字</strong></p><p>this代表子类本身引用</p><p>super代表 父类的引用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、概念：&quot;&gt;&lt;a href=&quot;#1、概念：&quot; class=&quot;headerlink&quot; title=&quot;1、概念：&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、概念：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能
      
    
    </summary>
    
    
      <category term="面向对象" scheme="http://cxqiang.gitee.io/blog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>封装</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/%E5%B0%81%E8%A3%85/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/封装/</id>
    <published>2019-08-29T13:43:13.000Z</published>
    <updated>2019-08-30T14:16:08.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a><strong>1、概念</strong></h3><p>封装从字面上来理解就是包装的意思，专业点就是<strong>信息隐藏</strong>，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，<strong>数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。</strong>系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。</p><p><em>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。</em></p><h3 id="2、好处"><a href="#2、好处" class="headerlink" title="2、好处"></a><strong>2、好处</strong></h3><p>  比如我们常用将类的属性设置为private的，然后通过get set方法来访问</p><ol><li><p>良好的封装能够减少耦合。</p><p>外部只能通过 暴露的接口访问类的信息（get，set方法）</p></li><li><p>类内部的结构可以自由修改。</p><p>当你要修改 类中的一个日期Date型 问 String时</p></li><li><p>可以对成员进行更精确的控制。</p><p>比如说对 年龄age属性现在  可以在 set方法里 设置 if(age&gt;100|| age&lt;0)  抛出异常</p></li><li><p>隐藏信息，实现细节。</p><p>可以对外不提供一些属性的 get等外部访问方法，从而隐藏信息</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、概念&quot;&gt;&lt;a href=&quot;#1、概念&quot; class=&quot;headerlink&quot; title=&quot;1、概念&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、概念&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;封装从字面上来理解就是包装的意思，专业点就是&lt;strong&gt;信息隐藏&lt;/strong&gt;，是
      
    
    </summary>
    
    
      <category term="面向对象" scheme="http://cxqiang.gitee.io/blog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>接口和抽象类</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/接口和抽象类/</id>
    <published>2019-08-29T13:42:59.000Z</published>
    <updated>2019-08-30T14:09:53.290Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1：抽象类和抽象方法"><a href="#1：抽象类和抽象方法" class="headerlink" title="1：抽象类和抽象方法"></a><strong>1：抽象类和抽象方法</strong></h3><p>** 抽象类，包含抽象方法的类，在包含抽象方法时，必须在类前面声明为 abstract class**</p><p><strong>抽象类中可以包含普通的方法</strong></p><p><strong>其导出类必须实现抽象方法,否则其导出类 也必须声明为 抽象类</strong></p><p><strong>抽象方法：方法前面声明为 abstract，并且没有方法体</strong></p><p><strong>包含抽象方法的类叫抽象类</strong></p><p><strong>抽象类 可以包含抽象方法和普通方法</strong></p><p><strong>但是普通的类不能包含抽象方法</strong> </p><ul><li><strong>作用：</strong>使类抽象性明确起来，并告诉用户和编译器如何使用它</li></ul><h3 id="2：接口：使抽象的概念更迈进一步"><a href="#2：接口：使抽象的概念更迈进一步" class="headerlink" title="2：接口：使抽象的概念更迈进一步"></a><strong>2：接口：使抽象的概念更迈进一步</strong></h3><p><strong>关键字</strong>：interface</p><ul><li><p>interface不仅仅是一个极度抽象的类，还允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多继承变种的特性</p></li><li><p>interface这个关键字产生了一个完全抽象的类，只提供了形式而没有任何的实现</p></li><li><p>所有方法必须（自动的）是<strong>public</strong></p></li><li><p>就像类一样 将class 用interface代替 也有访问权限的 public private 包访问</p></li><li><p>在接口中的字段 默认都是并且只能是 public  static final的</p></li><li><p>方法必须是 public 的抽象方法（不能有方法体）</p></li><li><p>接口中不能有 代码块 {}  不管是不是static的</p></li><li><p>接口的实现：implements</p></li></ul><h4 id="抽象类是什么："><a href="#抽象类是什么：" class="headerlink" title="抽象类是什么："></a><strong>抽象类是什么：</strong></h4><p>抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象<strong>。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。</strong></p><p>(1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法</p><p>(2) 抽象类不能被实例化</p><p>(3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类</p><p>(4) 具体派生类必须覆盖基类的抽象方法</p><p>(5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</p><h4 id="接口是什么："><a href="#接口是什么：" class="headerlink" title="接口是什么："></a><strong>接口是什么：</strong></h4><p>(1) 接口不能被实例化</p><p>(2) 接口只能包含方法声明</p><p>(3) 接口的成员包括方法、属性、索引器、事件</p><p>(4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员</p><h4 id="接口和抽象类的区别："><a href="#接口和抽象类的区别：" class="headerlink" title="接口和抽象类的区别："></a><strong>接口和抽象类的区别：</strong></h4><p>（1）抽象类可以有构造方法，接口中不能有构造方法。</p><p>（2）抽象类中可以有普通成员变量，接口中没有普通成员变量</p><p>（3）抽象类中可以包含静态方法，接口中不能包含静态方法</p><p>（4） 一个类可以实现多个接口，但只能继承一个抽象类。</p><p>（5）接口可以被多重实现，抽象类只能被单一继承</p><p>（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</p><h4 id="接口和抽象类的相同点："><a href="#接口和抽象类的相同点：" class="headerlink" title="接口和抽象类的相同点："></a><strong>接口和抽象类的相同点：</strong></h4><p>(1) 都可以被继承</p><p>(2) 都不能被实例化</p><p>(3) 都可以包含方法声明</p><p>(4) 派生类必须实现未实现的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1：抽象类和抽象方法&quot;&gt;&lt;a href=&quot;#1：抽象类和抽象方法&quot; class=&quot;headerlink&quot; title=&quot;1：抽象类和抽象方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;1：抽象类和抽象方法&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;** 抽象类，包含抽象方法的类，在包含抽象
      
    
    </summary>
    
    
      <category term="面向对象" scheme="http://cxqiang.gitee.io/blog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>类与对象</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/类与对象/</id>
    <published>2019-08-29T13:42:47.000Z</published>
    <updated>2019-08-30T14:04:39.860Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1：什么是对象</strong></p><p>可谓万物皆对象，对象是客观存在的的事物，可以说任何客观存在都可以成为对象，(一台电脑,一只笔，一辆车)，对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p><p><strong>每个对象都提供服务</strong></p><p><strong>高内聚低耦合</strong></p><p>​     <strong>高内聚</strong>就是说相关度比较高的部分尽可能的集中，不要分散</p><p>​     <strong>低耦合</strong>就是说两个相关的模块尽可以能把依赖的部分降低到最小，不要让两个系统产生强依赖</p><p><strong>2: 什么是类呢？</strong></p><p>​    类就是对象的模板，它描述一类的对象的行为（方法）状态（属性）</p><p>​    而对象就是类的一个实例    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1：什么是对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可谓万物皆对象，对象是客观存在的的事物，可以说任何客观存在都可以成为对象，(一台电脑,一只笔，一辆车)，对象是类的一个实例（&lt;strong&gt;对象不是找个女朋友&lt;/strong&gt;），有状态和行为。例如，一条狗是一
      
    
    </summary>
    
    
      <category term="面向对象" scheme="http://cxqiang.gitee.io/blog/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>this和super关键字</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/this_super/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/this_super/</id>
    <published>2019-08-29T13:25:58.000Z</published>
    <updated>2019-08-29T13:40:35.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-this"><a href="#1-this" class="headerlink" title="1. this"></a>1. this</h2><ul><li>this是自身的一个对象，代表对象本身，可以理解为：当前对象的引用。只能在方法内部使用</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><pre><code>* 引用当前对象的成员变量和方法* 引用类的构造器 this(参数)* 返回对象的值 return this</code></pre><h5 id="注意：在构造器中调用构造器"><a href="#注意：在构造器中调用构造器" class="headerlink" title="注意：在构造器中调用构造器"></a>注意：在构造器中调用构造器</h5><pre><code>* 不能调用两个构造器，必须将构造器调用在起始位置，除了构造器外禁止在其他任何方法中调用构造器    </code></pre><h2 id="2-super"><a href="#2-super" class="headerlink" title="2. super"></a>2. super</h2><p>​    super是父类的一个对象，代表离自己最近的一个父类，可以理解为：父类的引用。只能在方法内部使用</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul><li>与this类似，应用父类的成员变量和方法</li><li><strong>子类中的成员变量或方法与父类中的成员变量或方法同名</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">"Shanghai"</span>;</span><br><span class="line">        <span class="keyword">super</span>.value(); <span class="comment">// 调用父类的方法</span></span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        City c = <span class="keyword">new</span> City();</span><br><span class="line">        c.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="这输出的是"><a href="#这输出的是" class="headerlink" title="这输出的是"></a>这输出的是</h4><pre><code>ShanghaiChina</code></pre><p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。</p><ul><li>引用类的构造器 super(参数)  （必须在构造器代码的第一行，默认都有父类构造器 super()在代码第一行的，若有参数就要显示的写出了）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-this&quot;&gt;&lt;a href=&quot;#1-this&quot; class=&quot;headerlink&quot; title=&quot;1. this&quot;&gt;&lt;/a&gt;1. this&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;this是自身的一个对象，代表对象本身，可以理解为：当前对象的引用。只能在方法内部使用&lt;/l
      
    
    </summary>
    
    
      <category term="关键字" scheme="http://cxqiang.gitee.io/blog/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>权限修饰符</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/permission_controller/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/permission_controller/</id>
    <published>2019-08-29T13:18:39.000Z</published>
    <updated>2019-08-29T13:24:32.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a><strong>权限修饰符</strong></h1><h3 id="私有的权限private："><a href="#私有的权限private：" class="headerlink" title="私有的权限private："></a><strong>私有的权限private：</strong></h3><ul><li>private 可以修饰 数据成员，构造方法，方法成员，可以修饰成员内部类，被private修饰的成员，只能在定义了它们的类中使用，在其他的类中不能被调用，私有的，创建者和内部使用</li></ul><h3 id="默认权限：（default）"><a href="#默认权限：（default）" class="headerlink" title="默认权限：（default）"></a><strong>默认权限：（default）</strong></h3><ul><li>可修饰，类，数据成员，构造方法，方法成员，使用默认的权限，即不写任何的关键字，默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包 的类中被调用，<strong>且子类不能访问 （除非子类和它是在同一个包里面）</strong></li></ul><h3 id="受保护的权限-protected"><a href="#受保护的权限-protected" class="headerlink" title="受保护的权限 protected"></a><strong>受保护的权限 protected</strong></h3><ul><li>protected可以修饰 数据成员，构造方法，方法成员，可以修饰成员内部类，被 protected修饰得到成员，被protected修饰的成员，能在定义它们的类中，同包 的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。</li></ul><h3 id="公有的权限-public"><a href="#公有的权限-public" class="headerlink" title="公有的权限 public"></a><strong>公有的权限 public</strong></h3><ul><li>可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。</li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h4><ol><li><p>并不是每个修饰符都可以修饰类（指外部类），只有public和default可以。</p></li><li><p>所有修饰符都可以修饰<strong>数据成员</strong>，<strong>方法成员</strong>，<strong>构造方法</strong>。</p><p> 在private放在构造器前面你不能调用new来创建对象：应用：单例模式</p><ol start="3"><li>为了代码安全起见，修饰符不要尽量使用权限大的，而是适用即可。比如，数据成员，如果没有特殊需要，尽可能用private。<ol start="4"><li>修饰符修饰的是“被访问”的权限。</li></ol></li></ol></li></ol><p><strong>为什么要权限控制</strong></p><ul><li><p>为了不让客户端触及和修改</p></li><li><p>为了让类库设计者可用更改类的内部工作方式，而不必担心会对用户造成影响。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;权限修饰符&quot;&gt;&lt;a href=&quot;#权限修饰符&quot; class=&quot;headerlink&quot; title=&quot;权限修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;权限修饰符&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;私有的权限private：&quot;&gt;&lt;a href=&quot;#私有的权限privat
      
    
    </summary>
    
    
      <category term="关键字" scheme="http://cxqiang.gitee.io/blog/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>static</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/static/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/static/</id>
    <published>2019-08-29T12:54:11.000Z</published>
    <updated>2019-08-29T13:16:50.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。</li><li>同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。</li><li>static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。</li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><pre><code>- static方法就是没有this的方法。**在static方法内部不能调用非静态方法，反过来是可以的。**而且可以在没有创建任何对象的前提下，仅仅**通过类本身来调用static方法**。这实际上正是static方法的主要用途。</code></pre><ul><li>在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。但是在非静态方法中可以访问静态成员的</li><li>只能访问static变量</li></ul><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><ul><li>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li><li>static变量并不是所在类的某个具体对象所有，而是该类的所有对象所共有的，<strong>静态变量既能被对象调用，也能直接拿类来调用。</strong></li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><ul><li>static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。<strong>在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次</strong>。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li></ul><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a><strong>误区</strong></h4><ul><li><p>static关键字并不会改变变量和方法的访问权限。只有private,public,protected,(包访问)才能改变其访问权限</p></li><li><p>在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）</p></li><li><p>在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。</p></li><li><p>static和final一块用表示什么？</p><pre><code>1. static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！    2. 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。    3. 对于方法，表示不可覆盖，并且可以通过类名直接访问。</code></pre></li></ul><h4 id="static的局限"><a href="#static的局限" class="headerlink" title="static的局限"></a><strong>static的局限</strong></h4><pre><code>1. 它只能调用static变量。  2. 它只能调用static方法。  3. 不能以任何形式引用this、super。  4. static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。</code></pre><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在J
      
    
    </summary>
    
    
      <category term="关键字" scheme="http://cxqiang.gitee.io/blog/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>final</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/final/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/final/</id>
    <published>2019-08-29T12:31:13.000Z</published>
    <updated>2019-08-29T12:52:50.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>final关键字在java中有<strong>“这是无法改变的”</strong>或者<strong>“终态的”</strong>含义，可以修饰类(非抽象的)，方法(非抽象的)，变量</p><ul><li>final类不能被继承，没有子类，final类中的方法默认都是final的</li><li>final方法不能被子类覆盖，但可以被继承调用</li><li>final变量表示为常量，只能被赋值一次，赋值后值不在修改</li><li>final不能用于修饰构造方法</li></ul><h3 id="1-final类"><a href="#1-final类" class="headerlink" title="1. final类"></a>1. final类</h3><p>​    final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。我们见到的String类就是final类</p><h3 id="2-final方法"><a href="#2-final方法" class="headerlink" title="2. final方法"></a>2. final方法</h3><p>​    把方法锁定，以防任何继承类修改它的含义，不能重载覆盖</p><p>​    注意：类的private方法会隐式地被指定为final方法</p><h3 id="3-final变量"><a href="#3-final变量" class="headerlink" title="3. final变量"></a>3. final变量</h3><ul><li>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>修饰成员变量时必须在定义或者构造器中赋值初始化(空白final)</li><li>修饰普通变量时必须赋值才能使用</li></ul><h3 id="4-final参数"><a href="#4-final参数" class="headerlink" title="4. final参数"></a>4. final参数</h3><p>​    当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</p><h3 id="5-应用"><a href="#5-应用" class="headerlink" title="5. 应用"></a>5. 应用</h3><pre><code>- 一个永不改变的编译时常量- 一个在运行时被初始化的值，不希望你改变他</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;final&quot;&gt;&lt;a href=&quot;#final&quot; class=&quot;headerlink&quot; title=&quot;final&quot;&gt;&lt;/a&gt;final&lt;/h1&gt;&lt;p&gt;final关键字在java中有&lt;strong&gt;“这是无法改变的”&lt;/strong&gt;或者&lt;strong&gt;“终态的”&lt;/
      
    
    </summary>
    
    
      <category term="关键字" scheme="http://cxqiang.gitee.io/blog/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>visitor</title>
    <link href="http://cxqiang.gitee.io/blog/2019/08/29/visitor/"/>
    <id>http://cxqiang.gitee.io/blog/2019/08/29/visitor/</id>
    <published>2019-08-29T07:50:38.000Z</published>
    <updated>2019-08-29T07:50:38.327Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
