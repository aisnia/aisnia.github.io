[{"title":"Selector选择器与网络通信","date":"2019-09-05T13:40:10.000Z","path":"2019/09/05/Selector选择器/","text":"1：nio阻塞式 BlockingNIO 一：使用NIO完成网络通信 三个核心 1、通道(Channel) ：负责连接 java.nio.channels.Channel |–SelecttableChannel |–SocketChannel |–ServerSocketChannel |–DatagramChannel |–Pipe.SinkChannel |–Pipe.SourceChannel 2、缓冲区(Buffer) : 负责数据的存取 3、选择器：(selector) : 是SelecttableChannel 多路复用器。用于监控SelecttableChannel的IO状况 选择器NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。 1. 创建选择器1Selector selector = Selector.open();Copy to clipboardErrorCopied 2. 将通道注册到选择器上123ServerSocketChannel ssChannel = ServerSocketChannel.open();ssChannel.configureBlocking(false);ssChannel.register(selector, SelectionKey.OP_ACCEPT);Copy to clipboardErrorCopied 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 它们在 SelectionKey 的定义如下： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4;Copy to clipboardErrorCopied 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如： 1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;Copy to clipboardErrorCopied 3. 监听事件1int num = selector.select();Copy to clipboardErrorCopied 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 4. 获取到达的事件1234567891011Set&lt;SelectionKey&gt; keys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove();&#125;Copy to clipboardErrorCopied 5. 事件循环因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 1234567891011121314while (true) &#123; int num = selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove(); &#125;&#125; 6、demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.xiaoqiang.nio;import org.junit.Test;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.file.Paths;import java.nio.file.StandardOpenOption;/** * @author xiaoqiang * @date 2019/7/25-19:37 */public class TestBlockingNIO2 &#123; // 客户端 @Test public void client() throws IOException &#123; SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898)); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); FileChannel fileChannel = FileChannel.open(Paths.get(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\1.jpg\"), StandardOpenOption.READ); while (fileChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); &#125;// 这样会服务器不知道 客户端是否传输完了 所有要手动shutdown socketChannel.shutdownOutput();// 接受服务端的反馈 while (socketChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); System.out.println(new String(byteBuffer.array())); byteBuffer.clear(); &#125; fileChannel.close(); socketChannel.close(); &#125; // 服务端 @Test public void server() throws IOException &#123; ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.bind(new InetSocketAddress(9898)); FileChannel fileChannel = FileChannel.open(Paths.get(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\2.jpg\"), StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE); SocketChannel socketChannel = serverSocketChannel.accept(); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); while (socketChannel.read(byteBuffer) != -1) &#123; byteBuffer.flip(); fileChannel.write(byteBuffer); byteBuffer.clear(); &#125; byteBuffer.put(\"ok 收到了\".getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); serverSocketChannel.close(); socketChannel.close(); fileChannel.close(); &#125;&#125; 非阻塞的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.xiaoqiang.nio;import org.junit.Test;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.*;import java.util.Date;import java.util.Iterator;/** * @author xiaoqiang * @date 2019/7/25-19:55 */public class TestNonBlockingNIO &#123; @Test public void client() throws IOException &#123;// 1获取通道 SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(\"127.0.0.1\", 9898));// 2切换成非阻塞的模式 socketChannel.configureBlocking(false);// 分配指定大小的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024);// 发送数据给服务端 byteBuffer.put(new Date().toString().getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); socketChannel.close(); &#125; @Test public void server() throws IOException &#123;// 1 获取通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();// 2 切换为非阻塞模式 serverSocketChannel.configureBlocking(false);// 3 绑定端口号 serverSocketChannel.bind(new InetSocketAddress(9898));// 4 获取选择器 Selector selector = Selector.open();// 5 将通道注册到选择器上 并且指定监听的时间// 第二个参数是选择键 即监控的状态 SelectionKey的常量 1 读 4写 8连接 接受16 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);// 轮询式的获取选择器上 准备就绪的 事件 while (selector.select() &gt; 0) &#123;// 7 获取当前选择器中所有注册的选择键(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; // 8 获取事件 SelectionKey sk = iterator.next();// 9 判断是什么事件准备就绪 if (sk.isAcceptable()) &#123;// 10 接受就绪 就获取客户端的连接 SocketChannel socketChannel = serverSocketChannel.accept();// 11 切换到非阻塞模式 socketChannel.configureBlocking(false);// 12 将 改通道注册到 选择器上 socketChannel.register(selector, SelectionKey.OP_READ); &#125; else if (sk.isReadable()) &#123;// 13 获取当前选择上读就绪 状态的通道 SocketChannel channel = (SocketChannel) sk.channel();// 读取数据 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); int len=0; while ((len = channel.read(byteBuffer)) &gt; 0) &#123; byteBuffer.flip(); System.out.println(new String(byteBuffer.array(), 0, len)); byteBuffer.clear(); &#125; &#125; // 15、取消选择键 iterator.remove(); &#125; &#125; &#125;&#125; UDP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.xiaoqiang.nio;import org.junit.Test;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.DatagramChannel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.util.Date;import java.util.Iterator;import java.util.Scanner;/** * @author xiaoqiang * @date 2019/7/25-20:30 */public class TestNonBlockingNIO2 &#123; public static void main(String[] args) throws IOException &#123; send(); &#125; public static void send() throws IOException &#123; DatagramChannel dc = DatagramChannel.open(); dc.configureBlocking(false); ByteBuffer byteBuffer = ByteBuffer.allocate(1024); Scanner scan = new Scanner(System.in); while (scan.hasNext()) &#123; String str = scan.next(); byteBuffer.put((new Date().toString() + \": \\n\" + str).getBytes()); byteBuffer.flip(); dc.send(byteBuffer, new InetSocketAddress(\"127.0.0.1\", 9898)); byteBuffer.clear(); &#125; dc.close(); &#125; @Test public void receive() throws IOException &#123; DatagramChannel dc = DatagramChannel.open(); dc.configureBlocking(false); dc.bind(new InetSocketAddress(9898)); Selector selector = Selector.open();// UDP无连接 只有监听读模式就行 dc.register(selector, SelectionKey.OP_READ); while (selector.select()&gt;0) &#123; Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()) &#123; SelectionKey sk = iterator.next(); if (sk.isReadable()) &#123; ByteBuffer byteBuffer = ByteBuffer.allocate(1024); dc.receive(byteBuffer); byteBuffer.flip(); System.out.println(new String(byteBuffer.array(), 0, byteBuffer.limit())); byteBuffer.clear(); &#125; iterator.remove(); &#125; &#125; &#125;&#125;","tags":[{"name":"NIO","slug":"NIO","permalink":"http://cxqiang.gitee.io/blog/tags/NIO/"}]},{"title":"网络通信","date":"2019-09-05T13:25:08.000Z","path":"2019/09/05/网络通信/","text":"","tags":[]},{"title":"Channel通道","date":"2019-09-05T13:08:29.000Z","path":"2019/09/05/Channel通道/","text":"通道Channel表示IO源与目标打开的连接 其实类似于传统的 ‘流’，不过Channel本身不能直接的访问数据，只能与Buffer交互 通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 原始 IO流 通道 独立的处理器 一、通道(Channel)用于源节点与目标节点的连接，在JAVA NIO中缓冲区中数据的传输，本身是不存储任何数据的，因此需要配合缓冲区进行传输 二、通道的主要实现类​ 实现了 java.nio.channels.Channel 接口 ​ FileChannel 本地文件 ​ SocketChannel TCP ​ ServerSockerChannel TCP ​ DatagramChannel UDP 三、获取通道1、java支持通道的类提供了 getChannel()方法​ 本地文件IO ​ FileInputStream /FileOutStream ​ RandomAccessFile ​ 网络IO ​ Socket ​ ServerSocket ​ DatagramSocket 2、JDK1.7 的NIO.2针对各个通道 提供了open()方法 3、JDK1.7的NIO.2的FIles 工具类提供了newByteChannel()方法 四：通道之间的数据传输transferTo() transferFrom() 五：分散(Scatter)与聚集(Gather)分散读取 将通道中的数据分散到多个缓冲区中 聚集写入 将多个缓冲区中的数据聚集到通道中 六：字符集Charset编码：字符串 –》 字节数组 解码： 字节数组 –》 字符串 七： 直接缓冲区 和 非直接缓冲区1、字节缓冲区要么是直接的，要么是非直接的。如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。 2、 直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法 来创建。此方法返回的 缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区 。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对 应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 3、 直接字节缓冲区还可以过 通过FileChannel 的 map() 方法 将文件区域直接映射到内存中来创建 。该方法返回MappedByteBuffer 。Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 4、字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理 非直接缓冲区 直接缓存区创建和销毁物理内存 消耗资源，而且写入物理内存，不受管理了 但是高效，减少了中间的复杂操作 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** * @author xiaoqiang * @date 2019/7/24-21:18 */public class TestChannel &#123; // 非直接缓冲区 @Test public void test() throws IOException &#123; // 利用通道来完成文件的复制 FileInputStream in = new FileInputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\1.jpg\"); FileOutputStream out = new FileOutputStream(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\2.jpg\");// 1 获取通道 FileChannel inChannel = in.getChannel(); FileChannel outChannel = out.getChannel();// 2 分配指定大小的缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate(1024);// 3 将通道中的数据存入缓冲区 while (inChannel.read(byteBuffer) != -1) &#123; // 将缓冲区的数据写入通道// 切换成读取数据的模式 byteBuffer.flip(); outChannel.write(byteBuffer);// 清空缓冲区 byteBuffer.clear(); &#125; outChannel.close(); inChannel.close(); in.close(); out.close(); &#125; // 使用直接缓冲区完成文件的复制(内存映射文件) @Test public void test1() throws IOException &#123;// 前一个参数是文件路径，后一个参数是 操作的模式 比如这里是读操作 FileChannel inChannel = FileChannel.open(Paths.get(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\1.jpg\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\2.jpg\"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);// 内存映射文件 直接缓存 只是获取方式不一样 MappedByteBuffer inMapBuffer = inChannel.map(FileChannel.MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMapBuffer = outChannel.map(FileChannel.MapMode.READ_WRITE, 0, inChannel.size());// 不需要通道类读写了 byte[] bytes = new byte[inMapBuffer.limit()]; inMapBuffer.get(bytes); outMapBuffer.put(bytes); inChannel.close(); outChannel.close(); &#125; //通道之间的数据传输(直接缓冲区的方式) @Test public void test3() throws IOException &#123; // 前一个参数是文件路径，后一个参数是 操作的模式 比如这里是读操作 FileChannel inChannel = FileChannel.open(Paths.get(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\1.jpg\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\2.jpg\"), StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);// inChannel.transferTo(0, inChannel.size(), outChannel); outChannel.transferFrom(inChannel, 0, inChannel.size()); inChannel.close(); outChannel.close(); &#125; @Test public void test4() throws IOException &#123; RandomAccessFile raf1 = new RandomAccessFile(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\1.jpg\", \"rw\");// 获取通道 FileChannel channel1 = raf1.getChannel();// 指定分配大小的缓冲区 ByteBuffer byteBuffer1 = ByteBuffer.allocate(100); ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024);// 分散读取 ByteBuffer[] byteBuffers = &#123;byteBuffer1, byteBuffer2&#125;; channel1.read(byteBuffers); for (ByteBuffer byteBuffer : byteBuffers) &#123; byteBuffer.flip(); &#125; System.out.println(new String(byteBuffers[0].array(), 0, byteBuffers[0].limit())); System.out.println(\"---------\"); System.out.println(new String(byteBuffers[1].array(), 0, byteBuffers[1].limit()));//具体写入 RandomAccessFile raf2 = new RandomAccessFile(\"C:\\\\Users\\\\Dell\\\\Desktop\\\\2.jpg\", \"rw\"); FileChannel channel2 = raf2.getChannel(); channel2.write(byteBuffers); &#125;// 编码集 @Test public void test5() &#123; Map&lt;String, Charset&gt; map = Charset.availableCharsets(); Set&lt;Map.Entry&lt;String, Charset&gt;&gt; set = map.entrySet(); for (Map.Entry&lt;String, Charset&gt; stringCharsetEntry : set) &#123; System.out.println(stringCharsetEntry.getKey() + \"=\" + stringCharsetEntry.getValue()); &#125; &#125; @Test public void test6() throws CharacterCodingException &#123; Charset cs1 = Charset.forName(\"GBK\");// 获取编码器 CharsetEncoder ce = cs1.newEncoder();// 获取解码器 CharsetDecoder cd = cs1.newDecoder(); CharBuffer charBuffer = CharBuffer.allocate(1024); charBuffer.put(\"小强\"); charBuffer.flip();// 编码 ByteBuffer byteBuffer = ce.encode(charBuffer); for (int i = 0; i &lt; 4; i++) &#123; System.out.println(byteBuffer.get()); &#125;// 解码 byteBuffer.flip(); CharBuffer charBuffer1 = cd.decode(byteBuffer); System.out.println(charBuffer1.toString()); System.out.println(\"--------------------------------\"); &#125;&#125; 文件加锁FileChannel的 tryLock() 方法 和 lock()方法 来加锁 可获得整个FileLock 参数都是 long position , long size ,boolean shared 加锁的区域是由 size-position 来决定的，即加载 position 到 position+size 区域，在这之外的部分不会被锁定 shared 指定是否为共享锁 使用 FIleLock.isShared()进行查询 是独占锁 还是 共享锁 使用FileLock的 release()方法可以释放锁 管道1234567891011121314151617181920212223242526272829/** * @author xiaoqiang * @date 2019/7/25-21:04 */public class TestPipe &#123; @Test public void test1() throws IOException &#123;// 1 获取管道 Pipe pipe = Pipe.open();// 2 将缓冲区的数据写入管道 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); byteBuffer.put(\"通过单向管道发送数据\".getBytes()); Pipe.SinkChannel sinkChannel = pipe.sink(); byteBuffer.flip(); sinkChannel.write(byteBuffer); byteBuffer.clear();s// 读取缓冲区中的数据 Pipe.SourceChannel sourceChannel = pipe.source(); ByteBuffer byteBuffer2 = ByteBuffer.allocate(1024); byteBuffer.flip(); sourceChannel.read(byteBuffer2); System.out.println(new String(byteBuffer2.array(), 0, byteBuffer2.limit())); sinkChannel.close(); sourceChannel.close(); &#125;&#125;","tags":[{"name":"NIO","slug":"NIO","permalink":"http://cxqiang.gitee.io/blog/tags/NIO/"}]},{"title":"Buffer缓冲区","date":"2019-09-05T12:52:04.000Z","path":"2019/09/05/Buffer缓冲区/","text":"缓冲区发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区中的核心属性 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 ② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。 ③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 当然还有mark 属性 在调用 mark()方法时，会将当前的position 赋值熬mark 上，即标记一下，当调用 reset()方法时 position 会重置到之前 mark的位置 直接缓冲区，非直接缓冲区非直接缓冲区：通过allocate() / wrap( byte[] buf )方法分配缓存区，将缓冲区建立在JVM的内存中 直接缓冲区：通过allocateDirect() 方法分配缓存区，将缓冲区建立到操作系统的物理内存中，可以提高效率 ​ buf.isDirect() 判断是否为直接缓冲区 测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.xiaoqiang.nio;import org.junit.Test;import java.nio.ByteBuffer;/** * @author xiaoqiang * @date 2019/7/24-12:52 */public class TestBuffer &#123; @Test public void test1() &#123;// 分配一个指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); System.out.println(\"-------------allocate---------\"); System.out.println(\"position \" + buf.position()); System.out.println(\"limit \" + buf.limit()); System.out.println(\"capacity \" + buf.capacity());// 写数据 String s = \"abcde\"; buf.put(s.getBytes()); System.out.println(\"-------------put---------\"); System.out.println(\"position \" + buf.position()); System.out.println(\"limit \" + buf.limit()); System.out.println(\"capacity \" + buf.capacity());//切换成读取数据的模式 buf.flip(); System.out.println(\"-------------flip---------\"); System.out.println(\"position \" + buf.position()); System.out.println(\"limit \" + buf.limit()); System.out.println(\"capacity \" + buf.capacity());// get缓存区的数据 byte[] bytes = new byte[buf.limit()]; buf.get(bytes); System.out.println(new String(bytes)); System.out.println(\"-------------get---------\"); System.out.println(\"position \" + buf.position()); System.out.println(\"limit \" + buf.limit()); System.out.println(\"capacity \" + buf.capacity());// rewind() : 可重复读数据 即把position变为0 buf.rewind(); System.out.println(\"-------------rewind---------\"); System.out.println(\"position \" + buf.position()); System.out.println(\"limit \" + buf.limit()); System.out.println(\"capacity \" + buf.capacity());// clear() 情况缓存去 但是缓冲区的数据还存在，但处于被遗忘的状态，只是把position，limit指针变为原来的 buf.clear(); System.out.println(\"-------------clear---------\"); System.out.println(\"position \" + buf.position()); System.out.println(\"limit \" + buf.limit()); System.out.println(\"capacity \" + buf.capacity());// reset() &#125; @Test public void test2() &#123; String s = \"abcde\"; ByteBuffer buf = ByteBuffer.allocate(1024); buf.put(s.getBytes()); buf.flip(); byte[] bytes = new byte[buf.limit()]; buf.get(bytes, 0, 2); System.out.println(new String(bytes, 0, 2)); System.out.println(buf.position());// 标记一下 position buf.mark(); buf.get(bytes, 2, 2); System.out.println(new String(bytes,2,2)); System.out.println(buf.position()); buf.reset(); System.out.println(buf.position());// hasRemaining() 判断缓冲区是否还有操作数据 if (buf.hasRemaining()) &#123; //remaining() 返回可操作数据的数量 System.out.println(buf.remaining()); &#125; &#125; &#125;","tags":[{"name":"NIO","slug":"NIO","permalink":"http://cxqiang.gitee.io/blog/tags/NIO/"}]},{"title":"NIO概览","date":"2019-09-05T12:36:00.000Z","path":"2019/09/05/NIO概览/","text":"Java NIO（New IO，Non Blocking IO 非阻塞IO）是从Java 1.4版本开始引入的 一个新的IO API，可以替代标准的Java IO API。 NIO与原来的IO有同样的作用和目的，但是使用 的方式完全不同，NIO支持面向缓冲区的、基于 通道的IO操作。NIO将以更加高效的方式进行文 件的读写操作。NIO采用内存映射文件的方式来处理输入输出，NIO将文件或文件的一段区域映射到内存中，这样就可以像访问内存一样访问文件了。 流与块的比较​ 原来的 I/O 库(在 java.io.*中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 ​ 面向流 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。 ​ 一个 面向块 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 ​ 在NIO中有几个核心对象需要掌握：缓冲区（Buffer）、通道（Channel）、选择器（Selector）。 NIO与IO主要的区别 IO NIO 面向流的 面向缓存区 阻塞IO 非阻塞IO 无 有选择器 IO NIO NIO的核心是 通道(Channel) 和 缓冲区(Buffer) 通道表示 打开到IO设备(文件，套接字)的连接，当用到NIO系统时，需要获取连接设备的通道以及用于容纳数据的缓存区，然后操作缓冲区，对数据进行处理 简而言之：Channel 负责传输，Buffer负责存储 二、缓冲区Buffer​ 缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。具体看下面这张图就理解了： ​ 上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入Buffer中，然后将Buffer中的内容写入通道。服务端这边接收数据必须通过Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理。 ​ 在NIO中，所有的缓冲区类型都继承于抽象类Buffer，最常用的就是ByteBuffer，对于Java中的基本类型，基本都有一个具体Buffer类型与之相对应，它们之间的继承关系如下图所示： 下面是一个简单使用IntBuffer的例子： 12345678910111213141516171819202122232425262728package com.demo.nio;import java.nio.IntBuffer;public class TestIntBuffer &#123; public static void main(String[] args) &#123; // 分配新的int缓冲区，参数为缓冲区容量 // 新缓冲区的当前位置将为零，其界限(限制位置)将为其容量。它将具有一个底层实现数组，其数组偏移量将为零。 IntBuffer buffer = IntBuffer.allocate(8); for (int i = 0; i &lt; buffer.capacity(); ++i) &#123; int j = 2 * (i + 1); // 将给定整数写入此缓冲区的当前位置，当前位置递增 buffer.put(j); &#125; // 重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为0 buffer.flip(); // 查看在当前位置和限制位置之间是否有元素 while (buffer.hasRemaining()) &#123; // 读取此缓冲区当前位置的整数，然后当前位置递增 int j = buffer.get(); System.out.print(j + &quot; &quot;); &#125; &#125;&#125; 运行后可以看到： 三、通道Channel​ Channel和传统IO中的Stream很相似。虽然很相似，但是有很大的区别，主要区别为：通道是双向的，通过一个Channel既可以进行读，也可以进行写；而Stream只能进行单向操作，通过一个Stream只能进行读或者写，比如InputStream只能进行读取操作，OutputStream只能进行写操作； ​ 通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。 ​ 在NIO中，提供了多种通道对象，而所有的通道对象都实现了Channel接口。它们之间的继承关系如下图所示： Channel(通道)表示到实体如硬件设备、文件、网络套接字或可以执行一个或多个不同I/O操作的程序组件的开放的连接。所有的Channel都不是通过构造器创建的，而是通过传统的节点InputStream、OutputStream的getChannel方法来返回响应的Channel。 Channel中最常用的三个类方法就是map、read和write，其中map方法用于将Channel对应的部分或全部数据映射成ByteBuffer，而read或write方法有一系列的重载形式，这些方法用于从Buffer中读取数据或向Buffer中写入数据。 1、使用NIO读取数据在前面我们说过，任何时候读取数据，都不是直接从通道读取，而是从通道读取到缓冲区。所以使用NIO读取数据可以分为下面三个步骤：(1). 从FileInputStream获取Channel(2). 创建Buffer(3). 将数据从Channel读取到Buffer中 下面是一个简单的使用NIO从文件中读取数据的例子： 123456789101112131415161718192021222324252627import java.io.*; import java.nio.*; import java.nio.channels.*; public class Program &#123; public static void main( String args[] ) throws Exception &#123; FileInputStream fin = new FileInputStream(\"c:\\\\test.txt\"); // 获取通道 FileChannel fc = fin.getChannel(); // 创建缓冲区 ByteBuffer buffer = ByteBuffer.allocate(1024); // 读取数据到缓冲区 fc.read(buffer); buffer.flip(); while (buffer.remaining()&gt;0) &#123; byte b = buffer.get(); System.out.print(((char)b)); &#125; fin.close(); &#125; &#125; 2、使用NIO写入数据使用NIO写入数据与读取数据的过程类似，同样数据不是直接写入通道，而是写入缓冲区，可以分为下面三个步骤：(1). 从FileInputStream获取Channel(2). 创建Buffer(3). 将数据从Channel写入到Buffer中 下面是一个简单的使用NIO向文件中写入数据的例子： 123456789101112131415161718192021222324252627282930package com.demo.nio;import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class Program &#123; private static final byte message[] = &#123; 83, 111, 109, 101, 32, 98, 121, 116, 101, 115, 46 &#125;; public static void main( String args[] ) throws Exception &#123; FileOutputStream fout = new FileOutputStream( \"c:\\\\test.txt\" ); FileChannel fc = fout.getChannel(); ByteBuffer buffer = ByteBuffer.allocate( 1024 ); for (int i=0; i&lt;message.length; ++i) &#123; buffer.put( message[i] ); &#125; buffer.flip(); fc.write( buffer ); fout.close(); &#125;&#125; 四、选择器Selector​ Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。 与Selector有关的一个关键类是SelectionKey，一个SelectionKey表示一个到达的事件，这2个类构成了服务端处理业务的关键逻辑。","tags":[{"name":"NIO","slug":"NIO","permalink":"http://cxqiang.gitee.io/blog/tags/NIO/"}]},{"title":"ByteArray","date":"2019-09-05T08:21:44.000Z","path":"2019/09/05/ByteArray/","text":"ByteArrayInputStreamByteArrayInputStream,就是从一个byte 数组里边读取数据到内存的缓冲区,然后可以利用这个输入流的对象对缓冲区数据进行特定操作. 我(字节输入流)将byte数组里的数据读入缓冲区,然后我又操作这个缓冲区; 123456789101112// 构造函数ByteArrayInputStream(byte[] buf)ByteArrayInputStream(byte[] buf, int offset, int length)synchronized int available() void close()synchronized void mark(int readlimit) boolean markSupported()synchronized int read()synchronized int read(byte[] buffer, int offset, int length)synchronized void reset()synchronized long skip(long byteCount) ​ 将字节数组 buf 写入 流中（内存）中，然后在用read方法 读取出来 说明：ByteArrayInputStream实际上是通过“字节数组”去保存数据。 通过ByteArrayInputStream(byte buf[]) 或 ByteArrayInputStream(byte buf[], int offset, int length) ，我们可以根据buf数组来创建字节流对象。 read()的作用是从字节流中“读取下一个字节”。 read(byte[] buffer, int offset, int length)的作用是从字节流读取字节数据，并写入到字节数组buffer中。offset是将字节写入到buffer的起始位置，length是写入的字节的长度。 markSupported()是判断字节流是否支持“标记功能”。它一直返回true。 mark(int readlimit)的作用是记录标记位置。记录标记位置之后，某一时刻调用reset()则将“字节流下一个被读取的位置”重置到“mark(int readlimit)所标记的位置”；也就是说，reset()之后再读取字节流时，是从mark(int readlimit)所标记的位置开始读取。 123456789101112131415161718192021public class ByteArrayInputStreamTest_1 &#123; public static void main(String[] args) &#123; byte[] src = \"abcdefg\".getBytes(); InputStream is = null; //将字节数组 输入到 内存中 is = new ByteArrayInputStream(src); //用于接收的数组 byte[] b = new byte[5]; int len = -1; try &#123; //读取 输入流中的数据到 缓冲数组b中 返回读取到的长度，-1则代表已读完 while((len=is.read(b))!=-1) &#123; String str = new String(b,0,len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; ByteArrayOutputStreamByteArrayOutputStream就是将数据写入了一个可变大小的byte 数组中,至于这个数组是谁,这个数组在哪,我们不用关心,因为我们有了这个输出流,我们就有了可以操作这个byte 数组一个对象,那么我们就可以通过调用对象的方法方便地操作这个数组.这已经足够了! 一言以蔽之:我(字节输出流)往byte数组里输出数据,然后我又操作这个数组; 1234567891011121314// 构造函数ByteArrayOutputStream()ByteArrayOutputStream(int size) void close()synchronized void reset() int size()synchronized byte[] toByteArray() String toString(int hibyte) String toString(String charsetName) String toString()synchronized void write(byte[] buffer, int offset, int len)synchronized void write(int oneByte)synchronized void writeTo(OutputStream out) 说明：ByteArrayOutputStream实际上是将字节数据写入到“字节数组”中去。 通过ByteArrayOutputStream()创建的“字节数组输出流”对应的字节数组大小是32。 通过ByteArrayOutputStream(int size) 创建“字节数组输出流”，它对应的字节数组大小是size。 write(int oneByte)的作用将int类型的oneByte换成byte类型，然后写入到输出流中。 write(byte[] buffer, int offset, int len) 是将字节数组buffer写入到输出流中，offset是从buffer中读取数据的起始偏移位置，len是读取的长度。 writeTo(OutputStream out) 将该“字节数组输出流”的数据全部写入到“输出流out”中。 1234567891011121314151617181920212223242526/** * 字节数组输出流 * toByteArray():内部将数据保存在内存中，所以需要通过这个方法，获取一个字节数组 */public class ByteArrayOutputStreamTest_1 &#123; public static void main(String[] args) &#123; byte[] data = null; //创建一个字节数组输出流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); String str = \"abcdefghijklmnopqrstuvwxyz\"; //获取字符串的字节数组 byte[] b = str.getBytes(); try &#123; //将字节数组 b写入次 输出流 baos.write(b,0,b.length); baos.flush(); //将输出流装换成 字节数组 data = baos.toByteArray(); System.out.println(new String(data,0,data.length)); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;","tags":[{"name":"IO","slug":"IO","permalink":"http://cxqiang.gitee.io/blog/tags/IO/"}]},{"title":"IO概览","date":"2019-09-05T08:21:44.000Z","path":"2019/09/05/IO概览/","text":"字节流 区分， 在javaIO中输入输出的目标是内存，比如 输入流是，将文件或者其他的数据（输入）存储在流中，即 外界 ==&gt; 程序 输出流是将内存的数据输入到文件或其他载体中 程序 ==&gt; 外界 1、InputStream / OutputStreamIputStream - 用于从源中读取数据， 所有有关输入的流都从这继承 （抽象类），提供了输入流所具备的基本方法。因为读取的数据源（构造器中的数据源）不相同，所以产生了很多子类。 常用方法 public int available() 给出可以从此文件输入流中读取的字节数。 返回一个int值。 void close() 关闭此输入流并释放与流相关联的任何系统资源。 public int read(int r) 此方法从InputStream读取指定的数据字节，并返回一个int值。 返回数据的下一个字节，如果它是文件的末尾，则返回-1。 public int read(byte[] r) 此方法将输入流中的r.length个字节读入数组。返回读取的总字节数。 如果它到达文件的结尾，则返回-1。 int read(byte[] b, int off, int len) 从输入流读取最多 len字节的数据到一个字节数组，从数组off开始写入。 除了图中的，其他常见的输入流 类 功能 描述 StringBufferInputStream String转换为 InputStream 字符串，底层是StringBuffer PipedInputStream 管道输入流 用来和管道输出流对接，构造器接受一个PipedOutputStream或者同时指定int值为缓冲区的大小。 典型地使用方法，在一个线程中数据PipedInputStream读入，此数据是由另一个线程写入到对PipedOutputStream中。 单线程下使用可能还会造成死锁。 SequenceInputStream 将两个或多个InputStream对象合并成一个 2、OutStream - 用于将数据写入目标 所有有关输出的流都从这继承 （抽象类），提供了输出流所具备的基本方法，flush（）方法 是输出流的标配。 常用方法 void close() 关闭此输出流并释放与此流相关联的任何系统资源。 void flush() 刷新此输出流并强制任何缓冲的输出。 void write(byte[] b) 将 b.length字节从指定的字节数组写入此输出流 void write(byte[] b, int off, int len) 从指定的字节数组写入 len个字节，从偏移 off开始输出到此输出流。 字符流Reader和Writer是所有字符流的抽象类 常用的有 FIleReader/FileWriter 文件字符输入输出流 InputStreamReader/OutputStreamWriter 可将InputStream/OutputStream转换为Reader/Writer BufferReader /BufferWriter 对应字节流的BufferedInoutStream等 常用方法 read() 返回一个int性 即ASCII码 read(char[]) 将字符读取到字符数组里面 write(int i) 写字符 write(char[]，int off ,int len) 写入字符数组 write(String s,int off,int len) 写入字符串","tags":[{"name":"IO","slug":"IO","permalink":"http://cxqiang.gitee.io/blog/tags/IO/"}]},{"title":"File","date":"2019-09-05T08:06:38.000Z","path":"2019/09/05/File/","text":"File 类 方法声明 方法描述 File(String pathname) 通过指定的一个字符串类型的文件路径来创建一个新的File对象 File(String parent , String child) 根据指定的一个字符串类型的父路径和一个字符串类型的子路径（包括文件名称）创建一个File对象 File(File parent , String child) 根据指定的 File 类的父路径和字符串类型的子路径包括文件名称）创建一个File对象 常用方法 boolean exists() 判断File对象对应的文件或者目录是否存在若存在则返回true，否则返回false boolean delete() 删除File对象对应的文件或者目录若成功则返回true，否则返回false boolean createNewFile() 当File对象对应的文件不存在时，该方法将新建一个此File对象所指定的新文件若创建成功则返回true，否则返回false String getName() 返回File对象表示的文件或文件夹的名称 String getPath() 返回File对象对应的路径 String getAbsolutePath() 返回File对象对应的绝对路径（在UNIX/Linux等系统上，如果路径是以正斜线 / 开始的，则这个路径是绝对路径；在Windows等系统上，如果路径是从盘符开始的，则这个路径是绝对路径） String getParent() 返回File对象对应目录的父目录，（即返回的目录不包含最后一级子目录） boolean canRead() 判断File对象对应的文件或者目录是否可读若可读则返回true，反之返回false boolean canWrite() 判断File对象对应的文件或者目录是否可写。若可写则返回true，反之返回false boolean isFile() 判断File对象对应的是否是文件（不是目录）若是文件则返回true，反之返回false boolean isDirectory() 判断File对象对应的是否是目录（不是文件）若是目录则返回true，反之返回false boolean isAbsolute() 判断File对象对应的文件或者目录是否是绝对路径 long lastModified() 返回1970 年1 月1 日 0 时0 分 0 秒到文件最好修改时间的毫秒值 long length() 返回文件内容长度 String [ ]list() 返回指定目录的全部内容，只列出名称 File[ ] listFiles() 返回一个包含了File对象所有子文件和子目录的File数组 FileDescriptor 介绍 FileDescriptor 是“文件描述符”。 FileDescriptor 可以被用来表示开放文件、开放套接字等。 以FileDescriptor表示文件来说：当FileDescriptor表示某文件时，我们可以通俗的将FileDescriptor看成是该文件。但是，我们不能直接通过FileDescriptor对该文件进行操作；若需要通过FileDescriptor对该文件进行操作，则需要新创建FileDescriptor对应的FileOutputStream，再对文件进行操作。 FileInputStream/FileOutputStream FileInputStream 是文件输入流，它继承于InputStream。将文件输入到 流(内存) 中， 通常，我们使用FileInputStream从某个文件中获得输入字节。 FileOutputStream 是文件输出流，它继承于OutputStream。将 流((内存)中的数据， 输出到文件中通常，我们使用FileOutputStream 将数据写入 File 或 FileDescriptor 的输出流。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.xiaoqiang.iostream;import java.io.*;import java.math.BigInteger;import java.net.URL;import java.util.Arrays;/** * @author xiaoqiang * @date 2019/7/22-9:49 */public class TestFile &#123; public static final String fromPath = \"D:\\\\idea_workspace\\\\JavaSE\\\\src\\\\com\\\\xiaoqiang\\\\iostream\\\\abc.txt\"; public static final String toPath = \"D:\\\\idea_workspace\\\\JavaSE\\\\src\\\\com\\\\xiaoqiang\\\\iostream\\\\123.txt\"; public static void main(String[] args) &#123; try &#123; //创建文件输入流 输入到流(内存) FileInputStream file = new FileInputStream(fromPath); //创建文件输出流 FileOutputStream fileOutputStream = new FileOutputStream(toPath); //缓冲数组 byte[] bytes = new byte[512]; int len=0; while ((len = file.read(bytes) )!= -1) &#123; //读取输入流到 缓冲数组中 file.read(bytes); //将数组中的数据 写入输出流 fileOutputStream.write(bytes,0,bytes.length); //清除缓冲 fileOutputStream.flush(); &#125; file.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;","tags":[{"name":"IO","slug":"IO","permalink":"http://cxqiang.gitee.io/blog/tags/IO/"}]},{"title":"TreeSet","date":"2019-09-04T12:42:14.000Z","path":"2019/09/04/TreeSet/","text":"概述文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。 TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。这点会在接下来的代码中做说明，如果指定了比较器则按照比较器来进行排序。 特点分析1.特点分析 TreeSet是基于TreeMap的NavigableSet实现,所以要想理解好TreeSet，必须研究TreeMap。 TreeMap对其的实现中，key作为存储set中元素的位置，而value始终都是一个static final常量。 时间复杂度为:log(n)的方法：add(),remove(),contains() 非线程安全集合 支持浅拷贝、序列化 4个公有构造器、 TreeSet() TreeSet(Comparator comparator) TreeSet(Collection c) TreeSet(SortedSet s) java8新增方法1个：分割器spliterator() TreeSet是基于TreeMap的NavigableSet实现 实例化时,如果不提供比较器,则元素存储顺序为:自然排序;如果提供比较器,则按照比较器的规则排序. TreeSet在add(),remove(),contains()这3个方法中,时间复杂度为:log(n). 请注意，Set维护的顺序必须与equals等同(无论是否提供比较器),只要Set正确实现了Set接口,这是因为Set接口就equals做过定义,但是TreeSet实例使用它自己的comppareTo()方法对元素排序,因此通过这个方法被认为equals的两个元素是从Set对equals的定义出发的.即使排序与equals不一致，Set的行为也是明确定义的;它只是没有遵守Set接口的总体规则。 注意,这一实现并不是线程同步的.如果多个线程并发访问一个treeset,并且至少有一个线程更改了treeset的结构,则必须采取额外的同步措施.这通常是通过在一些自然封装集合的对象上进行同步来完成的.如果没有这样的对象存在,则set应该使用Collections#synchronizedSortedSet 或者Collections.synchronizedSortedSet来进行包装.而这一包装操作最好在实例被创建的时候就完成,以防止一些非同步的行为.格式如下: SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); 由TreeSet得到的迭代器支持fail-fast功能.注意:迭代器的fail-fast功能是不能保证的,一般来说,在任何非同步的并发修改中,都不能给出明确保证.迭代器只是尽可能的抛出异常. TreeSet类是java集合框架中的一员. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; /** * 底层map * 维护一个NavigableMap型变量，NavigableMap是TreeMap的接口 * 序列化时,值被置为null */ private transient NavigableMap&lt;E,Object&gt; m; // PRESENT定义为静态常量，用来填充map的value private static final Object PRESENT = new Object(); //包级私有构造器:根据指定参数m创建TreeSet的底层map TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; /** * 构造一个新的,空的treeset,元素按自然排序. * 插入set中的所有元素必须实现Comparable接口. * 进一步讲,在set中的任何两个元素e1,e2在进行e1.compareTo(e2)相互比较时,都不能 * 抛出类型安全异常ClassCastException. * 如果用户想要插入一个和规定冲突的元素(比如向set&lt;String&gt;集合中插入Integer对象), * 则add方法会抛出异常ClassCastException. */ //公有构造器,调用上一个构造器方法,这里可以看出底层map为treemap. public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; /** * 构造一个新的,空的treeset,元素存储顺序和传入比较器一致. * 所有被插入这个set的元素都应该可以使用这个比较器, * 即在进行comparator.compare(e1,e2)的比较时,不能抛出类型安全异常 * ClassCastException.如果用户尝试添加一个和此约束冲突的元素,则add()方法的 * 调用者会抛出类型安全异常. * 如果传入比较器为null,则使用自然排序. */ public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator)); &#125; /** * 构造一个新的但包含指定集合元素的treeset,元素顺序为自然排序. * 插入set的所有元素必须实现Comparable接口. */ public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; //创建一个新的,元素和给定参数的一致,并且排序和给定的有序set一致. public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; //迭代器,此处便可以发现,虽然底层用的是map,但是只是用了map的key对set的元素进行存储. //因为这里返回的是keyset的迭代器. public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator(); &#125; //返回一个元素降序的迭代器. public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator(); &#125; public NavigableSet&lt;E&gt; descendingSet() &#123; return new TreeSet&lt;&gt;(m.descendingMap()); &#125; //返回底层treemap的size public int size() &#123; return m.size(); &#125; //根据底层treemap,判定是否为空 public boolean isEmpty() &#123; return m.isEmpty(); &#125; //根据底层treemap,判定是否包含o对象. public boolean contains(Object o) &#123; return m.containsKey(o); &#125; /** * 调用底层的treemap,进行插入操作. * m.put(e,PRESENT),表示任何插入操作,key对应的value都是静态常量PRESETN, * 也就是底层map利用key对treeset的元素进行保存. */ public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; //调用底层treemap的remove方法,删除元素. public boolean remove(Object o) &#123; return m.remove(o)==PRESENT; &#125; //调用底层treemap的方法清空set中的元素 public void clear() &#123; m.clear(); &#125; //方法时间复杂度:线性 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; /**如果 * 1.底层Map没有存储元素 * 2.参数中包含元素 * 3.参数类型为SortedSet * 4.底层map类型为TreeMap */ if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; //类型转化 SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; //获取参数集合c的比较器. Comparator&lt;?&gt; cc = set.comparator(); //获取底层treemap的比较器. Comparator&lt;? super E&gt; mc = map.comparator(); //如果两个比较器等价,则进行插入操作;否则不插入. if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; //调用AbstractCollection方法 return super.addAll(c); &#125; //根据key值范围,截取set.调用的是NavigableSet的方法 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; //返回视图中所有元素的值:&lt;=toElement public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;&gt;(m.headMap(toElement, inclusive)); &#125; //返回视图中所有元素的值:&gt;=toElement public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive)); &#125; //参数为true,则包含等于;否则不包含等于. //因此本方中,返回key的范围为:[fromElement,toElement) public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; //返回key的范围:[,toElement) public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; /** * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException if &#123;@code fromElement&#125; is null * and this set uses natural ordering, or its comparator does * not permit null elements * @throws IllegalArgumentException &#123;@inheritDoc&#125; */ //返回key范围:[,fromElement] public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; //获取底层treemap的比较器. public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; //获取第一个key public E first() &#123; return m.firstKey(); &#125; //获取最后一个key public E last() &#123; return m.lastKey(); &#125; /*--------NavigableSet的API方法---------*/ //返回比e小且和e的差最小的key public E lower(E e) &#123; return m.lowerKey(e); &#125; //返回&lt;=e的最大key public E floor(E e) &#123; return m.floorKey(e); &#125; //返回&gt;=e的最小key public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; //返回&gt;e的最小值 public E higher(E e) &#123; return m.higherKey(e); &#125; //返回最小key;如果底层map为空,则返回null public E pollFirst() &#123; Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null) ? null : e.getKey(); &#125; //返回最大key;如果底层map为空,则返回null public E pollLast() &#123; Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null) ? null : e.getKey(); &#125; //返回treeset的浅拷贝(元素本身不会被拷贝) @SuppressWarnings(\"unchecked\") public Object clone() &#123; TreeSet&lt;E&gt; clone; try &#123; clone = (TreeSet&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(e); &#125; // clone.m = new TreeMap&lt;&gt;(m); return clone; &#125; //序列化时,将treeset实例的状态写入到流中. private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; //写入隐藏信息 s.defaultWriteObject(); //写入比较器 s.writeObject(m.comparator()); //写入size s.writeInt(m.size()); //按序写入所有key for (E e : m.keySet()) s.writeObject(e); &#125; //从读入流重构TreeSet private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; //读入隐藏信息 s.defaultReadObject(); //读入比较器 @SuppressWarnings(\"unchecked\") Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); //创建底层TreeMap TreeMap&lt;E,Object&gt; tm = new TreeMap&lt;&gt;(c); m = tm; //读入size int size = s.readInt(); //读入key,生成TreeMap tm.readTreeSet(size, s, PRESENT); &#125; /** * 创建key的分割器 * @since 1.8 */ public Spliterator&lt;E&gt; spliterator() &#123; return TreeMap.keySpliteratorFor(m); &#125; //序列化uid private static final long serialVersionUID = -2479143000061671589L;&#125;","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"Vector","date":"2019-09-04T12:18:18.000Z","path":"2019/09/04/Vector/","text":"概述文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。 Vector作为List的另外一个典型实现类，完全支持List的全部功能，Vector类也封装了一个动态的，允许在分配的Object[]数组，Vector是一个比较古老的集合，JDK1.0就已经存在，建议尽量不要使用这个集合，Vector与ArrayList的主要是区别是，Vector是线程安全的，但是性能比ArrayList要低。 数据结构继承关系1234java.lang.Object java.util.AbstractCollection&lt;E&gt; java.util.AbstractList&lt;E&gt; java.util.Vector&lt;E&gt; 实现接口1Serializable, Cloneable, Iterable&lt;E&gt;, Collection&lt;E&gt;, List&lt;E&gt;, RandomAccess 子类1Stack 基本元素属性123protected Object[] elementData; //存放元素的数组protected int elementCount; //已经放入数组的元素个数protected int capacityIncrement; //数组的增长系数 源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501package java.util;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; //定义数组，存放元素 protected Object[] elementData; //已经放入数组的元素数量 protected int elementCount; //增长的系数 protected int capacityIncrement; //可序列化版本号 private static final long serialVersionUID = -2767605614048989439L; //构造方法，提供初始大小，和增长系数 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; //构造方法，提供初始大小，增长系数为零 public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; //无参构造方法 public Vector() &#123; this(10); &#125; //构造方法，将指定的集合元素转化为Vector public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) //判断c.toArray是否是Object[]类型 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; //将elementData中的元素全部拷贝到anArray数组中 public synchronized void copyInto(Object[] anArray) &#123; System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; //将数组长度设置为等于vector的个数 public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; //扩充容量 public synchronized void ensureCapacity(int minCapacity) &#123; if (minCapacity &gt; 0) &#123; modCount++; ensureCapacityHelper(minCapacity); &#125; &#125; //扩充容量帮助函数 private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; //最大容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //扩充容量执行方法 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //根据capacityIncrement进行判断，capacityIncrement&gt; 0 增加capacityIncrement个容量，否则容量扩充当前容量的一倍 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //扩容操作，生成已给新的数组，容量为newCapacity,并将elementData中的元素全部拷贝到新数组中，并将新生成的数组在赋值给elementData elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; //设置size public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; //返回当前容量 public synchronized int capacity() &#123; return elementData.length; &#125; //返回vector的元素个数 public synchronized int size() &#123; return elementCount; &#125; //是否为空 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; //返回vector中全部元素对应的Enumeration public Enumeration&lt;E&gt; elements() &#123; //匿名内部类实现 return new Enumeration&lt;E&gt;() &#123; int count = 0; public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(\"Vector Enumeration\"); &#125; &#125;; &#125; //是否包含Object对线o public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; //返回 o 对象的位置 public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; //从index位置开始，向后查找Object对象 （o） public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //倒序查找对象 o public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; //从最后一个元素开始，向前查找对象o ,找到返回元素的索引，否则返回 -1 public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + \" &gt;= \"+ elementCount); if (o == null) &#123; for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; //返回索引为index的元素 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; return elementData(index); &#125; //返回第一个元素 public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(0); &#125; //返回最后一个元素 public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return elementData(elementCount - 1); &#125; //将index位置的元素设置为obj public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; elementData[index] = obj; &#125; //删除指定位置的元素，Object[]对象数组从index+1开始向前依次移动一个位置 public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt;= \" + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; //将obj元素插入index位置 public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + \" &gt; \" + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; //添加元素 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; //删除元素 ，删除成功返回true, 否则返回false public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; //清空所有的元素 public synchronized void removeAllElements() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; //克隆方法 public synchronized Object clone() &#123; try &#123; @SuppressWarnings(\"unchecked\") Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; //转化为数组 public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; //转化为指定类型的数组 @SuppressWarnings(\"unchecked\") public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; // Positional Access Operations @SuppressWarnings(\"unchecked\") E elementData(int index) &#123; return (E) elementData[index]; &#125; //得到索引为index的元素 public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); &#125; //设置index位置的元素为element public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125; //添加方法 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; //删除操作 public boolean remove(Object o) &#123; return removeElement(o); &#125; //将element添加到index位置上 public void add(int index, E element) &#123; insertElementAt(element, index); &#125; //删除index位置的元素 public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue; &#125; //清除 public void clear() &#123; removeAllElements(); &#125; // Bulk Operations //是否包含集合c中所有的元素 public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; //将集合c中所有的元素添加到列表中，借助System.copyOf()方法实现 public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; //删除集合c中所有的元素 public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; //将集合c 添加到index之后的位置上 public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; //判断方法 public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; //计算hashCode值 public synchronized int hashCode() &#123; return super.hashCode(); &#125; public synchronized String toString() &#123; return super.toString(); &#125; //返回从fromIndex到toIndex之间的子集合 public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; //范围删除元素 protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; //将对象写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; final java.io.ObjectOutputStream.PutField fields = s.putFields(); final Object[] data; synchronized (this) &#123; fields.put(\"capacityIncrement\", capacityIncrement); fields.put(\"elementCount\", elementCount); data = elementData.clone(); &#125; fields.put(\"elementData\", data); s.writeFields(); &#125; public synchronized ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; elementCount) throw new IndexOutOfBoundsException(\"Index: \"+index); return new ListItr(index); &#125; public synchronized ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0); &#125; public synchronized Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; //省略了Itr、ListItr、VectorSpliterator内部类的实现&#125; Vector和ArrayList的实现方式可以看出非常的类似，既然Vector类建议尽量少的使用，还是最好不要用了，通过上面的源码发现，每个方法中都添加了synchronized的关键字来保证同步，所以它是线程安全的，但正是这些方法的同步，让它的效率大大的降低了，比ArrayList的效率要慢。 给出如下几点总结： 1.Vector有四个不同的构造方法。无参构造方法的容量为默认值10，仅包含容量的构造方法则将容量增长量（从源码中可以看出容量增长量的作用，第二点也会对容量增长量详细说）明置为0。 2.注意扩充容量的方法ensureCapacityHelper。 与ArrayList相同，Vector在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。当容量不足以容纳当前的元素个数时，就先看构造方法中传入的容量增长量参数CapacityIncrement是否为0，如果不为0，就设置新的容量为就容量加上容量增长量，如果为0，就设置新的容量为旧的容量的2倍，如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），而后同样用Arrays.copyof()方法将元素拷贝到新的数组。 3.很多方法都加入了synchronized同步语句，来保证线程安全。 4.同样在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，Vector中也允许元素为null。 5.其他很多地方都与ArrayList实现大同小异，Vector现在已经基本不再使用。","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"HashSet","date":"2019-09-04T12:14:52.000Z","path":"2019/09/04/HashSet/","text":"一、HashSet概述 HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。主要具有以下的特点： 不保证set的迭代顺序，特别是它不保证该顺序恒久不变 有且只允许一个null元素 不允许有重复元素，这是因为HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();** 非同步的。如果多 个线程同时访问一个哈希set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该set的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该set进行意外的不同步访问： 1Set s = Collections.synchronizedSet(new HashSet(...)); HashSet通过iterator()返回的迭代器是fail-fast的 二、基本属性12private transient HashMap&lt;E,Object&gt; map; //map集合，HashSet存放元素的容器private static final Object PRESENT = new Object(); //map，中键对应的value值 三、HashSet源码解析相关HashSet的操作，基本上都是直接调用底层HashMap的相关方法来完成。构造方法​ HashSet提供了四种方式的构造器， 可以构造一个新的空 set，其底层 HashMap实例的默认初始容量是16，加载因子是 0.75， 构造一个包含指定collection中的元素的新set， 构造一个新的空set，其底层HashMap实例具有指定的初始容量和默认的加载因子（0.75）， 以及构造一个新的空set，其底层HashMap实例具有指定的初始容量和指定的加载因子。 12345678910111213141516171819202122232425262728293031323334//默认的无参构造器，构造一个空的HashSet,实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 public HashSet() &#123; map = new HashMap&lt;E, Object&gt;(); &#125; //构造一个包含指定collection中的元素的新set。 //实际底层使用默认的加载因子0.75和足以包含指定collection中所有元素的初始容量来创建一个HashMap。 public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;E, Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); //AbstractCollection.addAll(Collection&lt;? extends E&gt; c) &#125; //以指定的初始容量和加载因子构造一个空的HashSet public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E, Object&gt;(initialCapacity, loadFactor); &#125; //以指定的initialCapacity和默认加载因子0.75构造一个空的HashSet public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E, Object&gt;(initialCapacity); &#125; /** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持 * * @param initialCapacity 初始容量 * @param loadFactor 加载因子 * @param dummy 标记，用于与其他的构造函数区分（可忽略） * @throws IllegalArgumentException 如果初始容量小于零或加载因子为非正数 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E, Object&gt;(initialCapacity, loadFactor); &#125; 通过构造函数，不难发现，HashSet的底层是采用HashMap实现的。Add()方法HashSet提供了add(E e)添加元素的方法，其调用的是底层HashMap中的put(K key, V value)方法，首先判断元素（也就是key）是否存在，如果不存在则插入，如果存在则不插入，这样HashSet中就不存在重复值。 1234//如果此set中尚未包含指定元素，则添加指定元素public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; remove() 与 clear()123456789 //如果指定元素存在于此set中，则将其移除 public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125;//从此set中移除所有元素 public void clear() &#123; map.clear(); &#125; HashSet提供了remove(Object o)删除元素、clear()清除所有元素的方法。 contains()HashSet提供了contains(Object o)查看是否包含指定元素的方法，其底层调用的是HashMap.containsKey(Object key)判断是否包含指定key。 1234//如果此set包含指定元素，则返回 true public boolean contains(Object o) &#123; return map.containsKey(o); &#125; 其他公开的方法 size()、isEmpty()、clone()123456789101112131415161718192021//返回此set中的元素的数量 public int size() &#123; return map.size(); &#125; //如果此set不包含任何元素，则返回 true public boolean isEmpty() &#123; return map.isEmpty(); &#125; //返回此 HashSet实例的浅表副本 @SuppressWarnings(\"unchecked\") public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(e); &#125; &#125; 总结 HashSet的底层通过HashMap实现的。而HashMap在1.7之前使用的是数组+链表实现，在1.8+使用的数组+链表+红黑树实现。其实也可以这样理解，HashSet的底层实现和HashMap使用的是相同的方式，因为Map是无序的，因此HashSet也无法保证顺序。 HashSet的方法，也是借助HashMap的方法来实现的。","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"TreeMap","date":"2019-09-04T07:18:42.000Z","path":"2019/09/04/TreeMap/","text":"概述文章的内容基于JDK1.7进行分析，之所以选用这个版本，是因为1.8的有些类做了改动，增加了阅读的难度，虽然是1.7，但是对于1.8做了重大改动的内容，文章也会进行说明。 TreeMap实现了SotredMap接口，它是有序的集合。而且是一个红黑树结构，每个key-value都作为一个红黑树的节点。如果在调用TreeMap的构造函数时没有指定比较器，则根据key执行自然排序。这点会在接下来的代码中做说明，如果指定了比较器则按照比较器来进行排序。 继承关系123public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125; 1Serializable, Cloneable, Map&lt;K,V&gt;, NavigableMap&lt;K,V&gt;, SortedMap&lt;K,V&gt; 1234private final Comparator&lt;? super K&gt; comparator; //比较器，是自然排序，还是定制排序 ，使用final修饰，表明一旦赋值便不允许改变private transient Entry&lt;K,V&gt; root = null; //红黑树的根节点private transient int size = 0; //TreeMap中存放的键值对的数量private transient int modCount = 0; //修改的次数 由于TreeMap中源码较长，接下来将分段解析部分源码。既然是红黑树存储，肯定要有数据结构（Node）节点的。看一下TreeMap中关于节点的定义部分。 Node节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; //键 V value; //值 Entry&lt;K,V&gt; left = null; //左孩子节点 Entry&lt;K,V&gt; right = null; //右孩子节点 Entry&lt;K,V&gt; parent; //父节点 boolean color = BLACK; //节点的颜色，在红黑树种，只有两种颜色，红色和黑色 //构造方法，用指定的key,value ,parent初始化，color默认为黑色 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; //返回key public K getKey() &#123; return key; &#125; //返回该节点对应的value public V getValue() &#123; return value; &#125; //替换节点的值，并返回旧值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; //重写equals()方法 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; //两个节点的key相等，value相等，这两个节点才相等 return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; //重写hashCode()方法 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); //key和vale hash值得异或运算，相同则为零，不同则为1 return keyHash ^ valueHash; &#125; //重写toString()方法 public String toString() &#123; return key + \"=\" + value; &#125;&#125; 构造方法1234567891011121314151617181920212223242526//构造方法，comparator用键的顺序做比较public TreeMap() &#123; comparator = null;&#125;//构造方法，提供比较器，用指定比较器排序public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; his.comparator = comparator;&#125;//将m中的元素转化daoTreeMap中，按照键的顺序做比较排序public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;//构造方法，指定的参数为SortedMap//采用m的比较器排序public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序. 自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象 定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。等下面分析到比较方法的时候在分析这两种比较有何不同。 对于Map来说，使用的最多的就是put()/get()/remove()等方法，下面依次进行分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; //红黑树的根节点 if (t == null) &#123; //红黑树是否为空 compare(key, key); // type (and possibly null) check //构造根节点，因为根节点没有父节点，传入null值。 root = new Entry&lt;&gt;(key, value, null); size = 1; //size值加1 modCount++; //改变修改的次数 return null; //返回null &#125; int cmp; Entry&lt;K,V&gt; parent; //定义节点 // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; //获取比较器 if (cpr != null) &#123; //如果定义了比较器，采用自定义比较器进行比较 do &#123; parent = t; //将红黑树根节点赋值给parent cmp = cpr.compare(key, t.key); //比较key, 与根节点的大小 if (cmp &lt; 0) //如果key &lt; t.key , 指向左子树 t = t.left; //t = t.left , t == 它的做孩子节点 else if (cmp &gt; 0) t = t.right; //如果key &gt; t.key , 指向它的右孩子节点 else return t.setValue(value); //如果它们相等，替换key的值 &#125; while (t != null); //循环遍历 &#125; else &#123; //自然排序方式，没有指定比较器 if (key == null) throw new NullPointerException(); //抛出异常 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //类型转换 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) // key &lt; t.key t = t.left; //左孩子 else if (cmp &gt; 0) // key &gt; t.key t = t.right; //右孩子 else return t.setValue(value); //t == t.key , 替换value值 &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //创建新节点，并制定父节点 //根据比较结果，决定新节点为父节点的左孩子或者右孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); //新插入节点后重新调整红黑树 size++; modCount++; return null;&#125;//比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125;private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; //插入的节点默认的颜色为红色 x.color = RED; // //情形1： 新节点x 是树的根节点，没有父节点不需要任何操作 //情形2： 新节点x 的父节点颜色是黑色的，也不需要任何操作 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //情形3：新节点x的父节点颜色是红色的 //判断x的节点的父节点位置，是否属于左孩子 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; //获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); //判断是否x节点的父节点的兄弟节点为红色。 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // x节点的父节点设置为黑色 setColor(y, BLACK); // y节点的颜色设置为黑色 setColor(parentOf(parentOf(x)), RED); // x.parent.parent设置为红色 x = parentOf(parentOf(x)); // x == x.parent.parent ,进行遍历。 &#125; else &#123; //x的父节点的兄弟节点是黑色或者缺少的 if (x == rightOf(parentOf(x))) &#123; //判断x节点是否为父节点的右孩子 x = parentOf(x); //x == 父节点 rotateLeft(x); //左旋转操作 &#125; //x节点是其父的左孩子 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); //上面两句将x.parent 和x.parent.parent的颜色做调换 rotateRight(parentOf(parentOf(x))); //进行右旋转 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); //y 是x 节点的祖父节点的左孩子 if (colorOf(y) == RED) &#123; //判断颜色 setColor(parentOf(x), BLACK); //父节点设置为黑色 setColor(y, BLACK); //父节点的兄弟节点设置为黑色 setColor(parentOf(parentOf(x)), RED); //祖父节点设置为红色 x = parentOf(parentOf(x)); //将祖父节点作为新插入的节点，遍历调整 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; //x 是其父亲的左孩子 x = parentOf(x); rotateRight(x); //以父节点为旋转点，进行右旋操作 &#125; setColor(parentOf(x), BLACK); //父节点为设置为黑色 setColor(parentOf(parentOf(x)), RED); //祖父节点设置为红色 rotateLeft(parentOf(parentOf(x))); //以父节点为旋转点，进行左旋操作 &#125; &#125; &#125; root.color = BLACK; //通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色&#125; 红黑树是一个更高效的检索二叉树，有如下特点： 每个节点只能是红色或者黑色 根节点永远是黑色的 所有的叶子的子节点都是空节点，并且都是黑色的 每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点） 从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同） 上面的代码，详细的标注了每条语句的作用，但是我相信，如果你没有一定的功力，即使注释已经很详细了，你也会是一脸懵逼 ，二脸懵逼，全脑懵逼中，下面配合图片来梳理一下代码所表示的含义：当一个默认为红色的节点插入树中，其实对应的是7中可能发生的情况，分别进行叙述： 情形1：新插入的节点时红黑树的根节点，没有父节点，无需任何的操作，直接将颜色设置为黑色就可以了 情形2：新节点的父节点颜色是黑色的，新插入的节点是红色的。也无需任何的操作。因为新节点的插入并没有影响到红黑书的特点 情形3：新节点的父节点（左孩子节点）颜色是红色的，而父节点的兄弟节点颜色也是红色的。那么情况就出现了，此时插入的节点就违反了红黑树的特点4 ，需要对红黑树进行调整。 操作看下图：调整操作如上图，将父节点和父节点的兄弟节点，都修改为红色，然后将祖父节点修改为红色，因为修改了祖父节点的颜色，祖父节点可能会发生颜色的冲突，所以将新插入的节点修改为祖父节点，在进行调整。 情形4：父节点（左孩子节点）的颜色为红色，父节点的兄弟节点的颜色为黑色或者为null，新插入的节点为父节点的右孩子节点。如下图：此时以父节点为旋转点，就新插入的节点进行左旋操作。便变成了情形5对应的情况，将执行情形5的操作 情形5：父节点（左孩子节点）的颜色为红色，父节点的兄弟节点颜色为黑色或者null,新插入节点为父亲的左孩子节点。如下图： 情形6 和情形7的操作与情形4和情形5的操作相同，它们之前的区别是父节点为有孩子节点，再次不再赘述。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); //根据key查找节点，并返回该节点 if (p == null) return null; V oldValue = p.value; //获取key对应的值 deleteEntry(p); //删除节点 return oldValue; //返回key对应的值&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; //根据键寻找节点，有非为两种方式，如果定制了比较器，采用定制排序方式，否则使用自然排序 if (comparator != null) return getEntryUsingComparator(key); //循环遍历树，寻找和key相等的节点 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; //循环遍历树，寻找和key相等的节点 int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;//删除节点private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; //记录修改的次数 size--; //数量减1 //当前节点的两个孩子都不为空 if (p.left != null &amp;&amp; p.right != null) &#123; //寻找继承者，继承者为当前节点的右孩子节点或者右孩子节点的最小左孩子 Entry&lt;K,V&gt; s = successor(p); p.key = s.key; //key - value 的替换 ，并没有替换颜色 p.value = s.value; p = s; //指向继承者 &#125; // p has 2 children // Start fixup at replacement node, if it exists. //开始修复树结构，继承者的左孩子不为空，返回左孩子，否则返回右孩子 //不可能存在左右两个孩子都存在的情况，successor寻找的就是最小节点，它的左孩子节点为null Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent //已经被选为继承者，当前拥有的一切放弃，所以将孩子交给爷爷抚养 replacement.parent = p.parent; //p节点没有父节点，则指向根节点 if (p.parent == null) root = replacement; //如果p为左孩子，如果p为左孩子，则将p.parent.left = p.left else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; //删除p节点到左右分支，和父节点的引用 p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) //恢复颜色分配 fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. //红黑书中父节点为空的只能是根节点。 root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125;private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; //不是根节点，颜色为黑色，调整结构 while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; //判断x是否为左孩子 if (x == leftOf(parentOf(x))) &#123; //x的兄弟节点 Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); //若兄弟节点是红色 if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); //设置兄弟节点变为黑色 setColor(parentOf(x), RED); //父节点设置为红色 rotateLeft(parentOf(x)); //左旋父节点 sib = rightOf(parentOf(x)); //重新设置x的兄弟节点 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); //兄弟节点的两个孩子都是黑色的重新设置兄弟节点的颜色，修改为红色 x = parentOf(x); //将x定位到父节点 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; //兄弟节点的右孩子是黑色的，左孩子是红色的 setColor(leftOf(sib), BLACK); //设置左孩子节点为黑色 setColor(sib, RED); //兄弟节点为红色 rotateRight(sib); //右旋 sib = rightOf(parentOf(x)); //右旋后重新设置兄弟节点 &#125; setColor(sib, colorOf(parentOf(x))); //兄弟节点颜色设置和父节点的颜色相同 setColor(parentOf(x), BLACK); //父节点设置为黑色 setColor(rightOf(sib), BLACK); //将兄弟节点的有孩子设置为黑色 rotateLeft(parentOf(x)); //左旋 x = root; //设置x为根节点 &#125; &#125; else &#123; // symmetric //x为父节点的右节点，参考上面的操作 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp;colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK);&#125; 删除红黑树的操作比插入操作要稍微麻烦一点，分为两步： 以排序二叉树的方法删除指定节点。删除的节点存在三种情况： 被删除节点，没有左右孩子节点，直接删除即可 被删除节点，有一个孩子节点，那么让它的孩子节点指向它的父节点即可 本删除的节点，有两个非空的孩子节点，那么需要找到该节点的前驱或者后继节点，更换元素值，在将前驱或者后继节点删除（任意一个节点的前驱或者后继都必定至多有一个非空的子节点，可以按照前面的两种情形进行操作） 进行颜色的调换和树的旋转，满足红黑树的特征 下面来分情形讨论一下可能发生的情况： 情形1：被删除的节点为根节点或者颜色为空色，此时删除该节点不影响红黑树的特点。无需操作 情形2：被删除节点为黑色，兄弟节点为红色，如下图：若删除上图中的x节点，将缺少一个黑节点，与红黑树的性质冲突，所以修改sib颜色为黑色，设置p节点为红色，并进行左旋操作。在进行后续的处理。 情形3：被删除节点为黑色，x节点的兄弟节点的子节点都是黑色，如下图：x节点是黑色的，兄弟节点（黑色的）的子节点也是黑色的，p节点的颜色无法确定，有可能是红色的，也有可能是黑色的。如果是红色的直接设置为黑色即可，如果为黑色的，则需要将x定位的p节点，在进行处理。 情形4：被删除节点为黑色，x的兄弟节点的右自子节点为黑色。如下图：情形4的调整为了转变成情形5的情况，来进行处理。 情形5：被删除节点为黑色，x的兄弟节点右子节点为红色。如下图：sib的左子节点的颜色不确定，可能是红色也可能是黑色，但是对它并没有什么影响，因为变换前后它的上层分支的黑色节点数并没有改变。 上面的情形只是针对删除的节点是左孩子的情况，进行的分析，被删除的节点也可能是右分支。情况完全相同只不过左右顺序发生了颠倒，不再进行复述。 至此TreeMap中实现的最重要已经说完了。 下面简单说一下一些方法的作用 firstEntry() 返回Map中最小的key higherEntry(Object key ) 返回该Map中位于key后一位的key-value lowerEntry(Object key ) 返回该Map中唯一key前一位的key-value tailMap(Object key , boolean inclusive) 返回该Map的子Map 关于红黑树的节点插入操作，首先是改变新节点，新节点的父节点，祖父节点，和新节点的颜色，能在当前分支通过节点的旋转改变的，则通过此种操作，来满足红黑书的特点。 如果当前相关节点的旋转解决不了红黑树的冲突，则通过将红色的节点移动到根节点解决，最后在将根节点设置为黑色","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"ComcurrentHashMap(JDK8)","date":"2019-09-04T07:16:10.000Z","path":"2019/09/04/ComcurrentHashMap2/","text":"概述本文主要介绍ConcurrentHashMap在JDK8中的源码实现和原理，与之前介绍的Java集合-ConcurrentHashMap工作原理和实现JDK7有较大区别。在JDK8中，开发人员几乎把ConcurrentHashMap的源码重写了一遍，源码由之前的2000多行增加到了6300行左右，因此实现也就复杂很多。在学习之前，最好先了解下如下知识： 1、ReentrantLock的实现和原理。2、Synchronized的实现和原理。3、硬件对并发支持的CAS操作及JVM中Unsafe对CAS的实现。4、JDK1.7中关于ConcurrentHashMap的实现原理。5、volatile的实现原理。6、二叉树，平衡二叉树以及红黑树的知识。 数据结构JDK 1.8中ConcurrentHashMap抛弃了分段锁技术的实现，直接采用CAS + synchronized保证并发更新的安全性，底层采用数组+链表+红黑树的存储结构。其包含核心静态内部类 Node。首先通过一张图来看下数据结构吧： 说明：数据结构采用数组 + 链表 + 红黑树的方式实现。当链表中(bucket)的节点个数超过8个时，会转换成红黑树的数据结构存储，这样设计的目的是为了减少同一个链表冲突过大情况下的读取效率。 Java8中主要做了如下优化: 将Segment抛弃掉了，直接采用Node（继承自Map.Entry）作为table元素。 修改时，不再采用ReentrantLock加锁，直接用内置synchronized加锁，java8的内置锁比之前版本优化了很多，相较ReentrantLock，性能不并差。 size方法优化，增加了CounterCell内部类，用于并行计算每个bucket的元素数量。 内部类和继承关系Java8中ConcurrentHashMap增加了很多内部类来支持一些操作和优化性能。下面介绍几个核心的内部类。 Node类：存放元素的key,value,hash值,next下一个链表节点的引用。用于bucket为链表时。 TreeBin：内部属性有root，first节点，以及root节点的锁状态变量lockState，这是一个读写锁的状态。用于存放红黑树的root节点，并用读写锁lockState控制在写操作即将要调整树结构前，先让读线程完成读操作。从链表结构调整为红黑树时，table中索引下标存储的即为TreeBin TreeNode：红黑树的节点，存放了父节点，左子节点，右子节点的引用，以及红黑节点标识。 ForwardingNode：在调用transfer()方法期间，插入bucket头部的节点，主要用来标识在扩容时元素的移动状态，即是否在扩容时还有并发的插入节点，并保证该节点也能够移动到扩容后的表中。 ReservationNode：占位节点，不存储任何信息，无实际用处，仅用于computeIfAbsent和compute方法中。 重要属性介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123; // table最大容量，为2的幂次方 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认table初始容量大小 private static final int DEFAULT_CAPACITY = 16; // 默认支持并发更新的线程数量 private static final int DEFAULT_CONCURRENCY_LEVEL = 16; // table的负载因子 private static final float LOAD_FACTOR = 0.75f; // 链表转换为红黑树的节点数阈值，超过这个值，链表转换为红黑树 static final int TREEIFY_THRESHOLD = 8; // 在扩容期间，由红黑树转换为链表的阈值，小于这个值，resize期间红黑树就会转为链表 static final int UNTREEIFY_THRESHOLD = 6; // 转为红黑树时，红黑树中节点的最小个数 static final int MIN_TREEIFY_CAPACITY = 64; // 扩容时，并发转移节点(transfer方法)时，每次转移的最小节点数 private static final int MIN_TRANSFER_STRIDE = 16; // 以下常量定义了特定节点类hash字段的值 static final int MOVED = -1; // ForwardingNode类对象的hash值 static final int TREEBIN = -2; // TreeBin类对象的hash值 static final int RESERVED = -3; // ReservationNode类对象的hash值 static final int HASH_BITS = 0x7fffffff; // 普通Node节点的hash初始值 // table数组 transient volatile Node&lt;K,V&gt;[] table; // 扩容时，下一个容量大小的talbe，用于将原table元素移动到这个table中 private transient volatile Node&lt;K,V&gt;[] nextTable; // 基础计数器 private transient volatile long baseCount; // table初始容量大小以及扩容容量大小的参数，也用于标识table的状态 // 其有几个值来代表也用来代表table的状态: // -1 ：标识table正在初始化 // - N : 标识table正在进行扩容，并且有N - 1个线程一起在进行扩容 // 正数：初始table的大小，如果值大于初始容量大小，则表示扩容后的table大小。 private transient volatile int sizeCtl; // 扩容时，下一个节点转移的bucket索引下标 private transient volatile int transferIndex; // 一种自旋锁，是专为防止多处理器并发而引入的一种锁，用于创建CounterCells时使用， // 主要用于size方法计数时，有并发线程插入而计算修改的节点数量， // 这个数量会与baseCount计数器汇总后得出size的结果。 private transient volatile int cellsBusy; // 主要用于size方法计数时，有并发线程插入而计算修改的节点数量， // 这个数量会与baseCount计数器汇总后得出size的结果。 private transient volatile CounterCell[] counterCells; // 其他省略&#125; 以上的一些属性，在初始化，扩容，链表转红黑树等方法中用到。 属性众多，sizeCtl，counterCells都比较重要。sizeCtl：即作为table初始化状态的标识，也用作扩容时的线程数标识，还用作初始和扩容后table的容量标识，用处很多，不同状态值代表的含义如下： 1、 -1：标识table正在初始化2、- N：标识table正在进行扩容，并且有N - 1个线程一起在进行扩容3、正数：初始化table的大小，如果值大于初始容量大小，则表示扩容后的table大小。 counterCells在put size等方法中再介绍。 核心方法源码分析put方法，调用的是putVal方法 123public V put(K key, V value) &#123; return putVal(key, value, false);&#125; 再看下putVal方法的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode());// 计算key的hash值 int binCount = 0;// 表示table中索引下标代表的链表或红黑树中的节点数量 // 采用自旋方式，等待table第一次put初始化完成，或等待锁或等待扩容成功然后再插入 for (Node&lt;K,V&gt;[] tab = table;;) &#123; // f节点标识table中的索引节点，可能是链表的head，也可能是红黑树的head // n:table的长度，i:插入元素在table的索引下标，fh : head节点的hash值 Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0)// 第一次插入元素，先执行初始化 tab = initTable(); // 定位到的索引下标节点(head)为null，表示第一次在此索引插入， // 不加锁直接插入在head之后，在casTabAt中采用Unsafe的CAS操作，保证线程安全 else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // head节点为ForwadingNode类型节点，表示table正在扩容，链表或红黑树也加入到帮助扩容操作中 else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123;// 索引下标存在元素，且为普通Node节点，给head加锁后执行插入或更新 V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123;// 为普通链表节点，还记得之前定义的几种常量Hash值吗？ binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; // 插入新元素，每次插在单向链表的末尾，这点与Java7中不同（插在首部） if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123;// head为树节点，按树的方式插入节点 Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // 链表节点树超过阈值8，将链表转换为红黑树结构 if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; // 如果是插入新元素，则将链表或红黑树最新的节点数量加入到CounterCells中 addCount(1L, binCount); return null;&#125; 初看起来，putVal方法很复杂，但笔者在代码上增加了比较详细的注释，看起来就方便的多啦，总体流程和步骤如下： 1、采用自旋的方式，保证首次put时，当前线程或其他并发put的线程等待table初始化完成后再次重试插入。2、采用自旋的方式，检查当前插入的元素在table中索引下标是否正在执行扩容，如果正在扩容，则帮助进行扩容，完成后，重试插入到新的table中。3、插入的table索引下标不为空，则对链表或红黑树的head节点加synchronized锁，再插入或更新。访问入口是Head节点，其他线程访问head，在链表或红黑树插入或修改时必须等待synchronized释放。4、插入后，如果发现链表节点数大于等于阈值8，调用treeifyBin方法，将链表转换为红黑树结构，提高读写性能。treeifyBin方法内部也同样采用synchronized方式保证线程安全性。5、插入元素后，会将索引代表的链表或红黑树的最新节点数量更新到baseCount或CounterCell中。 putVal方法用到了很多字方法，如下，我们一一来分析：（1）spread：计算元素的hash值（2）initTable：初始化table，在首次执行put，computeIfAbsent，computIfPresent,compute,merge方法时调用。（3）tabAt：用于定位key在table中的索引节点(head节点)。（4）casTabAt：采用Unsafe的compareAndSwapObject方法，用CAS的方式更新或替换节点。（5）helpTransfer：帮忙扩容。（6）treeifyBin：链表转红黑树，实现源码就不分析了，感兴趣的同学可以自行研究下。（7）addCount：链表或红黑树节点最新数量添加到CounterCell中。 spread方法计算key的hash值，将key的hashCode的高16位也加入到计算中，避免平凡冲突。如果仅用key的hashCode作为hash值，那么2,4之类的整形key值，只有低4位，那么很容易发生冲突。 123static final int spread(int h) &#123; return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; initTable方法12345678910111213141516171819202122232425private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123;// while自旋 // sizeCtl小于0，表示table正在被其他线程执行初始化， // 放弃初始化竞争，自旋等待初始化完成 // 还记得前面介绍的sizeCtl的含义吗？ if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings(\"unchecked\") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; 初始化比较简单，步骤如下： 1、自旋检查table是否完成初始化。2、若发现sizeCtl值为负数，则放弃初始化的竞争，让其他正在初始化的线程完成初始化。3、如果没有其他线程初始化，则用Unsafe.compareAndSwapInt更新sizeCtl的值为-1，表示table开始被当前线程执行初始化，其他线程禁止执行。4、初始化：table设置为默认容量大小（元素并未初始化，只是划定了大小），sizeCtl设为下次扩容table的size大小。5、初始化完成。 整个初始化，用到了sizeCtl和Unsafe.compareAndSwapInt来保证初始化的线程安全性。有没有觉得Doug Lea大神对并发编程的出神入化。 tabAt和casTabAt方法这两个方法比较简单，都是利用Unsafe的CAS方法保证读取和替换的原子性，保证线程安全。 12345678static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125; 疑问解答：为什么table本身明明用了volatile修饰，不直接用table[i]的方式取节点，而非要用Unsafe.getObjectVolatile方法的CAS操作取节点。答：虽然table本身是volatile类型，但仅仅是指table数组引用本身，而数组中每个元素并不是volatile类型，Unsafe.getObjectVolatile保证了每次从table中读取某个位置链表引用的时候都是从主内存中读取的，如果不用该方法，有可能读的是缓存中已有的该位置的旧数据。 helpTransfer方法这是一个辅助扩容的方法，能够支持扩容时直接加入到扩容中，其中真正扩容的核心方法是transfer，扩容前，会更新SIZECTL的值，表示并发扩容的线程数，transfer扩容方法太过复杂，本文不做介绍，将在下篇文章中介绍。 1234567891011121314151617181920212223final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125;static final int resizeStamp(int n) &#123; return Integer.numberOfLeadingZeros(n) | (1 &lt;&lt; (RESIZE_STAMP_BITS - 1));&#125; addCount方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Adds to count, and if table is too small and not already * resizing, initiates transfer. If already resizing, helps * perform transfer if work is available. Rechecks occupancy * after a transfer to see if another resize is already needed * because resizings are lagging additions. * * @param x the count to add * @param check if &lt;0, don't check resize, if &lt;= 1 only check if uncontended */private final void addCount(long x, int check) &#123; // check,即链表或红黑树的节点数，&lt;0不检查是否正在扩容， // &lt;=1仅检查是否存在竞争，没有竞争则直接返回 CounterCell[] as; long b, s; // 如果首次执行addCount，并且尝试用CAS对baseCount计数失败，表示有竞争，则执行如下操作。 // 或者非首次addCount，也执行如下的操作 if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125;&#125;// sumCount方法final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; addCount方法做了如下操作： 1、判断是否首次执行addCount，并判断是否存在竞争关系，如果CAS成功，数量就成功汇总到baseCount中，如果CAS操作失败，则表示有竞争，有其他线程并发插入，则修改的数量会被记录到CounterCell中。2、BaseCount和CounterCell相加就表示正常无并发下的节点数量和并发插入下的节点数量，table索引下标所代表的链表或红黑树节点的数量就能达到精确计算的效果。3、在addCount时，还会去检查sizeCtl是否为-N，以确定table是否正在扩容，如果正在扩容，则加入到扩容的操作中。 addCount方法所统计的数值baseCount和counterCells将会被用到size方法中，用于精确计算并发读写情况下table中元素的数量。这种设计多么巧妙，不愧为Doug Lea大神的设计，因此这种设计思路也可以在实际的工作应用中多思考思考，作为很多并发统计问题的解决做设计参考。 size方法123456789101112131415161718public int size() &#123; long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);&#125;// sumCount方法final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; size方法最终执行的是sumCount方法，在sumCount方法中，其实就是将baseCount的数值与CounterCell表中并发情况下插入的节点数量进行汇总累加得到。这个结果也把并发的情况也考虑进去了。看这个方法之前最好先看addCount方法。 get方法get方法步骤：1、计算key的hash值，并定位table索引2、若table索引下元素(head节点)为普通链表，则按链表的形式迭代遍历。3、若table索引下元素为红黑树TreeBin节点，则按红黑树的方式查找(find方法)。 1234567891011121314151617181920public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123;// 普通链表 if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; // hash值小于-1,即为红黑树，还记得之前定义的TreeBin节点的hash值吗 else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123;// 匹配下一个链表元素 if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; 红黑树的查找方法源码如下：步骤如下：1、检查lockState是否为写锁，如果是，则表示有并发写入线程在写入，则按正常的链表方式遍历并查找。2、如果没有写锁，仅加读锁，然后按红黑树的方式查找(TreeBin.findTreeNode方法)。 1234567891011121314151617181920212223242526final Node&lt;K,V&gt; find(int h, Object k) &#123; if (k != null) &#123; for (Node&lt;K,V&gt; e = first; e != null; ) &#123; int s; K ek; if (((s = lockState) &amp; (WAITER|WRITER)) != 0) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek)))) return e; e = e.next; &#125; else if (U.compareAndSwapInt(this, LOCKSTATE, s, s + READER)) &#123; TreeNode&lt;K,V&gt; r, p; try &#123; p = ((r = root) == null ? null : r.findTreeNode(h, k, null)); &#125; finally &#123; Thread w; if (U.getAndAddInt(this, LOCKSTATE, -READER) == (READER|WAITER) &amp;&amp; (w = waiter) != null) LockSupport.unpark(w); &#125; return p; &#125; &#125; &#125; return null;&#125; 疑问解答：前文不是说了，链表元素超过8个时，会被转成红黑树的结构吗？为什么在树节点遍历方法中，第一点仍然采用链表的方式遍历？回答：还记得TreeBin和TreeNode节点和Node节点的继承关系吗？Node本身可以链成一个链表，而TreeBin和TreeNode也继承自Node节点，也自然继承了next属性，同样拥有链表的性质，其实真正在存储时，红黑树仍然是以链表形式存储的，只是逻辑上TreeBin和TreeNode多了支持红黑树的root，first, parent，left，right，red属性，在附加的属性上进行逻辑上的引用和关联，也就构造成了一颗树。这一点有点像LinkedHashMap，里面的节点又是在Table中，各个table中的元素又通过before和after引用进行双向链接，达到各个节点之间在逻辑上互链起来的效果。 红黑树的查找遍历如下，其实就是二叉树查找，红黑树是按hash值的大小来构造左子节点和右子节点的，比父节点hash值小放在左边，大则放在右边的： 12345678910111213141516171819202122232425262728final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) &#123; if (k != null) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; q; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.findTreeNode(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); &#125; return null;&#125;","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"ComcurrentHashMap(JDK1.7)","date":"2019-09-04T07:15:57.000Z","path":"2019/09/04/ComcurrentHashMap/","text":"1、概述本文学习知识点 ConcurrentHashMap与HashMap的区别。 数据存储结构。 如何提高并发读写性能。 put和get方法源码实现分析。 size方法如何实现。 2、与HashMap的区别 ConcurrentHashMap和HashMap都是Map的实现，提供key，value的读写。 都继承自AbstractMap类，但实现的接口不同，如下图： ConcurrentHashMap是线程安全的，HashMap非线程安全。 两者采用的数据结构不同。ConcurrentHashMap采用segement+entry数组的方式，HashMap采用Entry数组的方式 3、数据结构如下图描述了ConcurrentHashMap的存储结构，一目了然： 根据这个结构图，我们再看看源码中的声明： 12345678910111213public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements ConcurrentMap&lt;K, V&gt;, Serializable &#123; // 默认segment 段的个数 static final int DEFAULT_INITIAL_CAPACITY = 16; // 默认的更新map的并发级别，即默认最多允许16个线程进行并发写， // 这个级别与segment的个数一致 static final int DEFAULT_CONCURRENCY_LEVEL = 16; /** * The segments, each of which is a specialized hash table. */ final Segment&lt;K,V&gt;[] segments; // 其他省略&#125; 这里的segments数组中，每个segments其实是一个hash表，即HashEntry数组，如下，采用内部类实现方式： 1234567891011static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; // Hash table，默认初始容量为2，特别注意，这里table用了volatile修饰， // 保证多线程读写时的可见性 transient volatile HashEntry&lt;K,V&gt;[] table; // segment中hashtable的元素数量计数器，用于size方法中，分段计算汇总 transient int count; // 执行更新操作时，获取segment锁的重试次数，多核CPU重试64次，单核CPU重试1次 static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; // 其他省略&#125; Segment类，继承自ReentrantLock，因此每个Segment元素都是一个锁，锁的粒度从Hashtable类的整个表，降低到单个Segment元素，以支持分段锁，提供更高的并发读写能力，再来看下segments及其内部HashEntry数组怎么初始化，以及初始化容量大小，构造方法如下： 1234567891011121314151617181920212223242526272829303132333435public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1;// segments数组的大小 // 根据并发级别算出segments的大小以及2的指数 while (ssize &lt; concurrencyLevel) &#123; ++sshift; ssize &lt;&lt;= 1; &#125; this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY;// segment内部HashEntry的默认容量，为2 while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0]，即创建segments数组， // 并初始化segments[0]元素的HashEntry数组 Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; // UNSAFE为sun.misc.Unsafe对象，使用CAS操作， // 将segments[0]的元素替换为已经初始化的s0，保证原子性。 // Unsafe类采用C++语言实现，底层实现CPU的CAS指令操作，保证原子性。 UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; &#125; 从构造方法可以看出，ConcurrentHashMap初始化时，先根据并发级别数，计算出Segment数组的大小ssize和每个Segment中HashEntry数组的大小cap，并初始化Segment数组的第一个元素；Segment数组的大小为2的幂次方，默认为16，每个Segment内部HashEntry数组大小也是2的幂次方，最小值为2，也是默认的初始大小。 put方法实现12345678910111213141516171819202122232425262728293031323334public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); // 根据hash值、segmentShift,segmentMask(段的长度)计算定位到段的索引下标 int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; // (j &lt;&lt; SSHIFT) + SBASE)这段代码也是为了定位段下标。 // 如果通过Unsafe类的CAS读取段下标元素，元素没有初始化， // 则调用ensureSegment进行初始化 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);&#125;private int hash(Object k) &#123; int h = hashSeed; if ((0 != h) &amp;&amp; (k instanceof String)) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // Spread bits to regularize both segment and index locations, // using variant of single-word Wang/Jenkins hash. h += (h &lt;&lt; 15) ^ 0xffffcd7d; h ^= (h &gt;&gt;&gt; 10); h += (h &lt;&lt; 3); h ^= (h &gt;&gt;&gt; 6); h += (h &lt;&lt; 2) + (h &lt;&lt; 14); return h ^ (h &gt;&gt;&gt; 16);&#125; put过程：1.通过key的hashCode值再计算hash值。2.通过hash值找到segments数组的下标。3.检查下标segment是否已经初始化，如果没有初始化，则调用ensureSegment进行初始化，内部用了CAS操作进行替换，达到初始化效果。初始化的过程进行了双重检查，UNSAFE.getObjectVolatile，通过这个方法执行了两次，以检查segment是否已经初始化，以及用UNSAFE.compareAndSwapObject进行CAS替换，CAS的替换有失败的可能，因此源码中还加了自旋重试的操作，保证最终CAS操作的成功。ensureSegment的实现源码就不贴出来了，读者自行看下。4.再调用segment类的put方法，将元素放入HashEntry数组中。Segment类的put方法是操作的核心，内部回有加锁等机制。源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; // 调用父类ReentrantLock的tryLock()方法尝试锁住segment， // 获取锁失败，则调用scanAndLockForPut方法自旋重试获取锁 HashEntry&lt;K,V&gt; node = tryLock()?null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 当有线程A和线程B在相同segment对象上put对象时，执行过程如下： 线程A执行tryLock()方法获取锁。 线程B获取锁失败，则执行scanAndLockForPut()方法，在scanAndLockForPut方法中，会通过重复执行tryLock()方法尝试获取锁，在多处理器环境下，重复次数为64，单处理器重复次数为1，当执行tryLock()方法的次数超过上限时，则执行lock()方法挂起线程B；这样设计目的是为了让线程切换和自旋消耗的CPU的时间达到平衡，不至于白白浪费CPU，也不会过于平凡切换线程导致更多的CPU浪费。 获得锁之后，根据hash值定位到HashEntry数组的下标，更新或插入元素，在插入过程中，如果HashEntry数组元素个数容量超过负载比例，则进行rehash操作扩容，扩容为原来的两倍rehash请对比HashMap源码自行分析，基本一模一样）； 在插入后，还会更新segment的count计数器，用于size方法中计算map元素个数时不用对每个segment内部HashEntry遍历重新计算，提高性能。 当线程A执行完插入操作后，会通过unlock()方法释放锁，接着唤醒线程B继续执行； get方法get方法比较简单，值得注意的是，get方法不加锁，并用Unsafe.getObjectVolatile方法读取元素，这个方法保证读取对象永远是最新的 1234567891011121314151617public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; size方法实现12345678910111213141516171819202122232425262728293031323334353637383940414243public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try &#123; for (;;) &#123; // 超过重复计算的次数，采用全部加锁后计算 if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; // 汇总每个segment的count计数器 for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; // 判断连续两次计算结果是否相等 if (sum == last) break; last = sum; &#125; &#125; finally &#123; // 释放所有segment上的锁 if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; 由于ConcurrentHashMap支持并发读写，所以在准确计算元素时存在一定的难度，思路如下： 1、重复汇总计算segments元素个数，即将每个segment的计数器count累加汇总。2、如果连续两次计算的sum值相同，则结束计算，认为并发过程中计算的值正确，并返回。3、如果重复三次，计算的结果都不相同，则强制锁住全部segment后，重新计算值。 虽然采用重复计算和最后加锁的方式再次计算，但size方法仍不能保证结果的准确性，例如，两次计算结果相等，在返回之前，又有新的线程插入新值，则此时的结果就是不准确的。所以，在并发读写环境下，size方法进行精确计算的意义并不大，只能作为一个大概的计算结果，因此也决定了在使用size方法时，要评估清楚自己的需求是什么，是精确计算，还是粗略计算。","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"LinkedHashMap","date":"2019-09-04T06:08:11.000Z","path":"2019/09/04/LinkedHashMap/","text":"1.概述​ LinkedHashMap 继承自 HashMap，在 HashMap 基础上，通过维护一条双向链表，解决了 HashMap 不能随时保持遍历顺序和插入顺序一致的问题。除此之外，LinkedHashMap 对访问顺序也提供了相关支持。在一些场景下，该特性很有用，比如缓存。在实现上，LinkedHashMap 很多方法直接继承自 HashMap，仅为维护双向链表覆写了部分方法。 四个关注点在LinkedHashMap上的答案 关 注 点 结 论 LinkedHashMap是否允许键值对为空 Key和Value都允许空 LinkedHashMap是否允许重复数据 Key重复会覆盖、Value允许重复 LinkedHashMap是否有序 有序 LinkedHashMap是否线程安全 非线程安全 2.原理LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构。该结构由数组和链表或红黑树组成，结构示意图大致如下： LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。其结构可能如下图： 上图中，淡蓝色的箭头表示前驱引用，红色箭头表示后继引用。每当有新键值对节点插入，新节点最终会接在 tail 引用指向的节点后面。而 tail 引用则会移动到新的节点上，这样一个双向链表就建立起来了。 上面的结构并不是很难理解，虽然引入了红黑树，导致结构看起来略为复杂了一些。但大家完全可以忽略红黑树，而只关注链表结构本身。好了，接下来进入细节分析吧。 3.类成员Entry 类Entry是LinkedHashMap静态内部类，继承了HashMap.Node&lt;K,V&gt;类，在Node类的基础上增加了before、 after节点用来构成双向循环链表。 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125; head &amp; tailhead和tail节点分别记录分别记录着双向循环链表头结点和尾节点。 123transient LinkedHashMap.Entry&lt;K,V&gt; head;transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrderaccessOrder 用来区分对LinkedHashMap中元素顺序。accessOrder为false时（默认为false），按照插入顺序，accessOrder为true时，按照访问顺序。 1final boolean accessOrder; 就是这个accessOrder，它表示： （1）false，所有的Entry按照插入的顺序排列 （2）true，所有的Entry按照访问的顺序排列 第二点的意思就是，如果有1 2 3这3个Entry，那么访问了1，就把1移到尾部去，即2 3 1。每次访问都把访问的那个数据移到双向队列的尾部去，那么每次要淘汰数据的时候，双向队列最头的那个数据不就是最不常访问的那个数据了吗？换句话说，双向链表最头的那个数据就是要淘汰的数据。 “访问”，这个词有两层意思： 1、根据Key拿到Value，也就是get方法 2、修改Key对应的Value，也就是put方法 构造函数LinkedHashMap提供了5种构造函数。 实际上LinkedHashMap的构造函数时调用父类HashMap的构造函数实现的。前四种accessOrder均为false，也就是表明默认按照插入顺序。第五种构造函数可以指定accessOrder的值。 123456789101112131415161718192021222324252627282930public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; put(K key, V value) 方法LinkedHashMap的put方法并没有重写父类HashMap的put方法。而是直接用HashMap的put方法 而是重写了其中的newNode、newTreeNode、afterNodeAccess和afterNodeInsertion方法。 123456Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;&gt;(hash, key, value, e); linkNodeLast(p); return p;&#125; LinkedHashMap重写了newTreeNode和newTreeNode方法。这两个方法在创建新节点的时候，都调用了linkNodeLast方法。 尾插法 12345678910private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; linkNodeLast方法中将给定的节点，将节点添加到双向链表的尾部。 afterNodeAccess 方法LinkedHashMap重写了afterNodeAccess方法，在put方法中，当遇到了put的key相同的时候，更新节点的同时，调用afterNodeAccess方法，如果accessOrder为true的时候，将会把节点添加至链表尾部。 当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; afterNodeInsertion 方法​ 在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。 evict 只有在构建 Map 的时候才为 false，在这里为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry方法在LinkedHashMap直接return false。如果有需要，我们可以选择重写removeEldestEntry方法，来定义老节点first在put新数据时的删除机制。 removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; LRU缓存​ 以下是使用 LinkedHashMap 实现的一个 LRU 缓存： 设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。即删除首部的元素 1234567891011class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125; 123456789public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, \"a\"); cache.put(2, \"b\"); cache.put(3, \"c\"); cache.get(1); cache.put(4, \"d\"); System.out.println(cache.keySet());&#125; 1[3, 1, 4]","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"HashMap","date":"2019-09-03T13:46:05.000Z","path":"2019/09/03/HashMap/","text":"HashMap 简介HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。 底层数据结构分析JDK1.8之前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 JDK 1.8 HashMap 的 hash 方法源码: JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 对比一下 JDK1.7的 HashMap 的 hash 方法源码. 12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 JDK1.8之后相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 类的属性： 12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 加载因子 final float loadFactor;&#125; loadFactor加载因子 loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。 loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。 threshold 阈值 threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 Node节点类源码: 123456789101112131415161718192021222324252627282930313233343536373839// 继承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; // 重写hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 重写 equals() 方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 树节点类源码: 12345678910111213141516static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 判断颜色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 返回根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; HashMap源码分析构造方法HashMap 中有四个构造方法，它们分别如下： 123456789101112131415161718192021222324252627// 默认构造函数。public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // 0.75 all other fields defaulted &#125; // 包含另一个“Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; putMapEntries方法： 123456789101112131415161718192021222324final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; put方法HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 对putVal方法添加元素的分析如下： ①如果定位到的数组位置没有元素 就直接插入。 ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125; 我们再来对比一下 JDK1.7 put方法的代码 对于put方法的分析如下： ①如果定位到的数组位置没有元素 就直接插入。 ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。 12345678910111213141516171819202122public V put(K key, V value) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 再插入 return null;&#125; get方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; resize方法进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap扩容可以分为三种情况：第一种：使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。 第二种：指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。 第三种：HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。 扩容前后，哈希桶的长度一定会是2的次方。这样在根据key的hash值寻找对应的哈希桶时，可以用位运算替代取余操作，更加高效。 扩容操作时，会new一个新的Node数组作为哈希桶，然后将原哈希表中的所有数据(Node节点)移动到新的哈希桶中，相当于对原哈希表中所有的数据重新做了一个put操作。所以性能消耗很大，可想而知，在哈希表的容量越大时，性能消耗越明显。 扩容时，如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量 如果追加节点后，链表数量》=8，则转化为红黑树 与HashTable的区别 与之相比HashTable是线程安全的，且不允许key、value是null。 HashTable默认容量是11。、 HashTable是直接使用key的hashCode(key.hashCode())作为hash值，不像HashMap内部使用static final int hash(Object key)扰动函数对key的hashCode进行扰动后作为hash值。 HashTable取哈希桶下标是直接用模运算%.（因为其默认容量也不是2的n次方。所以也无法用位运算替代模运算） 扩容时，新容量是原来的2倍+1。int newCapacity = (oldCapacity &lt;&lt; 1) + 1;Hashtable是Dictionary的子类同时也实现了Map接口，HashMap是Map接口的一个实现类；","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"HashMap(二)","date":"2019-09-03T13:46:05.000Z","path":"2019/09/03/HashMap2/","text":"1. HashMap概述： HashMap是基于哈希表的Map接口的非同步实现 ​ （Hashtable跟HashMap很像，唯一的区别是Hashtalbe中的方法是线程安全的，也就是同步的）。 ​ 此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 四个关注点在HashMap上的答案 关注点 结论 HashMap是否允许空 Key和Value都允许为空 HashMap是否允许重复数据 Key重复会覆盖、Value允许重复 HashMap是否有序 无序，特别说明这个无序指的是遍历HashMap的时候，得到的元素的顺序基本不可能是put的顺序 HashMap是否线程安全 非线程安全 HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。 HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。 HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。 如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。 图中，紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。 ​ 对于 HashMap 及其子类而言，它们采用 Hash 算法来决定集合中元素的存储位置。当系统开始初始化 HashMap 时，系统会创建一个长度为 capacity 的 Entry 数组，这个数组里可以存储元素的位置被称为“桶（bucket）”，每个 bucket 都有其指定索引，系统可以根据其索引快速访问该 bucket 里存储的元素。 无论何时，HashMap 的每个“桶”只存储一个元素（也就是一个 Entry），由于 Entry 对象可以包含一个引用变量（就是 Entry 构造器的的最后一个参数）用于指向下一个 Entry，因此可能出现的情况是：HashMap 的 bucket 中只有一个 Entry，但这个 Entry 指向另一个 Entry ——这就形成了一个 Entry 链。 2：hashMap的存储结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//数组链表static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //存放节点的hash值 final K key; //存放节点的键 V value; //存放节点的值 Node&lt;K,V&gt; next; //用于指向链表的下一个节点 //构造方法 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; //计算节点的hashCode public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //判断两个节点是否相等 键 值都比较 //在Objects.equals方法是 (a == b) || (a != null &amp;&amp; a.equals(b)); public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125;//红黑树 static final class TreeNode&lt;k,v&gt; extends LinkedHashMap.Entry&lt;k,v&gt; &#123; TreeNode&lt;k,v&gt; parent; // 父节点 TreeNode&lt;k,v&gt; left; //左子树 TreeNode&lt;k,v&gt; right;//右子树 TreeNode&lt;k,v&gt; prev; // needed to unlink next upon deletion boolean red; //颜色属性 TreeNode(int hash, K key, V val, Node&lt;k,v&gt; next) &#123; super(hash, key, val, next); &#125; //返回当前节点的根节点 final TreeNode&lt;k,v&gt; root() &#123; for (TreeNode&lt;k,v&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; 。。。相关的操作 &#125; 3：hashMap各种常用语成员变量加载因子 loadFactor（默认0.75）：为什么需要使用加载因子，为什么需要扩容呢？**如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多） 阈值 threshold = (当前容量)capacity * (加载因子) loadFactor​ 当 size 元素的个数 大于 阈值就会进行 扩容操作 resize() 1234567891011121314151617181920212223242526272829303132/** *创建 HashMap 时未指定初始容量情况下的默认容量 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * 最大容量 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * HashMap 默认的装载因子,当 HashMap 中元素数量超过 容量 *装载因子 时，进行 resize() 操作 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 当add一个元素到某个位桶，其链表长度达到8时将链表转换为红黑树 */static final int TREEIFY_THRESHOLD = 8;/** * 当删除桶位的某个元素时，其元素个数小于6个时将红黑树转变为链表 */static final int UNTREEIFY_THRESHOLD = 6;/** * 当需要将解决 hash 冲突的链表转变为红黑树时，需要判断下此时数组容量， * 若是由于数组容量太小（小于 MIN_TREEIFY_CAPACITY ）导致的 hash 冲突太多， * 则不进行链表转变为红黑树操作，转为利用 resize() 函数对 hashMap 扩容 */static final int MIN_TREEIFY_CAPACITY = 64; 123456789101112131415161718/保存Node&lt;K,V&gt;节点的数组transient Node&lt;K,V&gt;[] table;//由 hashMap 中 Node&lt;K,V&gt; 节点构成的 settransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //记录 hashMap 当前存储的元素的数量transient int size;//记录 hashMap 发生结构性变化的次数（注意 value 的覆盖不属于结构性变化）transient int modCount;//threshold的值应等于 Capacity * loadFactor, 初始化是等于Capacity//size 超过这个值时进行 resize()扩容int threshold;//记录 hashMap 装载因子 size/Capacityfinal float loadFactor; 三、HashMap 几种构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445//构造方法１，指定初始容量及装载因子public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;//tableSizeFor(initialCapacity) 方法返回的值是最接近 initialCapacity 的2的幂 static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1;// &gt;&gt;&gt; 代表无符号右移 n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; //构造方法２，仅指定初始容量，装载因子的值采用默认的 0.75public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;/** * 所有参数均采用默认值 长度为16 装载因子是 0.75 */public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;/** * 用另一个Map初始化 */public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125; 四，HashMap的存取机制put方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//指定节点 key,value，向 hashMap 中插入节点public V put(K key, V value) &#123; //注意待插入节点 hash 值的计算，调用了 hash(key) 函数 4 //实际调用 putVal（）进行节点的插入 return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; /*key 的 hash 值的计算是通过hashCode()的高16位异或低16位实现的： (h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的， 这么做可以在数组table的length比较小的时候， 也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销*/ int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;/** * */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /*根据 hash 值确定节点在数组中的插入位置，若此位置没有元素则进行插入， 注意确定插入位置所用的计算方法为 (n - 1) &amp; hash,由于 n 一定是２的幂次， 这个操作相当于 hash % n */ if ((p = tab[i = (n - 1) &amp; hash]) == null) //数组第一个为空 tab[i] = newNode(hash, key, value, null); else &#123; //第一个不为空 Node&lt;K,V&gt; e; K k; //比较原来元素（数组头）与待插入元素的 hash 值和 key 值 有键相同的则替换值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //若原来元素是红黑树节点，调用红黑树的插入方法:putTreeVal else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //证明待插入元素不是链表的头结点，从此节点开始向后寻找合适插入位置 for (int binCount = 0; ; ++binCount) &#123; //如果是找到了最后 则说明冲突了 在链表后面添加元素 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //判断是否要大于8 转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //每次都比较 键 是否相同 是就替换且e不是null 之前赋值了e=p.next了 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果找到了键相同的直接替换 然后return if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //预留给LinkedHashMap的方法 afterNodeAccess(e); return oldValue; &#125; &#125; //如果是null的 说明冲突了 在链表后面加了 ++modCount; //判断是否有扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; /*读懂这个函数要注意理解 hash 冲突发生的几种情况 １、两节点 key 值相同（hash值一定相同），导致冲突 ２、两节点 key 值不同，由于 hash 函数的局限性导致hash 值相同，冲突 ３、两节点 key 值不同，hash 值不同，但 hash 值对数组长度取模后相同，冲突 ​ */ get方法123456789101112131415161718192021222324252627282930313233public V get(Object key) &#123; Node&lt;K,V&gt; e; //实际上是根据输入节点的 hash 值和 key 值利用getNode 方法进行查找 return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;/** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // 检查数组上的节点 第一个 是返回 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first;//不是就判断它的下一个节点 if ((e = first.next) != null) &#123; //如果已经是红黑色了，就交给红黑色查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; //否则就往下遍历下一个节点 继续判断 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 5、扩容HashMap扩容可以分为三种情况： 第一种：使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。 第二种：指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。 第三种：HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍。 resize() 方法中比较重要的是链表和红黑树的 rehash 操作，先来说下 rehash 的实现原理： 我们在扩容的时候，一般是把长度扩为原来2倍，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个算法很巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的槽中了。 具体源码介绍： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; //threshold 阈值 当size大于阈值（当前数组长度*加载因子）的时候进行扩容操作，初始值是size int oldThr = threshold; int newCap, newThr = 0; /* 1、resize（）函数在size &gt; threshold时被调用。 oldCap大于 0 代表原来的 table 表非空， oldCap 为原表的大小， oldThr（threshold） 为 oldCap × load_factor */ if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // 容量加倍，阈值加倍 &#125; /* 2、resize（）函数在table为空被调用。 oldCap 小于等于 0 且 oldThr 大于0，代表用户创建了一个 HashMap，但是使用的构造函数为 HashMap(int initialCapacity, float loadFactor) 或 HashMap(int initialCapacity) 或 HashMap(Map&lt;? extends K, ? extends V&gt; m)，导致 oldTab 为 null，oldCap 为0， oldThr 为用户指定的 HashMap的初始容量。 */ else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; /* 3、resize（）函数在table为空被调用。 oldCap 小于等于 0 且 oldThr 等于0，用户调用 HashMap()构造函数创建的 HashMap，所有值均采用默认值， oldTab（Table）表为空，oldCap为0，oldThr等于0， */ else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //把 oldTab 中的节点 reHash 到 newTab 中去 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //若节点是单个节点，直接在 newTab 中进行重定位 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //若节点是 TreeNode 节点，要进行 红黑树的 rehash 操作 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //若是链表，进行链表的 rehash 操作 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //根据算法 e.hash &amp; oldCap 判断节点位置 rehash 后是否发生改变 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; // rehash 后节点新的位置一定为原来基础上加上 oldCap newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125;","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"LinkedList","date":"2019-09-03T13:00:42.000Z","path":"2019/09/03/LinkedList/","text":"1、简介123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable ​ LinkedList继承了AbstractSequentialList，它可以被当作堆栈、队列或双端队列进行操作。 实现List接口规定了List的操作规范。 实现 Deque 接口代表LinkedList可以当作双端队列使用。 实现Cloneable(标记接口)代表LinkedList是可以拷贝。 实现Serializable(标记接口)代表LinkedList是可以序列化的。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法： 2、源码分析1、LinkedList字段属性12345678910111213141516171819202122232425262728293031323334353637/** * size是双向链表中节点实例的个数，transient关键字表示size不会被序列化 */ transient int size = 0; /** * 链表头节点。 * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * 链表尾节点。 * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; /** * Node内部类 */ private static class Node&lt;E&gt; &#123; //当前节点的值 E item; // 后一个节点 Node&lt;E&gt; next; // 前一个节点 Node&lt;E&gt; prev; // 构造函数元素顺序分别为前一个节点，自己，后一个节点。 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 2、LinkedList的构造方法123456789101112131415161718/** * 无参构造方法. */ public LinkedList() &#123; &#125; /** * 构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回的顺序排列的 * * @param c 包含用于去构造 LinkedList 的元素的 collection * @throws 如果指定的集合为 null 则抛出 NullPointerException */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; // 调用无参构造函数 this(); // 添加集合中所有元素 addAll(c); &#125; 3、其他方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479/** * 头插入，即将节点值为e的节点设置为链表首节点，内部使用 */ private void linkFirst(E e) &#123; //获取当前首节点引用 final Node&lt;E&gt; f = first; //构建一个prev值为null,节点值为e,next值为f的新节点newNode final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //将newNode作为首节点 first = newNode; //如果原首节点为null，即原链表为null，则链表尾节点也设置为newNode //否则，原首节点的prev设置为newNode if (f == null) last = newNode; else f.prev = newNode; //长度加+1 size++; //修改次数+1 modCount++; &#125; /** * 尾插入，即将节点值为e的节点设置为链表的尾节点. */ void linkLast(E e) &#123; // 获取当前尾结点引用 final Node&lt;E&gt; l = last; //构建一个prev值为l,节点值为e,next值为null的新节点newNode final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //将newNode作为尾节点 last = newNode; //如果原尾节点为null，即原链表为null，则链表首节点也设置为newNode //否则，原尾节点的next设置为newNode if (l == null) first = newNode; else l.next = newNode; //长度加+1 size++; //修改次数+1 modCount++; &#125; /** * 在非空节点succ之前插入元素e. */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; //获取succ前一个节点 final Node&lt;E&gt; pred = succ.prev; //构建一个prev值为pred，节点值为e，next值为succ的新节点newNode final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //把newNode作为prev的前一个节点 succ.prev = newNode; //如果succ.prev为null，即如果succ为首节点，则将newNode设置为首节点 //否则原来succ前一个节点的下一个节点为newNode if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; /** * 删除首节点并返回该元素，内部使用 */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; //获取首节点的值 final E element = f.item; //获取首节点的下一个节点 final Node&lt;E&gt; next = f.next; //删除首节点 f.item = null; f.next = null; // help GC //原来首节点的下一个节点设置为首节点 first = next; // 如果原来首结点的后继结点为空，则尾结点设为null // 否则，原来首结点的后继结点的前驱结点设为null if (next == null) last = null; else next.prev = null; //长度 - 1 size--; //修改次数 +1 modCount++; return element; &#125; /** * 删除尾节点并返回该元素，内部使用 */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; //获取为尾节点的值 final E element = l.item; //获取尾节点上一个节点 final Node&lt;E&gt; prev = l.prev; //删除尾节点 l.item = null; l.prev = null; // help GC //原来尾节点上一个节点设置为尾节点 last = prev; // 如果原来尾结点的前驱结点为空，则首结点设为null // 否则，原来尾结点的前驱结点的后继结点设为null if (prev == null) first = null; else prev.next = null; //长度 - 1 size--; //修改次数 +1 modCount++; return element; &#125; /** * 删除指定非空节点并返回该元素 */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; //获取指定节点的值 final E element = x.item; //获取指定节点下一个节点 final Node&lt;E&gt; next = x.next; //获取指定节点前一个节点 final Node&lt;E&gt; prev = x.prev; //如果指定节点前一个节点为null，则首节点为指定节点的下一个节点 //否则指点节点的前节点的下一个节点为指定节点的下一个节点 if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; //如果指定节点下一个节点为null，则尾节点为指点节点的前一个节点。 //否则指点节点的前一个节点为，指点节点的前一个节点 if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; //删除指定节点的值 x.item = null; //长度减1 size--; //修改次数加1 modCount++; return element; &#125; /** * 获list 取首节点存储的值. * * @return 这个列表中的第一个元素 * @throws 如果这个list是空的则抛出 NoSuchElementException */ public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125; /** * 获取list 尾节点存储的值 * * @return 这个列表中的最后一个元素 * @throws 如果这个list是空的则抛出 NoSuchElementException */ public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125; /** * 删除首节点并返回首节点存储的值 * * @return 首结点存储的值 * @throws 如果这个list是空的则抛出 NoSuchElementException */ public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; /** * 删除尾节点并返回尾节点存储的值 * * @return 尾节点存储的值 * @throws 如果这个list是空的则抛出 NoSuchElementException */ public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; /** * 在list的开头插入指定的元素. * * @param e 需要添加的元素 */ public void addFirst(E e) &#123; linkFirst(e); &#125; /** * 在列表的尾部添加指定元素，该方法等价于add() * * @param e 需要添加的元素 */ public void addLast(E e) &#123; linkLast(e); &#125; /** * 判断是否包含指定元素 * * @param o 判断链表是否包含的元素 * @return &#123;@code true&#125; 如果链表包含指定的元素 */ public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; /** * 返回list中的元素数量. * * @return 列表中元素的数量 */ public int size() &#123; return size; &#125; /** * 插入指定元素，返回操作结果,默认添加到末尾作为最后一个元素 * * @param e 要添加到此链表中的元素 * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; // 通过尾插法来插入指定元素 linkLast(e); return true; &#125; /** * 删除指定元素，默认从first节点开始，删除第一次出现的那个元素 * * @param o 要从该列表中删除的元素（如果存在） * @return &#123;@code true&#125; 如果这个列表包含指定的元素 */ public boolean remove(Object o) &#123; //会根据是否为null分开处理。若值不是null，会用到对象的equals()方法 if (o == null) &#123; // 遍历链表，查找到指定元素后删除该结点，返回true for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; /** * 将集合插入到链表尾部，即开始索引位置为size * * @param c 包含要添加到此链表中的元素的集合 * @return &#123;@code true&#125; 如果该链表因添加而改变 * @throws 如果指定的集合是空的则抛出NullPointerException */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; /** * 将集合从指定位置开始插入 * * @param index 在哪个索引处前插入指定集合中的第一个元素 * * @param c 包含要添加到此链表中的元素的集合 * @return &#123;@code true&#125; 如果该链表因添加而改变 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws 如果指定的集合是空的则抛出 NullPointerException */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查该索引是否超过了list里面元素的数量，如果超出了则抛出 IndexOutOfBoundsException checkPositionIndex(index); // 将集合转换为Object数组 Object[] a = c.toArray(); // 获取数组长度 int numNew = a.length; //若没有元素要添加，直接返回false if (numNew == 0) return false; //succ指向当前需要插入节点的位置，pred指向其前一个节点 Node&lt;E&gt; pred, succ; //如果是在末尾开始添加，当前节点后一个节点初始化为null，前一个节点为尾节点 //否则当前位置的节点为指定位置的节点，前一个节点为要添加的节点的前一个节点 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; //遍历数组并添加到列表中 for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; //将元素值e，前继节点pred“封装”为一个新节点newNode Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果原链表为null，则新插入的节点作为链表首节点 //否则前节点会向后指向新加的节点 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果是从最后开始添加的，则最后添加的节点成为尾节点 if (succ == null) &#123; last = pred; &#125; else &#123; //如果不是从最后开始添加的，则最后添加的节点向后指向之前得到的后续第一个节点 pred.next = succ; //当前，后续的第一个节点也应改为向前指向最后一个添加的节点 succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; /** * 删除所有元素 */ public void clear() &#123; //遍历链表，删除所有结点,方便gc回收垃圾 for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; //删除首尾节点 first = last = null; //元素数量置为0 size = 0; modCount++; &#125; // Positional Access Operations /** * 获取指定位置的元素 * * @param index 要返回的元素的索引 * @return 该链表中指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; // 判断指定位置是否合法 checkElementIndex(index); //返回指定位置的值 return node(index).item; &#125; /** * 修改指定位置的元素，返回之前元素 * * @param index 要替换的元素的索引 * @param element 要存储在指定位置的元素 * @return 先前在指定位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; //判断位置是否合法 checkElementIndex(index); //获取指定位置的节点 Node&lt;E&gt; x = node(index); //获取指定位置的值 E oldVal = x.item; //将指定位置的值更新为新值 x.item = element; return oldVal; &#125; /** * 在指定位置前插入指定元素 * * @param index 指定元素将被插入的索引 * @param element 要插入的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; //判断位置是否合法 checkPositionIndex(index); //如果指定位置在尾部，则通过尾部插入法插入元素 //否则通过中间插入法插入元素 if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125; /** * 删除指定位置的元素，返回之前元素 * * @param index 要删除的元素的索引 * @return 之前在该位置的元素 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; //判断位置是否合法 checkElementIndex(index); //删除指定非空节点并返回该元素 return unlink(node(index)); &#125; /** * 判断指定位置是否合法. */ private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size; &#125; /** * 判断迭代器遍历时或插入元素时指定位置是否合法 */ private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size; &#125; /** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this \"outlining\" performs best with both server and client VMs. */ private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+size; &#125; private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; 4、与ArrayList的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"ArrayList","date":"2019-09-03T12:24:44.000Z","path":"2019/09/03/ArrayList/","text":"1、ArrayList类的定义12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList继承AbstractList抽象父类 实现List接口规定了List的操作规范。 实现RandomAccess(标记接口)代表ArrayList是支持快速随机访问。 实现Cloneable(标记接口)代表ArrayList是可以拷贝。 实现Serializable(标记接口)代表ArrayList是可以序列化的。 2、ArrayList字段属性12345678910111213141516171819202122232425262728293031323334/** * 默认初始容量. */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空实例的共享空数组实例(当用户指定该 ArrayList 容量为 0 时， * 返回该空数组). */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认大小空实例的共享空数组实例 * 当用户使用无参构造函数创建ArrayList实例的时候，返回的是该数组。 * 当用户第一次添加元素的时候，该数组将会扩容，变成容量为默认初始容量 * 的一个数组。 * 它与 EMPTY_ELEMENTDATA的区别就是：该数组是不指定容量返回的， * 而后者是在用户指 定容量为 0 时返回。 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * ArrayList的容量是这个数组缓冲区的长度 * 任何空数组（elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA） * 在新增第一个元素的时候将会把容量扩充到DEFAULT_CAPACITY即10 */ transient Object[] elementData; // non-private to simplify nested class access /** * ArrayList的大小（它包含的元素的数量）. * * @serial */ private int size; 3、ArrayList的构造方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * * 用指定的初始容量构造一个空的ArrayList. * * @param initialCapacity ArrayList的初始容量 * @throws 如果指定的初始容量的值为负值则抛出 IllegalArgumentException * */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * 无参构造函数 * * 创建一个 空的 ArrayList，此时其内数组缓冲区 elementData = &#123;&#125;, 长度为 0， * 当元素第一次被添加的时候，扩容到默认容量10。 */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * 构造一个包含指定元素的列表的列表集合，按照集合的顺序返回迭代器 * * @param c 要放入 ArrayList 中的集合，其内元素将会全部添加到新建的 ArrayList 实例中 * @throws 如果指定的集合为null则抛出 NullPointerException */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; ArrayList有3个构造函数，我们可以选择不传参数，或者传入List的大小，或者直接传入一个Collection, 当使用的是无参构造器时，会 用这个 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; 当使用的是有参构造器，n&gt;0 this.elementData 会根据参数new 出来多大的数组 ​ n==0 时用的是 this.elementData = EMPTY_ELEMENTDATA 4、添加add( E e)1234567891011121314151617181920212223242526272829public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true; &#125;private void add(E e, Object[] elementData, int s) &#123; if (s == elementData.length) elementData = grow(); //如果数组满了就需要扩容了 elementData[s] = e; size = s + 1; &#125;//向指定的位置插入 元素 public void add(int index, E element) &#123; rangeCheckForAdd(index); modCount++; final int s; Object[] elementData; //若慢了就扩容 if ((s = size) == (elementData = this.elementData).length) elementData = grow(); // 用数组的复制，来实现后移 System.arraycopy(elementData, index, elementData, index + 1, s - index); elementData[index] = element; size = s + 1; &#125; 5、扩容操作grow()123456789101112131415161718192021222324252627282930313233343536373839private Object[] grow() &#123; return grow(size + 1); &#125;private Object[] grow(int minCapacity) &#123; //Arrays.copyOf() 将elementData中数组的元素，复制到大小为newCapacity(minCapacity)的新数组 //并将 新数组返回 return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity)); &#125;//求扩容到的最小容量private int newCapacity(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 原来的基础 加上 一半 即扩容到1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果新的容量还是小于或等于最小的容量 说明参数是负数 或者是 无参构造器调用的 // 是负数抛出异常， 无参构造器构建的 则第一次 add操作扩容到 默认的大小 10 if (newCapacity - minCapacity &lt;= 0) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) return Math.max(DEFAULT_CAPACITY, minCapacity); if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return minCapacity; &#125; //如果扩容 大于了 Integer.Max_Value了 就用 Integer.Max_Value return (newCapacity - MAX_ARRAY_SIZE &lt;= 0) ? newCapacity : hugeCapacity(minCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 6、添加了 ListIterator 迭代器​ Iterator和ListIterator的区别: ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法 7、与Vector的比较​ Vector 是同步的，每个方法用synchronized锁住的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。 代替方案 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"容器概览","date":"2019-09-03T11:49:44.000Z","path":"2019/09/03/Collection/","text":"1 容器分类 容器分为Collection集合类，和Map键值对类2种 使用最多的就是第三层的容器类，其实在第三层之上还有一层Abstract 抽象类，如果要实现自己的集合类，可以继承Abstract类，而不必实现接口中的所有方法。 Collection 接口 List 接口 (按插入顺序保存，元素可以重复) ArrayList （相当于大小可变的数组，随机访问快，插入移除慢） ​ LinkedList（插入移除快，随机访问慢，也实现了Queue接口） ​ Vector（与ArrayList差不多，是线程安全的，每个方法都用synchronized锁住的） set 接口（不能有重复元素） HashSet（元素无序，查询速度非常快） LinkedHashSet（按插入顺序保存，同时有HashSet的查询速度） TreeSet（按元素升序保存对象，或者根据元素实现的比较器排序） Queue接口（一头进一头出） Map接口 HashMap （查找速度快，内部无规则排序） LinkedHashMap（按插入顺序排序，查找速度快） ​ HashTable（与HashMap差不多，不过是线程安全的，每个方法都是synchronize锁住的） TreeMap（按升序保存对象，或者根据元素实现的比较器排序）","tags":[{"name":"容器","slug":"容器","permalink":"http://cxqiang.gitee.io/blog/tags/容器/"}]},{"title":"Object","date":"2019-09-03T11:08:46.000Z","path":"2019/09/03/Object/","text":"Object是所有类的父类通用方法​ 123456789101112131415161718192021public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException 1、equals() 自反性 1x.equals(x); // true 对称性 1x.equals(y) == y.equals(x); // true 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; 一致性 多次调用equals()方法结果不变 1x.equals(y) == x.equals(y); // true 与null比较为false 1x.equals(null); // false; equals 与 ==的关系 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 即 == 比较的是引用（地址），equals（）比较的是内容 （Object默认实现的也是 ==比较的引用） 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 123456789101112131415161718192021222324public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; 2、hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hashCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; 3、toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125; 一般要重写这个方法，在输出 print 和 字符串的拼接时 会自动调用这个方法 4、Clone()1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 1234public class CloneExample &#123; private int a; private int b;&#125; 123CloneExample e1 = new CloneExample();// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' 重写 clone() 得到以下实现： 123456789public class CloneExample &#123; private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125; 123456CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 1java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 123456789101112131415161718192021222324public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125; 123456789ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 1234567891011121314151617181920212223242526272829public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125; 123456789DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 1234567891011121314151617181920212223242526public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125; 1234CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 5、getClass()方法1public final native Class&lt;?&gt; getClass(); 返回次Object的运行时类类型。 不可重写，要调用的话，一般和getName()联合使用，如getClass().getName(); 6、finalize()1protected void finalize() throws Throwable &#123; &#125; ​ 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 Java允许在类中定义一个名为finalize()的方法。它的工作原理是：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。 关于垃圾回收，有三点需要记住： 1、对象可能不被垃圾回收。只要程序没有濒临存储空间用完的那一刻，对象占用的空间就总也得不到释放。 2、垃圾回收并不等于“析构”。 3、垃圾回收只与内存有关。使用垃圾回收的唯一原因是为了回收程序不再使用的内存。 finalize()的用途： 无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。 不过这种情况一般发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式。 7、wait()方法 以及它的重载的方法1234567891011121314151617181920212223public final void wait() throws InterruptedException &#123; //一直等待直到被唤醒 wait(0L); &#125;//等待多久，如果时间过来久啊自己唤醒public final native void wait(long timeoutMillis) throws InterruptedException;//public final void wait(long timeoutMillis, int nanos) throws InterruptedException &#123; if (timeoutMillis &lt; 0) &#123; throw new IllegalArgumentException(\"timeoutMillis value is negative\"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( \"nanosecond timeout value out of range\"); &#125; if (nanos &gt; 0) &#123; timeoutMillis++; &#125; wait(timeoutMillis); &#125; wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔， 如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 8、**notify()方法​ 该方法唤醒在该对象上等待的某个线程。 9、notifyAll该方法唤醒在该对象上等待的所有线程。 10、构造方法 Object()","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"值传递与引用传递","date":"2019-09-03T08:38:14.000Z","path":"2019/09/03/值传递与引用传递/","text":"为什么说Java中只有值传递？在开始深入讲解之前，有必要纠正一下大家以前的那些错误看法了。如果你有以下想法，那么你有必要好好阅读本文。 错误理解一：值传递和引用传递，区分的条件是传递的内容，如果是个值，就是值传递。如果是个引用，就是引用传递。 错误理解二：Java是引用传递。 错误理解三：传递的参数如果是普通类型，那就是值传递，如果是对象，那就是引用传递。 实参与形参我们都知道，在Java中定义方法的时候是可以定义参数的。比如Java中的main方法： 1public static void main(String[] args) 这里面的args就是参数。参数在程序语言中分为形式参数和实际参数。 形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。 实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。 例： 12345678public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); pt.sout(\"Hello\");//实际参数为 Hello&#125;public void sout(String name) &#123; //形式参数为 name System.out.println(name);&#125; 实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。 值传递与引用传递上面提到了，当我们调用一个有参函数的时候，会把实际参数传递给形式参数。但是，在程序语言中，这个传递过程中传递的两种情况，即值传递和引用传递。我们来看下程序语言中是如何定义和区分值传递和引用传递的。 值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 有了上面的概念，然后大家就可以写代码实践了，来看看Java中到底是值传递还是引用传递 ，于是，最简单的一段代码出来了： 123456789101112public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); int i = 10; pt.pass(i ); System.out.println(\"print in main , i is \" + i);&#125;public void pass(int j) &#123; j = 20; System.out.println(\"print in pass , j is \" + j);&#125; 上面的代码中，我们在pass方法中修改了参数j的值，然后分别在pass方法和main方法中打印参数的值。输出结果如下： 12print in pass , j is 20print in main , i is 10 可见，pass方法内部对name的值的修改并没有改变实际参数i的值。那么，按照上面的定义，有人得到结论：Java的方法传递是值传递。 但是，很快就有人提出质疑了。然后，他们会搬出以下代码： 1234567891011121314public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); User hollis = new User(); hollis.setName(\"Xiao\"); hollis.setGender(\"Male\"); pt.pass(hollis); System.out.println(\"print in main , user is \" + hollis);&#125;public void pass(User user) &#123; user.setName(\"Qiang\"); System.out.println(\"print in pass , user is \" + user);&#125; 同样是一个pass方法，同样是在pass方法内修改参数的值。输出结果如下： 12print in pass , user is User&#123;name='Qiang', gender='Male'&#125;print in main , user is User&#123;name='Qiang', gender='Male'&#125; 经过pass方法执行后，实参的值竟然被改变了，那按照上面的引用传递的定义，实际参数的值被改变了，这不就是引用传递了么。于是，根据上面的两段代码，有人得出一个新的结论：Java的方法中，在传递普通类型的时候是值传递，在传递对象类型的时候是引用传递。 ​ 但是，这种表述仍然是错误的。不信你看下面这个参数类型为对象的参数传递： 123456789101112131415public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); String name = \"Xiao\"; pt.pass(name); System.out.println(\"print in main , name is \" + name);&#125;public void pass(String name) &#123; name = \"Qiang\"; System.out.println(\"print in pass , name is \" + name);&#125;上面的代码输出结果为print in pass , name is Xiaoprint in main , name is Qiang 这又作何解释呢？同样传递了一个对象，但是原始参数的值并没有被修改，难道传递对象又变成值传递了？ Java中的值传递你有一把钥匙，当你的朋友想要去你家的时候，如果你直接把你的钥匙给他了，这就是引用传递。这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。 你有一把钥匙，当你的朋友想要去你家的时候，你复刻了一把新钥匙给他，自己的还在自己手里，这就是值传递。这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。 但是，不管上面哪种情况，你的朋友拿着你给他的钥匙，进到你的家里，把你家的电视砸了。那你说你会不会受到影响？而我们在pass方法中，改变user对象的name属性的值的时候，不就是在“砸电视”么。你改变的不是那把钥匙，而是钥匙打开的房子。 所以，值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参 https://www.cnblogs.com/wchxj/p/8729503.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"运算","date":"2019-09-03T08:25:28.000Z","path":"2019/09/03/运算/","text":"1、float 与 double​ Java 不能隐式执行向下转型，因为这会使得精度降低。 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。 1234// float f = 1.1;//错误 1.1 属于 double 需要强转float f = 1.1f;// 1.1f 才是float类型的 2、隐式类型转换​ 因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。 ​ 12short s1 = 1;// s1 = s1 + 1; ​ 但是使用 += 或者 ++ 运算符可以执行隐式类型转换。 12s1 += 1;// s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型： 1s1 = (short) (s1 + 1); 测试12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; short s1 = 1; // s1 = s1+1;//报错，因为s1+1结果是int类型，等号左边是short类型，所以要强转 s1 = (short) (s1 + 1); short s2 = 1; s2 += 1;// 因为+=在Java中进行了特殊处理，所以不会报错 long l1 = 1; l1 = l1 + 1;// 不报错，+左边是long型，右边是int型，所以进行运算的时候都变为long型，结果是long型再赋值给long型自然不会错 long l2 = 1; l2 += 1;// OK &#125; &#125; 3、switch​ 在Java7后可以使用 String类型作为参数 ​ Enum枚举类型也行，但是 long类型的不能作为 switch的参数","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"数据类型","date":"2019-09-03T07:48:49.000Z","path":"2019/09/03/数据类型/","text":"一、数据类型基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~ boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 包装类型基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱 调用了 Integer.valueOf(2)int y = x; // 拆箱 调用了 X.intValue() 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456789101112131415Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // 不一样的对象，falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // 用的是缓存池的对象，true x = new Integer(129); y = new Integer(129);System.out.println(x == y); // 不一样的对象，false z = Integer.valueOf(129); k = Integer.valueOf(129);System.out.println(z == k); // false 因为范围在 -127 到 128之外了 //所有不是用的缓存池里面的对象 valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"网络编程","date":"2019-09-02T12:35:28.000Z","path":"2019/09/02/网络编程/","text":"https://www.cnblogs.com/midiyu/p/7875574.html**‘** 一、概述计算机网络是通过传输介质、通信设施和网络通信协议，把分散在不同地点的计算机设备互连起来，实现资源共享和数据传输的系统。网络编程就就是编写程序使联网的两个(或多个)设备(例如计算机)之间进行数据传输。Java语言对网络编程提供了良好的支持，通过其提供的接口我们可以很方便地进行网络编程。下面先对网络编程的一些基础知识进行介绍，最后给出使用Java语言进行网络编程的实例。 二、计算机网络计算机网络20世纪60年代出现，经历了20世纪70年代、80年代和90年代的发展，进入21世纪后，计算机网络已经成为信息社会的基础设施，深入到人类社会的方方面面，与人们的工作、学习和生活息息相关。 网络协议 如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间能够进行相互通信是因为它们都共同遵守一定的规则，即网络协议。 网络体系结构 计算机网络是个复杂的系统，按照人们解决复杂问题的方法，把计算机网络实现的功能分到不同的层次上，层与层之间用接口连接。通信的双方具有相同的层次，层次实现的功能由协议数据单元(PDU)来描述。不同系统中的同一层构成对等层，对等层之间通过对等层协议进行通信，理解彼此定义好的规则和约定。 计算机网络体系结构是计算机网络层次和协议的集合，网络体系结构对计算机网络实现的功能，以及网络协议、层次、接口和服务进行了描述，但并不涉及具体的实现。接口是同一节点内相邻层之间交换信息的连接处，也叫服务访问点(SAP)。 计算机网络层次模型 三、OSI参考模型前面我们介绍了计算机网络的体系结构，因为计算机网络是个复杂的系统，所以把计算机网络实现的功能分到不同的层次上，而计算机网络体系结构是计算机网络层次和协议的集合。那么，计算机网络如何进行分层呢？下面先介绍的是OSI参考模型。 OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 OSI参考模型的7个层次 OSI模型层次功能 物理层 物理层处于OSI的最底层，是整个开放系统的基础。物理层涉及通信信道上传输的原始比特流(bits)，它的功能主要是为数据端设备提供传送数据的通路以及传输数据。 数据链路层 数据链路层的主要任务是实现计算机网络中相邻节点之间的可靠传输，把原始的、有差错的物理传输线路加上数据链路协议以后，构成逻辑上可靠的数据链路。需要完成的功能有链路管理、成帧、差错控制以及流量控制等。其中成帧是对物理层的原始比特流进行界定，数据链路层也能够对帧的丢失进行处理。 网络层 网络层涉及源主机节点到目的主机节点之间可靠的网络传输，它需要完成的功能主要包括路由选择、网络寻址、流量控制、拥塞控制、网络互连等。 传输层 传输层起着承上启下的作用，涉及源端节点到目的端节点之间可靠的信息传输。传输层需要解决跨越网络连接的建立和释放，对底层不可靠的网络，建立连接时需要三次握手，释放连接时需要四次挥手。 会话层和表示层 会话层的主要功能是负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信。 表示层关心所传输数据信息的格式定义，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。 应用层 应用层为OSI的最高层，是直接为应用进程提供服务的。其作用是在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务。 四、TCP/IP参考模型OSI参考模型的初衷是提供全世界范围的计算机网络都要遵循的统一标准，但是由于存在模型和协议自身的缺陷，迟迟没有成熟的产品推出。TCP/IP协议在实践中不断完善和发展取得成功，作为网络的基础，Internet的语言，可以说没有TCP/IP协议就没有互联网的今天。 简介 TCP/IP，即Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，是Internet最基本的协议、Internet国际互联网络的基础。 TCP/IP协议是一个开放的网络协议簇，它的名字主要取自最重要的网络层IP协议和传输层TCP协议。TCP/IP协议定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。TCP/IP参考模型采用4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这4个层次分别是：网络接口层、互联网层(IP层)、传输层(TCP层)、应用层。 OSI 和 TCP/IP模型对比 TCP/IP模型层次功能 网络接口层 TCP/IP协议对网络接口层没有给出具体的描述，网络接口层对应着物理层和数据链路层。 互联网层 ( IP层 ) 互联网层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。互联网层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，互联网层还需要完成拥塞控制的功能。 传输层 ( TCP层 ) TCP层负责在应用进程之间建立端到端的连接和可靠通信，它只存在与端节点中。TCP层涉及两个协议，TCP和UDP。其中，TCP协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等。UDP协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。 应用层 应用层为Internet中的各种网络应用提供服务。 五、常见网络协议上面主要介绍了OSI参考模型和TCP/IP模型的相关内容，从下面这张图可以看出TCP/IP协议簇中不同的层次中有着很多不同的网络协议，下面主要介绍传输层的TCP、UDP协议和应用层的HTTP协议。 TCP协议 简介 TCP（Transmission Control Protocol ，传输控制协议）是面向连接的传输层协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。TCP协议采用字节流传输数据。 TCP报文段格式 TCP报文段包括协议首部和数据两部分，协议首部的固定部分有20个字节，首部的固定部分后面是选项部分。 TCP报文段 下面是报文段首部各个字段的含义。 源端口号以及目的端口号，各占2个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和IP地址，可以唯一确定一个TCP连接，在网络编程中，通常被称为一个socket接口。 序号（seq），占4字节，用来标识从TCP发送端向TCP接收端发送的数据字节流。 确认序号（ack），占4字节，包含发送确认的一端所期望收到的下一个序号，因此，确认序号应该是上次已经成功收到数据字节序号加1. 数据偏移，占4位，用于指出TCP首部长度，若不存在选项，则这个值为20字节，数据偏移的最大值为60字节。 保留字段占6位，暂时可忽略，值全为0 标志位 URG（紧急） : 为1时表明紧急指针字段有效 ACK（确认）：为1时表明确认号字段有效 PSH（推送）：为1时接收方应尽快将这个报文段交给应用层 RST（复位）：为1时表明TCP连接出现故障必须重建连接 SYN（同步）：在连接建立时用来同步序号 FIN （终止）： 为1时表明发送端数据发送完毕要求释放连接 接收窗口占2个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。 校验和占2个字节，范围包括首部和数据两部分。 选项是可选的，默认情况是不选。 三次握手与四次挥手 TCP是面向连接的协议，因此每个TCP连接都有3个阶段：连接建立、数据传送和连接释放。连接建立经历三个步骤，通常称为“三次握手”。 TCP三次握手过程如下： 第一次握手 客户机发送连接请求报文段到服务器，并进入SYN_SENT状态，等待服务器确认。（SYN = 1,seq=x） 第二次握手 服务器收到连接请求报文，如果同意建立连接，向客户机发回确认报文段，并为该TCP连接分配TCP缓存和变量。(SYN=1,ACK=1,seq=y,ack=x+1)。 第三次握手 客户机收到服务器的确认报文段后，向服务器给出确认报文段，并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入ESTABLISHED（建立）（TCP连接成功）状态，完成三次握手。(ACK=1,seq=x+1,ack=y+1)。 TCP四次挥手过程如下： 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。（FIN = 1，seq = u） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。（ACK = 1，seq = v ，ack= u + 1） 服务器关闭客户端的连接，发送一个FIN给客户端。（FIN = 1，ACK = 1，seq = w ，ack = u + 1 ） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。（ACK = 1，seq = u + 1，ack = w+ 1 ） UDP协议 简介 UDP，用户数据报协议，英文全称是User Datagram Protocol，它是TCP/IP协议簇中无连接的运输层协议。 UDP协议格式 UDP格式 从图中可以看到，UDP协议十分简单，它由两部分组成：首部和数据。其中，首部仅有8个字节，包括源端口和目的端口，长度（UDP用于数据报的长度）、校验和。 HTTP协议 简介 HTTP，超文本传输协议，英文全称是Hypertext Transfer Protocol，它是互联网上应用最为广泛的一种网络协议。HTTP是一种应用层协议，它是基于TCP协议之上的请求/响应式的协议，即一个客户端与服务器建立连接后，向服务器发送一个请求；服务器接到请求后，给予相应的响应信息。HTTP协议默认的端口号为80. 现在使用的HTTP协议是HTTP/1.1版本，1997年之前采用的是HTTP1.0版本。HTTP连接在1.0版本中采用非持续连接工作方式，1.1版本采用的是持续连接工作方式，持续连接是指服务器在发送响应后仍然在一段时间内保持这条由TCP运输层协议建立起来的连接，使客户机和服务器可以继续在这条连接上传输HTTP报文。 是否采用持续连接工作方式，1.0中默认是关闭的，需要在HTTP头加入”Connection:Keep-Alive”，才能启用Keep-Alive。HTTP1.1中默认启用Keep-Alive，如果加入”Connection:close”，才关闭。目前大部分浏览器都是用HTTP1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。 HTTP报文 HTTP协议是基于TCP协议之上的请求/响应式协议，下面主要介绍HTTP报文的格式，HTTP报文主要有请求报文和响应报文两种。首先看请求报文的格式： HTTP请求报文格式 HTTP请求报文由请求行、首部行和实体主体组成，由浏览器发送给服务器。上面这张图中SP表示空格，cr lf表示回车和换行。 HTTP响应报文格式 上面这张图是HTTP响应报文，它由状态行、首部行和实体主体组成。下面两张图是在谷歌浏览器内访问服务器查看的HTTP请求和响应。 HTTP请求报文例子 HTTP响应报文例子 HTTP请求方法和响应状态码 在上面的HTTP请求报文例子中，我们可以看到请求方法是GET，这表示请求读取由URL所标志的信息，除了GET，还有其它几种常用的方法。 HTTP请求报文的一些方法 在HTTP响应报文的例子中，我们可以看到状态码是200，表示响应成功。下表是其它状态码，总共5大类，33种。 HTTPS和HTTP的区别HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点： 1、https协议需要到ca申请证书，一般免费证书很少，需要交费。 2、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 六、常见问题 到这里，关于计算机网络部分的总结内容就结束了，下面是几个常见的问题，汇总在这里。 OSI参考模型的分为哪几层，每层的功能？ OSI，开放系统互连参考模型，它的7个层次自顶到下依次为应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。各层的功能见文章开始。 TCP协议和UDP协议的区别？ TCP协议是传输控制协议，UDP协议是用户数据报协议，两者都是传输层的协议，主要区别在于前者是可靠的，面向连接的协议，后者是不可靠的，无连接的协议。其它的区别还有，TCP协议传输速度慢，UDP常用于一次性传输比较少量数据的网络应用。 TCP三次握手为什么不能是两次? 主要是防止两次握手情况下已经失效的连接请求报文段突然又传送到服务端而产生错误。例如，客户机A向服务器B发送TCP连接请求，第一个连接请求报文在网络的某个节点长时间滞留，A超时后认为报文丢失，于是再重传一次连接请求，B收到后建立连接。数据传输完毕后双方断开连接，而这时之前滞留的连接请求到达了服务端B，而B认为A又发来连接请求。如果两次握手建立连接，A并无连接请求，造成B的资源浪费。 HTTP请求的GET方法和POST方法的区别？ GET和POST是HTTP请求的两种方法，主要区别在于GET方法是请求读取由URL所标志的信息，POST是给服务器添加信息。点击查看更多 在浏览器中输入网址到显示出页面的整个过程？ (1) 输出包含域名的网址 (2) 浏览器向DNS请求解析域名对应的IP地址 (3) 域名系统DNS解析出域名对应的IP地址 (4) 浏览器与该服务器建立TCP连接 (5) 浏览器发送HTTP请求 (6) 服务器通过HTTP响应把页面文件发送给浏览器 (7) TCP连接释放 (8) 浏览器解释文件，并显示 *七、Java网络编程 *Java的网络编程主要涉及到的内容是Socket编程，那么什么是Socket呢？简单地说，Socket，套接字，就是两台主机之间逻辑连接的端点。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。Socket，本质上就是一组接口，是对TCP/IP协议的封装和应用(程序员层面上)。 整体流程Socket编程主要涉及到客户端和服务器端两个方面，首先是在服务器端创建一个服务器套接字(ServerSocket)，并把它附加到一个端口上，服务器从这个端口监听连接。端口号的范围是0到65536，但是0到1024是为特权服务保留的端口号，我们可以选择任意一个当前没有被其他进程使用的端口。 客户端请求与服务器进行连接的时候，根据服务器的域名或者IP地址，加上端口号，打开一个套接字。当服务器接受连接后，服务器和客户端之间的通信就像输入输出流一样进行操作。 实例一 下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端，通过这个例子可以初步对Socket编程有个把握。 服务器端 12345678910111213141516171819202122232425262728293031public class SocketServer &#123; public static void main(String[] args) throws IOException &#123; // 端口号 int port = 7000; // 在端口上创建一个服务器套接字 ServerSocket serverSocket = new ServerSocket(port); // 监听来自客户端的连接 Socket socket = serverSocket.accept(); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do &#123; double length = dis.readDouble(); System.out.println(\"服务器端收到的边长数据为：\" + length); double result = length * length; dos.writeDouble(result); dos.flush(); &#125; while (dis.readInt() != 0); socket.close(); serverSocket.close(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SocketClient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; int port = 7000; String host = \"localhost\"; // 创建一个套接字并将其连接到指定端口号 Socket socket = new Socket(host, port); DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); Scanner sc = new Scanner(System.in); boolean flag = false; while (!flag) &#123; System.out.println(\"请输入正方形的边长:\"); double length = sc.nextDouble(); dos.writeDouble(length); dos.flush(); double area = dis.readDouble(); System.out.println(\"服务器返回的计算面积为:\" + area); while (true) &#123; System.out.println(\"继续计算？(Y/N)\"); String str = sc.next(); if (str.equalsIgnoreCase(\"N\")) &#123; dos.writeInt(0); dos.flush(); flag = true; break; &#125; else if (str.equalsIgnoreCase(\"Y\")) &#123; dos.writeInt(1); dos.flush(); break; &#125; &#125; &#125; socket.close(); &#125;&#125; 实例二 可以看到上面的服务器端程序和客户端程序是一对一的关系，为了能让一个服务器端程序能同时为多个客户提供服务，可以使用多线程机制，每个客户端的请求都由一个独立的线程进行处理。下面是改写后的服务器端程序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class SocketServerM &#123; public static void main(String[] args) throws IOException &#123; int port = 7000; int clientNo = 1; ServerSocket serverSocket = new ServerSocket(port); // 创建线程池 ExecutorService exec = Executors.newCachedThreadPool(); try &#123; while (true) &#123; Socket socket = serverSocket.accept(); exec.execute(new SingleServer(socket, clientNo)); clientNo++; &#125; &#125; finally &#123; serverSocket.close(); &#125; &#125;&#125;class SingleServer implements Runnable &#123; private Socket socket; private int clientNo; public SingleServer(Socket socket, int clientNo) &#123; this.socket = socket; this.clientNo = clientNo; &#125; @Override public void run() &#123; try &#123; DataInputStream dis = new DataInputStream( new BufferedInputStream(socket.getInputStream())); DataOutputStream dos = new DataOutputStream( new BufferedOutputStream(socket.getOutputStream())); do &#123; double length = dis.readDouble(); System.out.println(\"从客户端\" + clientNo + \"接收到的边长数据为：\" + length); double result = length * length; dos.writeDouble(result); dos.flush(); &#125; while (dis.readInt() != 0); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(\"与客户端\" + clientNo + \"通信结束\"); try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面改进后的服务器端代码可以支持不断地并发响应网络中的客户请求。关键的地方在于多线程机制的运用，同时利用线程池可以改善服务器程序的性能。","tags":[{"name":"Java高级","slug":"Java高级","permalink":"http://cxqiang.gitee.io/blog/tags/Java高级/"}]},{"title":"反射","date":"2019-09-02T12:23:39.000Z","path":"2019/09/02/反射/","text":"运行时类型信息使得你可以在程序运行时发现和使用类型信息 Class对象常用的获取类的信息的方法类是程序的一部分，每个类都有一个Class对象（被保存到同名的.class文件中），为了生成这个 对象会运行java虚拟机的类类加载器 所有的类都是在第一次使用时，动态的加载到JVM中：当程序创建第一个对类的静态成员引用 时，就会加载这个类。证明构造器也是static 类加载首先会检查这个类的Class对象是否被加载，没有会找同名的.class文件加载字节码 class对象就和普通的对象一样，我们可以获取并操作它的引用 类的准备工作1：加载，由类加载器执行，查找对应的字节码，创建Class对象 2：链接：验证字节码，为静态域分配空间，如果必须的话，会解析这个类对其他类创建的 所有引用 3：初始化：对超类初始化，执行静态初始化器和静态初始化块（不包括构造器） 如果设置值为 final static 它是编译期的常量，不用初始化也可以读取（即调用 static final 字段 类不会加载），此时static的代码块不 会调用， 获取对象的class对象 1、Class c=对象名.class 类字面常量，这种方法（不会自动的初始化该对象）**，更加安全简单，因为它在编译期就会收到检查，推荐使用** 2、Class c= Class.forName(“com.xiaoqiang.Gum”); 参数要全限定名 包含包名，需要抛出ClassNotFindException这个异常 3、调用对象的 getClass（）方法 Class对象的方法 1234567getSimpleName() 和getCanonicalName() 简单和详细（ 包含包名）的类名getInterfaces() 返回Class对象中所含的接口的Class数组，getSuperclass（）返回基类的Class对象newInstance() 虚拟构造器，创建我自己，但得到的是Object引用，指向的确实具体的类实例，使用这个方法必须带有默认的构造器 泛化的Class引用得到的是确定对象的Class对象 Class class，这样就给出了限制 这时当用newInstance()方法得到的是具体的 Type对象 12345特例Class&lt;Number&gt; clazz=int.class;这个是错误的，虽然 Integer 是 Number的子类 即Integer就是 Number类型但是 Integer Class的对象 不是 Number Class的子类 这时就可以使用 JAVA泛型的通配符 ？ 代表 任何事物 1234Class&lt;? extends Number&gt; c = int.class;c=double.class;c=Number.class;这些都没有错误，因为 ? extends Number 已经限定了 可以为放 Number即其之类的对象 类型转换前先做检查 (然后在转换) 关键字：instanceof，返回boolean值，告诉我们对象是不是某个特定类型的实例 格式：对象 instanceof 类名 判断对象是否是 这个类（或者是其子类） instanceof只可与命名类型（即类名 String）进行比较 而不能与Class对象做比较 也可以用Class对象的方法 动态的instanceof即 class.getClass().isInstance(Object o) 判断Class对象 是否与Objiect对象一样 这两个是一样的，都是指 你是这个 类吗？ 或者是这个类的派生类吗？ 而 == 和 equal 比较的是两个Class对象的地址 反射RMI 远程方法调用，它允许一个JAVA程序将对象分布到多台机器上 Class类与java.lang.reflect 类库一起对反射的概念进行了支持，包含了Field，Method已经Constructor类 Class类 12345678910111213141516171819202122232425262728293031323334353637383940//Class实例有三种表示方式： //1、知道类名获取Foo的Class实例 Class c1 = Foo.class; //2、通过Foo对象获得Foo的Class实例 Class c2 = foo.getClass(); //3、通过forName()获得实例 Class c3 = Class.forName(\"test.reflect.Foo\");//这三者是相等的：//通过Class类的对象获得某个类的信息 String - getName() //返回类类型的名称 String - getSimpleName() //返回类类型的名称的简写Class&lt;?&gt; - getSuperclass() //获取超类的ClassClass&lt;?&gt;[] - getInterfaces() //获取所有的父接口Object - newInstance() //实例化 返回的是Object对象Constructor&lt;?&gt;[] - getConstructors() //获取访问属性为public的构造方法 // 获得指定参数的构造方法 这里构造方法的参数 为String String int（Integer）Constructor&lt;?&gt; constructor = c.getDeclaredConstructor(String.class, String.class, int.class);// 获得方法，getMethod只能获得public方法，包括父类和接口继承的方法Method - getMethod(String name,Class&lt;?&gt; args...) name 为方法名 args为方法的参数//获取任何一个的方法Method - getDeclaredMethod(String name,Class&lt;?&gt; args...)//获取所有的属性Field[] fields = c.getFields();//获取列自定义的属性 这里是获取name属性Field field = c.getDeclaredField(\"name\");// 获得类及其父类，父接口定义的public属性Field field2 = c.getField(\"color\");boolean - isPrimitive()判定指定的Class对象是否表示一个Java的基类型。获取类加载器getClassLoader() Constructor类1234567891011121314151617Constructor类的实例化对象，表示构造函数//获取访问权限constructor1.getModifiers()//获取构造器名称constructor1.getName()//获取构造的参数类型constructor1.getParameterTypes()//默认构造器创建实例Object obj = constructor1.newInstance()//带参数构造创建实例 Object obj2 = constructor2.newInstance(new Object[] &#123; 33, \"haha\" &#125;); Filed类12345678910111213// 获得权限修饰符，包括private/public/protect,static,finalString fieldModifier = Modifier.toString(field.getModifiers());getType()： //获取属性声明时类型对象（返回class对象）getGenericType() ： //返回属性声名的 Type 类型getName() ：// 获取属性声明时名字getAnnotations() ：// 获得这个属性上所有的注释getModifiers() ： //获取属性的修饰isEnumConstant() ： //判断这个属性是否是枚举类isSynthetic() ： //判断这个属性是否是 复合类get(Object obj) ： //取得obj对象这个Field上的值set(Object obj, Object value) ： //向obj对象的这个Field设置新值value Method类123456789101112131415161718192021222324252627282930313233343536//调用方法method.invoke(对象实例，参数);// 获得修饰符，包括private/public/protect,staticString modifier = Modifier.toString(method.geFiled类// 获得权限修饰符，包括private/public/protect,static,finalString fieldModifier = Modifier.toString(field.getModifiers());getType()： //获取属性声明时类型对象（返回class对象）getGenericType() ： //返回属性声名的 Type 类型getName() ： //获取属性声明时名字getAnnotations() ： //获得这个属性上所有的注释getModifiers() ：// 获取属性的修饰isEnumConstant() ： //判断这个属性是否是枚举类isSynthetic() ：// 判断这个属性是否是 复合类get(Object obj) ： //取得obj对象这个Field上的值set(Object obj, Object value) ：// 向obj对象的这个Field设置新值valuetModifiers());//获取参数的类型Class&lt;?&gt;[] paramTypes = method.getParameterTypes();//获取返回值的类型Class&lt;?&gt; returnType = method.getReturnType();//获取方法抛出的异常类型Class&lt;?&gt;[] excepTypes = method.getExceptionTypes();// 调用私有方法，getDeclaredMethod获得类自身的方法，包括public,protect,privateMethod method2 = c.getDeclaredMethod(\"buildMsg\", String.class);//设置可访问私有方法method2.setAccessible(true);//这是在调用invoke方法method2.invoke(对象实例，参数); Array数组12345678910111213141516//反射来创建数组Object array = Array.newInstance(int.class, 3)//通过反射来操作数组// 操作数组int[] exampleArray = &#123; 1, 2, 3, 4, 5 &#125;;// 获得数组类型Class&lt;?&gt; componentType = exampleArray.getClass().getComponentType();// 获得长度Array.getLength(exampleArray)// 获得指定元素 Array.get(exampleArray, 2)// 修改指定元素Array.set(exampleArray, 2, 6); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package myblog.rtti;import java.lang.reflect.Array;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class ToyReflection &#123; public static void printInfo(String info, Object obj) &#123; if (obj.getClass().isArray()) &#123; System.out.println(info + \": \"); int length = Array.getLength(obj); System.out.println(\"Array Size: \" + length); for (int i = 0; i &lt; length; i++) &#123; System.out.print(\"Array[\" + i + \"]: \" + Array.get(obj, i) + \", \"); &#125; if (length != 0) System.out.println(); &#125; System.out.println(info + \": \" + obj.toString()); &#125; public static void main(String[] args) &#123; try &#123; // 获得类对象 Class&lt;?&gt; c = Class.forName(\"myblog.rtti.Toy\"); printInfo(\"获得类对象\", c); // 获得超类 Class&lt;?&gt; superClass = c.getSuperclass(); printInfo(\"获得超类\", superClass); // 获得所有父接口 Class&lt;?&gt;[] interfaces = c.getInterfaces(); printInfo(\"获得所有父接口\", interfaces); // 实例化 Toy toy = (Toy) c.newInstance(); printInfo(\"实例化\", toy); // 获得访问属性为public的构造方法 Constructor&lt;?&gt;[] constructors = c.getConstructors(); printInfo(\"获得构造方法\", constructors); // 获得指定参数的构造方法 Constructor&lt;?&gt; constructor = c.getDeclaredConstructor(String.class, String.class, int.class); printInfo(\"获得指定构造方法\", constructor); // 获得方法，getMethod只能获得public方法，包括父类和接口继承的方法 Method method = c.getMethod(\"playToy\", String.class); printInfo(\"获得公有方法\", method); // 调用方法 method.invoke(toy, \"张三\"); // 获得修饰符，包括private/public/protect,static String modifier = Modifier.toString(method.getModifiers()); printInfo(\"获得修饰符\", modifier); // 获得参数类型 Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); printInfo(\"获得参数类型\", paramTypes); // 获得返回值类型 Class&lt;?&gt; returnType = method.getReturnType(); printInfo(\"获得返回值类型\", returnType); // 获得异常类型 Class&lt;?&gt;[] excepTypes = method.getExceptionTypes(); printInfo(\"获得异常类型\", excepTypes); // 调用私有方法，getDeclaredMethod获得类自身的方法，包括public,protect,private方法 Method method2 = c.getDeclaredMethod(\"buildMsg\", String.class); method2.setAccessible(true); String result = (String) method2.invoke(toy, \"李四\"); printInfo(\"获得私有方法\", result); // 获得全部属性 Field[] fields = c.getFields(); printInfo(\"获得全部属性\", fields); // 获得类自身定义的指定属性 Field field = c.getDeclaredField(\"name\"); printInfo(\"获得自身属性\", field); // 获得类及其父类，父接口定义的public属性 Field field2 = c.getField(\"color\"); printInfo(\"获得公有属性\", field2); // 获得权限修饰符，包括private/public/protect,static,final String fieldModifier = Modifier.toString(field.getModifiers()); printInfo(\"获得权限修饰符\", fieldModifier); // 操作数组 int[] exampleArray = &#123; 1, 2, 3, 4, 5 &#125;; // 获得数组类型 Class&lt;?&gt; componentType = exampleArray.getClass().getComponentType(); printInfo(\"数组类型\", componentType.getName()); // 获得长度 printInfo(\"数组长度\", Array.getLength(exampleArray)); // 获得指定元素 printInfo(\"获得数组元素\", Array.get(exampleArray, 2)); // 修改指定元素 Array.set(exampleArray, 2, 6); printInfo(\"修改数组元素\", exampleArray); // 获得当前的类加载器 printInfo(\"获得当前类加载器\", toy.getClass().getClassLoader().getClass().getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 反射的优点： 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点： 尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。","tags":[{"name":"Java高级","slug":"Java高级","permalink":"http://cxqiang.gitee.io/blog/tags/Java高级/"}]},{"title":"包装类","date":"2019-09-02T12:19:56.000Z","path":"2019/09/02/包装类/","text":"1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true； 12345int a = 220;Integer b = 220;System.out.println(a==b);//true2、两个Integer类型进行“==”比较， 如果其值在-128至127 ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关， 1234567891011Integer c=3;Integer h=3;Integer e=321;Integer f=321;System.out.println(c==h);//trueSystem.out.println(e==f);//false 3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。 1234567Integer a=1;Integer b=2;Integer c=3;System.out.println(c.equals(a+b));//true 4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。 1234567int i=1;int j = 2;Integer c=3;System.out.println(c.equals(i+j));//true","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"字符串3","date":"2019-09-02T12:07:10.000Z","path":"2019/09/02/字符串3/","text":"一、概述String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承） 在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; 1：String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。 value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 不变的好处 1. 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 二：字符串常量池 String Pool字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(\"aaa\");String s2 = new String(\"aaa\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 字面量和常量池初探1234String m = \"hello,world\"; String n = \"hello,world\"; String u = new String(m); String v = new String(\"hello,world\"); 会分配一个11长度的char数组，并在常量池分配一个由这个char数组组成的字符串，然后由m去引用这个字符串 用n去引用常量池里边的字符串，所以和n引用的是同一个对象 生成一个新的字符串，但内部的字符数组引用着m内部的字符数组 同样会生成一个新的字符串，但内部的字符数组引用常量池里边的字符串内部的字符数组，意思是和u是同样的字符数组 使用图来表示的话，情况就大概是这样的(使用虚线只是表示两者其实没什么特别的关系): 123456789String m = \"hello,world\"; String n = \"hello,world\"; String u = new String(m); String v = new String(\"hello,world\"); System.out.println(m == n); //true System.out.println(m == u); //false System.out.println(m == v); //false System.out.println(u == v); //false 结论： m和n是同一个对象 m,u,v都是不同的对象 m,u,v,n但都使用了同样的字符数组，并且用equal判断的话也会返回true https://www.cnblogs.com/xiaoxi/p/6036701.html","tags":[{"name":"字符串","slug":"字符串","permalink":"http://cxqiang.gitee.io/blog/tags/字符串/"}]},{"title":"字符串(二)","date":"2019-09-02T12:05:37.000Z","path":"2019/09/02/字符串2/","text":"String 字符串常量StringBuffer 字符串变量（线程安全）StringBuilder 字符串变量（非线程安全） 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象， 所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的： 1234String S1 = “This is only a” + “ simple” + “ test”;StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”); 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个 String S1 = “This is only a” + “ simple” + “test”; 其实就是： String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如： 1234String S2 = “This is only a”;String S3 = “ simple”;String S4 = “ test”;String S1 = S2 +S3 + S4; 这时候 JVM 会规规矩矩的按照原来的方式去做 在大部分情况下 StringBuffer &gt; StringStringBuffer Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。 可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。 StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。 例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。 在大部分情况下 StringBuilder &gt; StringBufferjava.lang.StringBuilde java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。","tags":[{"name":"字符串","slug":"字符串","permalink":"http://cxqiang.gitee.io/blog/tags/字符串/"}]},{"title":"字符串(一)","date":"2019-09-02T11:50:10.000Z","path":"2019/09/02/字符串1/","text":"1：不可变StringString对象是不可变的：创建后对象不能改变，在jdk中String类中每个看起来会修改String值的方 法，实际上都是创建了一个全新的 String 对象以及包含修改后的内容，而原来的String丝毫未动 2：重载 + 和 StringBuilder你可以对同一个String对象加任意多个别名(引用)String 对象具有只读的特性，指向他的任意引用 都不可能改变它的值，因此不会对其他引用造成影响 在 “+” String对象时，编译器会调用StringBuilder的append来进行操作，最后返回一个调用 toStrong()方法返回String对象 每次 “+” 都会创建个StringBuilder对象，使用当要+ 许多次是可以使用StringBuilder 而不是 String，StringBuffer与之差不多，但他是线程安全的，开销较大 3：无意识的递归自动类型转换：当String对象后面跟着一个 “+“，而后面的对象不是String，就会调用后面对象的 toString方法 ，自动的装换成String类型 4：String的操作​ 当改变字符串的内容时，String类方法会返回一个新的String对象，没有变化就返回原来的引用 方法 参数，重载版本 应用 构造器 重载版本：默认版本，String,StringBuilder,StringBuffer,char数组，byte数组 创建String对象 length() String中字符的个数 chatAt() Int索引 取得String中该索引位置上的char getChars(),getBytes() 要复制部分的起点和终点的索引，复制的目标数组，目标数组的起始索引 复制char或byte到一个目标数组中 toCharArray() 生成一个char[]，包含String 的所有字符 equals(),equalsIgnoreCase() 与之进行比较的String 比较两个String的内容是否相同 compareTo() 与之进行比较的String 按词典顺序比较String的内容，比较结果为负数、零或正数。注意，大小写并不等价 contains() 要搜索的CharSequence 如果该String对象包含参数的内容，则返回true contentEquals 与之进行比较的CharSequence或StringBuffer 如果该String与参数的内容完全一致，则返回true equalsIgnoreCase() 与之进行比较的String 忽略大小写，如果两个String的内容相同，则返回true regionMatcher() 该String的索引偏移量，另一个String及其索引偏移量，要比较的长度。重载版本增加了“忽略大小写”功能 返回boolean结果，以表明所比较区域是否相等 startsWith() 可能的起始String，重载版本在参数中增加了偏移量 返回boolean结果，以表明该String是否以此参数起始 endsWith() 该String可能的后缀String 返回boolean结果，以表明此参数是否该字符串的后缀 indexOf(),lastIndexOf() 重载版本包括：char，char与起始索引，String，String与起始索引 如果该String并不包含此参数，就返回-1；否则返回此参数在String中的起始索引。lastIndexOf()是从后向前搜索 concat() 要连接的String 返回一个新的String对象，内容为原始String连接上参数String replace() 要替换掉的字符，用来进行替换的新字符。也可以用一个charSequence来替换另一个CharSequence 返回替换字符后的新String对象。如果没有替换发生，则返回原始的String对象 toLowerCase()toUpperCase() 将字符的大小写改变后，返回一个新的String对象。如果没有改变发生，则返回原始的String对象 trim() 将String两端的空白字符删除后，返回一个新的String对象。如果没有改变发生，则返回原始的String对象 valueOf() 重载版本：Object;char[],char[],偏移量，与字符个数；boolean;char;int;long;float;double 返回一个表示参数内容的String intern() 为每个唯一的字符序列生成一个且仅生成一个String引用 5：格式化输出与c语言的输出类似，System.out.format(“%d”,x); %d 整型 %f 浮点型 %c 字符型 %s 字符串 %b Boolean值 %h 散列码 %x 十六进制整数 %% 字符‘%’ Formatter类构造器参数 是输出流 PrintStream , OutputStream ,File 格式化说明符 Formatter转换 如果嫌麻烦的话，可以使用String类的静态方法 String.format()方法 来返回一个 格式化的字符串 里面调用的页是Formatter对象","tags":[{"name":"字符串","slug":"字符串","permalink":"http://cxqiang.gitee.io/blog/tags/字符串/"}]},{"title":"枚举类型","date":"2019-09-02T11:40:50.000Z","path":"2019/09/02/枚举类型/","text":"1.基本enum特征 所有创建的枚举类都继承自抽象类 java.lang.Enum; 一个枚举类，所有实例都要在第一句写出以 ，隔开。 如果只有实例最后可以不加 ； 枚举类因为继承了Enum,所以再不能继承别的类，任何类也不能继承枚举类（构造器默认为private）。 123456public enum Color &#123; RED, BLUE, YELLOW, PURPLE&#125; 注意 ：RED,BLUE 这些是由 enum Color类调用默认private构造器创建的实例对象，和普通class相比只不过enum的实例对象只能在内部创建。时刻记着他们是一个实例对象。 枚举类实例不能在外部 new 出来 ，因为枚举类构造器为private 一般也不用声明private，默认就是private，因为enum实例只能在编译期间enum类内部被创建，但可以外部得到一个实例的引用。比如这么获得 12Color red = Color.RED;Color blue = Color.BLUE; ​ 枚举类的一些方法： ​ ​ 使用枚举元素 Color.RED 或者 red Color.values( ) 返回一个枚举类数组，数组元素就是枚举的实例。 red.ordinal() 方法返回该实例声明的次序从0开始。 2个实例可用 == 比较 Enum 实现了 Comparable和 Serializable 可以使用comparableTo( )方法，可以序列化 a. getDeclaringClass() 返回 Color.class 对象 a.name和a.toString( )方法一样。 ​ valuesOf(string ) 返回一个实例对象 Color b = Color.valueOf(“BLUE”); 根据class对象返回实例 Color b = Color.valueOf( Color.class, “BLUE” ) 通过带参构造器为枚举实例添加描述信息。调用 getDes()就可以的到当前对象的描述信息。 12345678910111213public enum Color &#123; RED(\"这是红色\"), BLUE(\"这是蓝色\"), YELLOW(\"这是黄色\"), PURPLE(\"这是紫色\"); String des; Color( String s) &#123; this.des = s; &#125; public String getDes()&#123; return des; &#125;&#125; 调用 getDes( )方法就可以的到当前对象的描述信息。 重写toString( )方法来为enum实例添加描述信息。 123456789101112public enum Color &#123; RED, BLUE, YELLOW, PURPLE; @Override public String toString() &#123; String id = name(); return id + \" is \" + id.toLowerCase(); &#125;&#125; 2.enum的特殊方法。 除了不能继承enum类外，enum和其普通类没区别，可以添加字段，方法，甚至是main 方法 enum 实例也可以用在 switch语句中 values()方法不在Enum中 它是由编译器添加的static方法。 编译器还添加了一个valuesOf(String s)方法，这个只需要一个参数就可以的得到实例，而Enum的需要2个。 如果将enum向上转型为Enum那么values 和 valuesOf 无法再使用。 与values 方法有相同作用的就是Class对象的getEnumConstants()，如果class是枚举类那么返回元素数组，不是枚举类返回null 3. 使用接口组织枚举 为了实现扩展enum 或者将enum分类，因为无法继承所以靠扩展子类无法实现，可以利用接口来达到这些功能。 接口内部创建实现该接口的enum 达到分类目的，并且可以向上转型为接口 123456789101112131415161718public interface Food &#123; enum Fruit implements Food&#123; APPLE, BANANA, ORANGE; &#125; enum Vegetables implements Food&#123; TOMATO, POTATO, BEANS; &#125; enum Drink implements Food&#123; COFFEE, COCA, REDBULL; &#125;&#125; public static void main(String[] args) &#123; Food food = Food.Fruit.APPLE; food = Food.Drink.REDBULL; food = Food.Vegetables.BEANS; &#125; 4. EnumSet EnumSet （抽象类）一个用来存放enum 元素的Set,存取enum速度非常快，性能非常高。 EnumSet 只能存放enum元素，不能插入空元素。 放入的元素位置和enum中保持一样，它处于排序状态，是一个有序Set. Enum 是个抽象类且方法除了colon( )克隆一个EnumSet外都是静态方法返回值都是EnumSet。 123EnumSet&lt;Color&gt; enumSet = EnumSet.noneOf(Color.class); //创建一个空集 EnumSet&lt;Color&gt; enumSet2 = EnumSet.allOf(Color.class); //把集合中所有元素添加进去 EnumSet&lt;Color&gt; enumSet3 = EnumSet.of(RED);//添加一个元素 5.EnumMap 特殊Map（类），key必须是enum, 由于enum元素有限所以内部只是由数组实现。 这是一个有序map，保持enum的元素顺序。 EnumMap&lt;Color,Object&gt; map = new EnumMap&lt;Color, Object&gt;(Color.class); 方法和其他Map一样。 6.实例对象添加方法 为每一个enum实例（相当于常量）添加一个方法，让他们有不同的行为。 为每一个实例添加不同行为的方法 在enum中创建一个或者多个abstract 方法，因为是enum的实例所以就得实现这些方法。 12345678910111213RED&#123; @Override String getInfo() &#123; return null; &#125; @Override String getTime() &#123; return null; &#125; &#125;; abstract String getInfo(); abstract String getTime(); enum也可以有main方法作为enum执行入口 常量添加方法后和有了类的行为，貌似和内部类一样，但他们有着不同行为，enum的常量不能作为方法参数类型，因为他们不是类，只是enum类型的static final 实例 由于enum的常量是 static final 的所以常量的方法不能访问外部类的非静态方法。 覆盖常量相关的方法 enum中所有非抽象方法每个实例都可以调 如果不需要每个实例都实现抽象类，那么就可以不用定义抽象类，每个实例各自实现方法，实现的方法可以覆盖enum中的方法。 使用enum职责链。 多种不同的方式解决问题，然后把它们连接在一起，但一个请求到达时遍历整个链，直到解决问题。 enum非常适合作为解决某一个问题的职责链，请求到达时遍历整个enum，直到解决问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.EnumSet;import java.util.Random;public enum COR &#123; SOLUTION_ONE&#123; @Override boolean Solve(int i) &#123; if (i == 1)&#123; System.out.println(name()+\" 解决问题 \" +i); return true; &#125; return false; &#125; &#125;, SOLUTION_TWO&#123; @Override boolean Solve(int i) &#123; if (i == 2)&#123; System.out.println(name()+\" 解决问题 \" +i); return true; &#125;return false; &#125; &#125;, SOLUTION_THREE&#123; @Override boolean Solve(int i) &#123; if (i == 3)&#123; System.out.println(name()+\" 解决问题 \" +i); return true; &#125;return false; &#125; &#125;, SOLUTION_FOUR&#123; @Override boolean Solve(int i) &#123; if (i == 4)&#123; System.out.println(name()+\" 可以解决问题 \" +i); return true; &#125;return false; &#125; &#125;; abstract boolean Solve(int i); public static void main(String[] args) &#123; Random random = new Random(); EnumSet&lt;COR&gt; cors = EnumSet.allOf(COR.class); for (int i = 0; i &lt; 6; i++) &#123; int id = random.nextInt(4)+1; for (COR cor :cors) &#123; if (cor.Solve(id))&#123; System.out.println(\" 解决问题 \" +id); break; &#125; &#125; &#125; &#125;&#125; enum状态机 状态机可以具有 有限个 状态，通常根据输入，从一个状态转移到下一个状态，也可以有瞬时状态，一但任务结束就立刻离开瞬时状态。每个状态都具有某些可接受的输入，不同的输入会使状态机从当前的状态移到不同的新状态。 7.多路分发 多种类型交互时有时并不能确定所有类型，如： NUM.complete(NUM) , NUM 是所有数字类型的超类，a.complete(b) ,a b可能是同种类型也可能不是同一种类型。 Java 动态绑定只能处理一种类型，属于单路分发（分派），动态绑定能将complete绑定到分路a。只有方法调用才会执行动态绑定。 可以为每一个分发实现自己的动态绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.xiaoqiang.foutth;import java.util.Random; enum Outcome &#123; WIN, LOSE, DRAW &#125; ///:~interface Item &#123; Outcome compete(Item it); Outcome eval(Paper p); Outcome eval(Scissors s); Outcome eval(Rock r);&#125;class Paper implements Item &#123; public Outcome compete(Item it) &#123; return it.eval(this); &#125; public Outcome eval(Paper p) &#123; return Outcome.DRAW; &#125; public Outcome eval(Scissors s) &#123; return Outcome.WIN; &#125; public Outcome eval(Rock r) &#123; return Outcome.LOSE; &#125; public String toString() &#123; return \"Paper\"; &#125;&#125;class Scissors implements Item &#123; public Outcome compete(Item it) &#123; return it.eval(this); &#125; public Outcome eval(Paper p) &#123; return Outcome.LOSE; &#125; public Outcome eval(Scissors s) &#123; return Outcome.DRAW; &#125; public Outcome eval(Rock r) &#123; return Outcome.WIN; &#125; public String toString() &#123; return \"Scissors\"; &#125;&#125;class Rock implements Item &#123; public Outcome compete(Item it) &#123; return it.eval(this); &#125; public Outcome eval(Paper p) &#123; return Outcome.WIN; &#125; public Outcome eval(Scissors s) &#123; return Outcome.LOSE; &#125; public Outcome eval(Rock r) &#123; return Outcome.DRAW; &#125; public String toString() &#123; return \"Rock\"; &#125;&#125;public class RoShamBo1 &#123; static final int SIZE = 20; private static Random rand = new Random(47); public static Item newItem() &#123; switch (rand.nextInt(3)) &#123; default: case 0: return new Scissors(); case 1: return new Paper(); case 2: return new Rock(); &#125; &#125; public static void match(Item a, Item b) &#123; System.out.println(a + \" vs. \" + b + \": \" + a.compete(b)); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; SIZE; i++) match(newItem(), newItem()); &#125; &#125; 使用enum实现多路分发 enum的实例不能作为类型参数，不可以重载方法。 可以使用enum构造器初始化每个enum实例，并以一组结果作为参数如 ENUM_A( vsA_DRAW, vsB_LOSE, vsC_WIN ) 在比较方法中使用switch 判断 返回 结果 123456789101112131415161718192021222324252627282930313233package enums;import static enums.OutCome.*;public enum RoSham &#123; PAPER(DRAW, LOSE, WIN), SCISSORS(WIN, DRAW, LOSE), ROCK(LOSE, WIN, DRAW); private OutCome vPAPER, vSCISSORS, vROCK; RoSham(OutCome paper, OutCome scissors, OutCome rock) &#123; this.vPAPER = paper; this.vSCISSORS = scissors; this.vROCK = rock; &#125; public OutCome complete(RoSham it) &#123; switch (it) &#123; default: case PAPER: return vPAPER; case SCISSORS: return vSCISSORS; case ROCK: return vROCK; &#125; &#125; public static void main(String[] args) &#123; System.out.println(PAPER.complete(ROCK)); &#125;&#125; PAPER.complete（）时把PAPER构造器中的结果与 OutCome 变量绑定，根据对比的参数返回对比结果，因此实例构造器中的参数位置非常重要、 使用EnumMap EnumMap实现真正的多路分发 123456789101112131415161718192021222324252627282930313233343536373839package enums;import java.util.EnumMap;import static enums.OutCome.*;public enum RoShamBo &#123; PAPER, SCISSORS, ROCK; static EnumMap&lt;RoShamBo, EnumMap&lt;RoShamBo, OutCome&gt;&gt; table = new EnumMap&lt;RoShamBo, EnumMap&lt;RoShamBo, OutCome&gt;&gt;(RoShamBo.class); static &#123; for (RoShamBo it : RoShamBo.values()) &#123; table.put(it, new EnumMap&lt;RoShamBo, OutCome&gt;(RoShamBo.class)); &#125; initRow(PAPER, DRAW, LOSE, WIN); initRow(SCISSORS, WIN, DRAW, LOSE); initRow(ROCK, LOSE, WIN, DRAW); &#125; static void initRow(RoShamBo it, OutCome vPAPER, OutCome vSCISSORS, OutCome vROCK) &#123; EnumMap&lt;RoShamBo, OutCome&gt; row = RoShamBo.table.get(it); row.put(RoShamBo.PAPER, vPAPER); row.put(RoShamBo.SCISSORS, vSCISSORS); row.put(RoShamBo.ROCK, vROCK); &#125; public OutCome complete(RoShamBo it) &#123; return table.get(this).get(it); &#125; public static void main(String[] args) &#123; System.out.println(ROCK.complete(SCISSORS)); &#125;&#125; 使用二维数组 简单，速度快，代码易懂，但是组数比较大时尺寸容易错 123456789private static OutCome[][] tables = &#123; &#123;DRAW, LOSE, WIN&#125;, &#123;WIN, DRAW, LOSE&#125;, &#123;LOSE, WIN, DRAW&#125;, &#125;; public OutCome completes (RoShamBo other) &#123; return tables[this.ordinal()][other.ordinal()]; &#125; 知识点 可以静态导入枚举类 直接使用枚举实例 import static ……Color.* 最好使用静态导入省去写enum类。","tags":[{"name":"java基础","slug":"java基础","permalink":"http://cxqiang.gitee.io/blog/tags/java基础/"}]},{"title":"","date":"2019-08-31T02:56:42.147Z","path":"2019/08/31/System/","text":"一、System类的定义 System类为Java的系统类，位于 java.lang 包中 System类的构造方法由 private 进行修饰，因此无法被实例化 System类提供了标准输入流、标准输出流和错误输出流； 此外还提供了访问操作系统环境变量，访问虚拟机环境变量，复制数组，垃圾回收等一系列实用方法 二、System类的常用方法 1、System.currentTimeMillis() 获取当前时间戳，单位为秒 2、System.nanoTime() 获取当前时间戳，单位为纳秒 3、System.lineSeparator() 行分隔符，等同于 System.getProperty(“line.separator”) 4、System.arraycopy() 拷贝数组，有五个参数，System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) src：源数组 srcPos：源数组开始截取的位置，从0开始 dest：目标数组 destPos：目标数组开始拷贝的位置，从0开始 length：截取长度 5、System.gc() 相当于调用了 Runtime.getRuntime().gc()， 在回收之前会调用对象的finalize()方法，用于负责回收无用对象占据的内存资源 告诉垃圾收集器准备进行垃圾收集，但垃圾收集器不一定会马上执行， 这是因为 垃圾回收只与内存有关，根据虚拟机的各种算法来计算得到执行垃圾回收的时间 6、System.runFinalization() 调用已失去引用的对象的finalize()方法，但不能保证其一定执行 7、System.load(String filepath) 用于加载库文件，参数为 库文件的绝对路径 库文件：动态链接库(ddl)，Dynamic Link Library， 是一个包含可由多个程序同时使用的代码和数据的库,实现程序模块化 8、System.loadLibrary(String libname) 用于加载库文件，参数为 库文件名 该库文件必须在 java.library.path 所指向的路径中 9、System.mapLibraryName(String libname) 将库名称映射到特定的字符串中 10、System.exit(int status) 终止目前正在运行的Java虚拟机 参数为0：正常终止 参数非0：异常终止 11、System.getenv() 获取操作系统的环境变量（即本地系统中的环境变量） 参数为空：获取操作系统的所有环境变量 参数不为空：获取操作系统的指定环境变量（例如：参数为“path”） 12、System.getProperties() 获取虚拟机（JVM）的所有环境变量 13、System.getProperty(String key) 获取虚拟机（JVM）的指定环境变量 System.getProperty(“java.version”)：获取java运行环境版本 System.getProperty(“java.vendor”)：获取java运行环境供应商 System.getProperty(“java.vendor.url”)：获取java运行环境供应商的URL System.getProperty(“java.home”)：获取java安装路径 System.getProperty(“java.vm.specification.version”)：获取java虚拟机规范版本 System.getProperty(“java.vm.specification.vendor”)：获取java虚拟机规范供应商 System.getProperty(“java.vm.specification.name”)：获取java虚拟机规范名称 System.getProperty(“java.vm.version”)：获取java虚拟机实现版本 System.getProperty(“java.vm.vendor”)：获取java虚拟机实现供应商 System.getProperty(“java.vm.name”)：获取java虚拟机实现名称 System.getProperty(“java.specification.version”)：获取java运行时环境规范版本 System.getProperty(“java.specification.vender”)：获取java运行时环境规范供应商 System.getProperty(“java.specification.name”)：获取java运行时环境规范名称 System.getProperty(“java.class.version”)：获取java类格式版本号 System.getProperty(“jjava.class.path”)：获取java类路径 System.getProperty(“java.library.path”)：获取加载库时搜索的路径列表 System.getProperty(“java.io.tmpdir”)：获取默认的临时文件路径 System.getProperty(“java.ext.dirs”)：获取一个或多个扩展目录的路径 System.getProperty(“os.name”)：获取操作系统的名称 System.getProperty(“os.arch”)：获取操作系统的构架 System.getProperty(“os.version”)：获取操作系统的版本 System.getProperty(“file.separator”)：获取文件分隔符 System.getProperty(“path.separator”)：获取路径分隔符 System.getProperty(“line.separator”)：获取行分隔符 System.getProperty(“user.name”)：获取用户名称 System.getProperty(“user.home”)：获取用户主目录 System.getProperty(“user.dir”)：获取用户当前工作目录 14、System.setProperties(Properties props) 设置虚拟机(JVM)的环境变量（批量） 1234Properties prop = new Properties();prop.setProperty(\"aaa\", \"bbb\");System.setProperties(prop);System.out.println(System.getProperty(\"aaa\")); 15、System.setProperty(String key, String value) 设置虚拟机(JVM)的环境变量（单个） 16、System.clearProperty(String key) 清除设置的虚拟机(JVM)的环境变量 17、System.console() 从控制台设备读取字符信息,只能通过命令执行,在IDE中会报错 18、System.setIn(InputStream in) 重新分配标准输入流 19、System.setErr(PrintStream err) 重新分配标准错误输出流 20、System.setOut(PrintStream out) 重新分配标准输出流 21、err 标准错误输出流，没有缓存，会立即输出 22、out 标准输出流，有缓存，不一定会立即输出 23、System.identityHashCode(Object obj) 根据对象内存地址来计算得到哈希值 注意，这里需要与 hashCode() 方法进行区分 1234567891011121314151617181920212223// 由于Apple并没有覆盖hashCode()方法，所以两方法得到的哈希值相等Apple apple = new Apple();System.out.println(apple.hashCode()); // 21685669System.out.println(System.identityHashCode(apple)); // 21685669// 由于String类覆盖了hashCode()方法，所以两方法得到的哈希值不相等String str = \"123\";System.out.println(str.hashCode()); // 48690System.out.println(System.identityHashCode(str)); // 21685669// 由于\"123\"会存在常量池中，str1和str2两者指向的是常量池中的同一对象，所以两方法得到的哈希值相等String str1 = \"123\";String str2 = \"123\";System.out.println(System.identityHashCode(str1)); // 21685669System.out.println(System.identityHashCode(str2)); // 21685669// str1和str2是两个不同对象，所以两方法得到的哈希值不相等String str1 = new String(\"123\");String str2 = new String(\"123\");System.out.println(System.identityHashCode(str1)); // 21685669System.out.println(System.identityHashCode(str2)); // 2133927002 24、System.setSecurityManager(SecurityManager securityManager) 设置安全管理器，接收一个 SecurityManager 类型的参数 25、System.getSecurityManager() 获取安全管理器 26、System.inheritedChannel() 返回从创建此Java虚拟机的实体继承得到的channel","tags":[]},{"title":"Random","date":"2019-08-31T02:56:32.000Z","path":"2019/08/31/Random/","text":"一、Random类的定义Random类位于 java.util 包中，主要用于生成伪 随机数 Random类将 种子数 作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关 创建Random实例时，若没有指定种子数，则会以 当前时间 作为种子数，来计算生成伪随机数 拥有 相同种子 的Random实例，在相同次数下，生成的伪随机数完全相同 1234Random random1 = new Random(10);Random random2 = new Random(10);System.out.println(random1.nextInt()); // -1157793070System.out.println(random2.nextInt()); // -1157793070 二、Random类的常用方法 1、random.nextBoolean() 用于从该随机数生成器的序列中得到下一个伪均匀分布的boolean值 2、random.nextBytes() 用于生成随机字节并将其放入用户提供的byte数组中 3、random.nextDouble() 用于从该随机数生成器的序列中得到下一个伪均匀分布在0.0到1.0之间的double值，[0.0, 1.0) 4、random.nextFloat() 用于从该随机数生成器的序列中得到下一个伪均匀分布在0.0到1.0之间的float值，[0.0, 1.0) 5、random.nextInt() random.nextInt() 用于从该随机数生成器的序列中得到下一个伪均匀分布的int值 random.nextInt(int bound) 用于从该随机数生成器的序列中得到下一个0到结束值之间伪均匀分布的int值，[0, 结束值) 6、random.nextGaussian() 用于从该随机数生成器的序列中得到下一个伪均匀分布的double值 生成的double值符合均值为0，方差为1的正态分布(高斯分布) 7、random.setSeed(long seed) 设置随机种子","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"Date","date":"2019-08-31T02:56:22.000Z","path":"2019/08/31/Date/","text":"一、Date类的定义 Date类位于 java.util 包中，主要用来封装当前的日期和时间， Date 类提供两个构造函数来实例化 Date 对象 Date()：使用当前日期和时间来初始化对象 Date(long milliseconds)：接收一个long类型的参数，该参数是从1970-01-01 00:00:00.000到当前时间的毫秒数 1234567Date date = new Date();// 打印Date对象// Sat：表示周六// Aug：表示八月// GMT：格林威治标准时间// GMT+08:00：东八区即标准北京时间System.out.println(date); // Sat Aug 11 17:03:32 GMT+08:00 2018 二、Date类的常用方法 1、getTime() 得到时间毫秒数 2、setTime(long milliseconds) 设置时间毫秒数 3、equals(Object obj) 比较两个时间是否相等 4、after(Date when) 测试目标日期是否在参数日期之后 5、before(Date when) 测试目标日期是否在参数日期之前 6、compareTo(Date anotherDate) 对两个Date对象进行比较 1234SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");Date date1 = sdf.parse(\"2018-08-10 08:08:123\");Date date2 = sdf.parse(\"2018-08-10 08:08:123\");System.out.println(date1.compareTo(date2)); // 0 如果目标日期在参数日期之后，则返回1 如果目标日期在参数日期之前，则返回-1 7、toInstant() 注意：Instant输出的是标准时间，即格林威治标准时间，而Date输出的是北京时间，两者相差8个小时 返回一个时间线上与此日期相同的一个点","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"Collections","date":"2019-08-31T02:56:11.000Z","path":"2019/08/31/Collections/","text":"1. 排序操作（主要针对List接口相关） reverse(List list)：反转指定List集合中元素的顺序 shuffle(List list)：对List中的元素进行随机排序（洗牌） sort(List list)：对List里的元素根据自然升序排序 sort(List list, Comparator c)：自定义比较器进行排序 swap(List list, int i, int j)：将指定List集合中i处元素和j出元素进行交换 rotate(List list, int distance)：将所有元素向右移位指定长度 2. 查找和替换（主要针对Collection接口相关） binarySearch(List list, Object key)：使用二分搜索法，以获得指定对象在List中的索引，前提是集合已经排序 max(Collection coll)：返回最大元素 max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素 min(Collection coll)：返回最小元素 min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素 fill(List list, Object obj)：使用指定对象填充 frequency(Collection Object o)：返回指定集合中指定对象出现的次数 3. 同步控制Collections工具类中提供了多个synchronizedXxx方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。HashSet、ArrayList、HashMap都是线程不安全的，如果需要考虑同步，则使用这些方法。这些方法主要有：synchronizedSet、synchronizedSortedSet、synchronizedList、synchronizedMap、synchronizedSortedMap。 特别需要指出的是，在使用迭代方法遍历集合时需要手工同步返回的集合。 4. 设置不可变集合Collections有三类方法可返回一个不可变集合： emptyXxx()：返回一个空的不可变的集合对象 singletonXxx()：返回一个只包含指定对象的，不可变的集合对象。 unmodifiableXxx()：返回指定集合对象的不可变视图 5、其他 disjoint(Collection c1, Collection c2) - 如果两个指定 collection 中没有相同的元素，则返回 true。 addAll(Collection&lt;? super T&gt; c, T… a) - 一种方便的方式，将所有指定元素添加到指定 collection 中。示范： Collections.addAll(flavors, “Peaches ‘n Plutonium”, “Rocky Racoon”); Comparator reverseOrder(Comparator cmp) - 返回一个比较器，它强行反转指定比较器的顺序。如果指定比较器为 null，则此方法等同于 reverseOrder()（换句话说，它返回一个比较器，该比较器将强行反转实现 Comparable 接口那些对象 collection 上的自然顺序）。","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"Arrays","date":"2019-08-31T02:55:55.000Z","path":"2019/08/31/Arrays/","text":"一、Arrays类的定义 Arrays类位于 java.util 包中，主要包含了操纵数组的各种方法 二、Arrays类的常用方法 1、Arrays.asList(T… data) 注意：该方法返回的是Arrays内部静态类ArrayList，而不是我们平常使用的ArrayList,，该静态类ArrayList没有覆盖父类的add, remove等方法，所以如果直接调用，会报UnsupportedOperationException异常 可接受可变参数，数组等 2、Arrays.fill() Arrays.fill(Object[] array, Object obj) 用指定元素填充整个数组（会替换掉数组中原来的元素） Arrays.fill(Object[] array, int fromIndex, int toIndex, Object obj) 用指定元素填充数组，从起始位置到结束位置，取头不取尾（会替换掉数组中原来的元素） 左闭右开原则 Integer[] data = {1, 2, 3, 4}; Arrays.fill(data, 0, 2, 9); System.out.println(Arrays.toString(data)); // [9, 9, 3, 4] 3、Arrays.sort() Arrays.sort(Object[] array) 对数组元素进行排序（串行排序） Arrays.sort(T[] array, Comparator&lt;? super T&gt; comparator) 使用自定义比较器，对数组元素进行排序（串行排序） Arrays.sort(Object[] array, int fromIndex, int toIndex) 对数组元素的指定范围进行排序（串行排序） 4、Arrays.parallelSort() 注意：其余重载方法与 sort() 相同 Arrays.parallelSort(T[] array) 对数组元素进行排序（并行排序），当数据规模较大时，会有更好的性能 5、Arrays.binarySearch() 二分查找 注意：在调用该方法之前，必须先调用sort()方法进行排序，如果数组没有排序， 那么结果是不确定的，此外如果数组中包含多个指定元素，则无法保证将找到哪个元素 Arrays.binarySearch(Object[] array, Object key) 使用 二分法 查找数组内指定元素的索引值 Arrays.binarySearch(Object[] array, int fromIndex, int toIndex, Object obj) 使用 二分法 查找数组内指定范围内的指定元素的索引值 6、Arrays.copyOf() Arrays.copyOf(T[] original, int newLength) 拷贝数组，其内部调用了 System.arraycopy() 方法，从下标0开始，如果超过原数组长度，会用null进行填充 7、Arrays.copyOfRange(T[] original, int from, int to) 拷贝数组，指定起始位置和结束位置，如果超过原数组长度，会用null进行填充 8、Arrays.equals(Object[] array1, Object[] array2) 判断两个数组是否相等，实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2) 9、Arrays.deepEquals(Object[] array1, Object[] array2) 判断两个多维数组是否相等，实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2) 10、Arrays.hashCode(Object[] array) 返回数组的哈希值 11、Arrays.deepHashCode(Object[] array) 返回多维数组的哈希值 12、Arrays.toString(Object[] array) 返回数组元素的字符串形式 13、Arrays.deepToString(Object[] array) 返回多维数组元素的字符串形式 14、Arrays.setAll(T[] array, IntFunction 12345Integer[] data = &#123;2, 3, 4, 5&#125;;// 第一个元素2不变，将其与第二个元素3一起作为参数x, y传入，得到乘积6，作为数组新的第二个元素// 再将6和第三个元素4一起作为参数x, y传入，得到乘积24，作为数组新的第三个元素，以此类推Arrays.parallelPrefix(data, (x, y) -&gt; x * y);System.out.println(Arrays.toString(data)); // [2, 6, 24, 120] 16、Arrays.spliterator(T[] array) 返回数组的分片迭代器，用于并行遍历数组 17、Arrays.stream(T[] array) 返回数组的流Stream，然后我们就可以使用Stream相关的许多方法了","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"正则表达式","date":"2019-08-31T02:37:46.000Z","path":"2019/08/31/正则表达式/","text":"正则表达式正则表达式就是以某种方式来描述字符串 可以用来匹配字符串来找到你需要的 String类的分隔split 和 replace方法可以放入正则表达式的参数 matches 匹配正则表达式的方法 符号定义基本书写符号 符号 符号 示例 解释 匹配输入 \\ 转义符 * 符号“*” * [ ] 可接收的字符列表 [efgh] e、f、g、h中的任意1个字符 e、f、g、h [^] 不接收的字符列表 [^abc] 除a、b、c之外的任意1个字符，包括数字和特殊符号 m、q、5、* | 匹配“|”之前或之后的表达式 ab|cd ab或者cd ab、cd ( ) 将子表达式分组 (abc) 将字符串abc作为一组 abc - 连字符 A-Z 任意单个大写字母 大写字母 限定符限定符将可选数量的数据添加到正则表达式，下表为常用限定符： 符号 含义 示例 示例 匹配输入 不匹配输入 * 指定字符重复0次或n次 (abc)* 仅包含任意个abc的字符串，等效于\\w* abc、abcabcabc a、abca + 指定字符重复1次或n次 m+(abc)* 以至少1个m开头，后接任意个abc的字符串 m、mabc、mabcabc ma、abc ? 指定字符重复0次或1次 m+abc? 以至少1个m开头，后接ab或abc的字符串 mab、mabc、mmmab、mmabc ab、abc、mabcc {n} 只能输入n个字符 [abcd]{3} 由abcd中字母组成的任意长度为3的字符串 abc、dbc、adc a、aa、dcbd {n,} 指定至少 n 个匹配 [abcd]{3,} 由abcd中字母组成的任意长度不小于3的字符串 aab、dbc、aaabdc a、cd、bb {n,m} 指定至少 n 个但不多于 m 个匹配 [abcd]{3,5} 由abcd中字母组成的任意长度不小于3，不大于5的字符串 abc、abcd、aaaaa、bcdab ab、ababab、a ^ 指定起始字符 ^[0-9]+[a-z]* 以至少1个数字开头，后接任意个小写字母的字符串 123、6aa、555edf abc、aaa、a33 $ 指定结束字符 ^[0-9]-[a-z]+$ 以1个数字开头后接连字符“–”，并以至少1个小写字母结尾的字符串 2-a、3-ddd、5-efg 33a、8-、7-Ab 匹配字符集匹配字符集是预定义的用于正则表达式中的符号集。如果字符串与字符集中的任何一个字符相匹配，它就会找到这个匹配项。 正则表达式中的部分匹配字符集: 符号 含义 示例 示例 匹配输入 不匹配输入 . 匹配除 \\n 以外的任何字符 a..b 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 aaab、aefb、a35b、a#*b ab、aaaa、a347b \\d 匹配单个数字字符，相当于[0-9] \\d{3}(\\d)? 包含3个或4个数字的字符串 123、9876 123、9876 \\D 匹配单个非数字字符，相当于[^0-9] \\D(\\d)* 以单个非数字字符开头，后接任意个数字字符串 a、A342 aa、AA78、1234 \\w 匹配单个数字、大小写字母字符，相当于[0-9a-zA-Z] \\d{3}\\w{4} 以3个数字字符开头的长度为7的数字字母字符串 234abcd、12345Pe 58a、Ra46 \\W 匹配单个非数字、大小写字母字符，相当于[^0-9a-zA-Z] \\W+\\d{2} 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 #29、#?@10 23、#?@100 分组构造常用分组构造形式: 常用分组构造形式 说明 () 非命名捕获。捕获匹配的子字符串（或非捕获组）。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 (?) 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如 (?’name’) 字符转义如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\。当然，要查找\\本身，你也得用\\ 例如：deerchao.net匹配deerchao.NET，C:\\Windows匹配C:\\Windows。注意在Java中: (https://github\\\\.com/[\\\\w\\\\-]) 用”\\.”配备”.”。 常用正则表达式举例 非负整数：“^\\d+$ ” 正整数： “ ^[0-9][1-9][0-9]$” 非正整数： “ ^((-\\d+)|(0+))$” 整数： “ ^-?\\d+$” 英文字符串： “ ^[A-Za-z]+$” 英文字符数字串： “ ^[A-Za-z0-9]+$” 英数字加下划线串： “^\\w+$” E-mail地址：“^[\\w-]+(.[\\w-]+)*@[\\w-]+(.[\\w-]+)+$” URL：“^[a-zA-Z]+://(\\w+(-\\w+))(.(\\w+(-\\w+)))(?\\s)?$” Petteren 和 MatcherPattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可 以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, CharSequence 接口有 CharBuffer,String,StringBuilder,StringBuffer Pattern类详解 Pattern表示编译后的正则表达式 Pattern 12345678910111. static Pattern compile(String regex) //将给定的正则表达式编译并赋予给Pattern类2. static Pattern compile(String regex, int flags) //同上，但增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ 3. int flags() //返回当前Pattern的匹配flag参数. 4. String[] split(CharSequence input) 分隔字符串 //快速判断匹配 5.Pattern.matcher(String regex,CharSequence input)//返回一个Matcher对象6.Pattern.matcher(CharSequence input) Matcher对象 123456789101112131415161718192021222324252627282930313233matches()Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.matches();//返回false,因为bb不能被\\d+匹配,导致整个字符串匹配未成功. Matcher m2=p.matcher(\"2223\"); m2.matches();//返回true,因为\\d+匹配到了整个字符串1. Pattern.matcher(String regex,CharSequence input),它与下面这段代码等价 Pattern.compile(regex).matcher(input).matches()2. matches是整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。但如果前部分匹配成功，将移动下次匹配的位置。2.lookingAt()Matcher m=p.matcher(\"22bb23\"); m.lookingAt();//返回true,因为\\d+匹配到了前面的22 Matcher m2=p.matcher(\"aa2223\"); m2.lookingAt();//返回false,因为\\d+不能匹配前面的aa lookingAt是部分匹配，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串 while (m.find()) &#123; matcher.start(); matcher.end(); matcher.group(1);&#125;1. find()是部分匹配，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。2. find()从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。 https://www.cnblogs.com/ggjucheng/p/3423731.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"泛型","date":"2019-08-31T01:34:09.000Z","path":"2019/08/31/泛型/","text":"泛型是什么？一般的类和方法，只能使用具体的类型，要么是自定义的类，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大,所有要使代码应用于“某种不具体的类型”， 于是引入了泛型 泛型实现了参数化类型的概念，使代码可以应用于多种类型 “泛型”意思就是适用于许多类型 一般我们是用Object类来存储任何类型 123456789101112public class Demo &#123; Object value; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125; &#125; 这样使用,只不过要的到具体类型时，需要强制转换 12345Demo demo = new Demo();demo.setValue(111); //自动装箱成Integer类型int value = (int) demo.getValue();demo.setValue(\"123\");String s = (String) demo.getValue(); 泛型却给我们带来了全新的编程体验 12345678910111213141516171819202122public class Demo&lt;T&gt; &#123; T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; public static void main(String[] args) &#123; Demo&lt;Integer&gt; demo = new Demo&lt;Integer&gt;(); demo.setValue(123); int value = demo.getValue(); Demo&lt;String&gt; demo1 = new Demo&lt;String&gt;(); demo1.setValue(\"123\"); String value1 = demo1.getValue(); // demo1.setValue(123); 错误 编译无法通过 &#125;&#125; 泛型除了可以将类型参数化外，而参数一旦确定好，如果类似不匹配，编译器就不通过。 所以，综合上面信息，我们可以得到下面的结论。 与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。 当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。 泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 Cache这个类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。 泛型方法原则：无论何时，只要你能做的，就尽可能使用泛型方法 要定义泛型方法,只需将泛型参数列表置于返回值之前 123public &lt;T&gt; T f() &#123;&#125;; 这是泛型方法；public int f（T a）&#123;&#125;；这不是泛型方法，返回值前无泛型。 泛型接口12public interface Iterable&lt;T&gt; &#123;&#125; 擦除1234List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();List&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;(); System.out.println(l1.getClass() == l2.getClass()); 打印的结果为 true 是因为 List和 List在 jvm 中的 Class 都是 List.class。泛型信息被擦除了。 可能同学会问，那么类型 String 和 Integer 怎么办？ 答案是泛型转译。 jvm并不认识泛型因此需要将泛型擦除。 ArrayList 和 ArrayList很容易被认为是不同类型。因为他们有不同的行为，但程序却认为他们是相同的，正是因为擦除的存在。 擦除的结果就是把一个对象变为它的原生类, 在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 则会被转译成普通的 Object 类型，如果指定了上限如 则类型参数就被替换成类型上限 即String。 泛型只是用来检查类型正确性，泛型部分的代码不会参与运行，这是由于泛型的擦除作用。 泛型代码内部无法获得有关泛型参数的类型的信息。 泛型的局限性 LIst list=new ArrayList&lt;&gt;(); list.add() 方法只能加入 Integer类型的 只是因为泛型的存在，让编译器有了限制 但实际上 List 接口中的 add(T t) 方法 被擦除为 add(Object obj) 我们可以用反射来绕过编译器的检查。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"异常","date":"2019-08-31T01:21:07.000Z","path":"2019/08/31/异常/","text":"JAVA的基本理念是结构不佳的代码不能运行 1：概念程序在运行时出现的错误 使用异常的好处能够降低错误处理代码的复杂度,只需要异常机制来捕获这个错误，然后处理，而且把正常的情况和非正常的处理代码相互隔离 2：基本异常异常情形是指阻止当前方法或者作用域继续执行的问题 抛出异常指：当前不解决问题，将问题交给上一级 throw new NullPointerException() 抛出异常后发生的事情 1）会在堆上 new 异常对象 2）当前的执行路径会终止，并且弹出异常的引用 3）异常处理机制会接管程序 4）异常处理程序会在特定的地方执行 使程序能从错误中恢复，或者以另一种方式运行或继续运行下去 异常会让我们（如果没有其他手段）强制程序（当前线程）停止，并告诉我们出现了什么问题，或者处理异常，并返回稳定状态 异常参数： 异常对象与其他对象一样，有两个构造器，默认构造器和字符串为参数的构造器 throw new NullPointerException(“t = null”) 其中throw 相当于”放回“这个异常对象 能够抛出任意类型的Throwable对象，它是异常类型的根类 3：捕获异常12345try&#123;&#125;catch(Type1 id1 )&#123;&#125; try块 捕获抛出的异常 catch 异常处理程序 可以有多个来处理不同的异常 对捕获的对应的异常Type1 id1进行处理 4：创建自定义的异常继承Exception异常类 有默认的构造器和 字符串参数的构造器就行 *异常以及记录日志 * 5：异常的说明 属于方法声明的一种 在方法后面 throws 异常列表 (相当于抛出异常将该方法的异常让别人理) 6：捕获所有的异常在catch(Exception e) 捕获异常的基类 放在最后一个catch，防止抢在其他具体异常处理前面 栈轨迹 printStackTrace（） 返回一个轨迹栈中元素所构成的数组，每个元素对应栈的一个栈帧第一 个方法在栈顶，最后在栈低，捕获后，重新抛出异常 throw Exception() 123456789Throwable的方法String getMessage() 获取详细信息String getLocalMessage() 用本地语言描述的详细信息String toString()简单描述fillInStackTrace(),原来异常点消失，只剩下新的抛出点信息（比如你捕获一个异常 然后从新把它抛出 可以调用这个方法） 异常链 在捕获一个异常后，抛出另一个异常，并且把原始异常信息保存下来，Throwable的子类在构造中可以接受一个 cause对象（原始的异常也是Throwable类）这样就可以将元素的异常传递个新的异常，可以通过最新的异常来递归的跟踪到原始的异常 7:JAVA标准异常 Throwable：任何可以作为异常抛出的类 Error：编译和系统错误 Exception，可抛出的基本类型 特例RuntimeException 运行时异常，不需要再声明方法中抛出，也被称为 不受检查异常，这种异常属于错误，将自 动捕获 务必记住：只能在代码中忽略RuntimeException及其子类的异常，其他类型的异常由编译器 强制实施的，究其原因，RuntimeException代表编程错误，无法预料的错误， 8：使用finally进行清理在运行完try 或者 catch 后必须执行的操作，一定执行的操作 123456789int i=1;try &#123; int x=1/0;&#125; catch (Exception e) &#123; return i;&#125;finally &#123; return -1;&#125; 上面代码返回的是 -1，因为finally中的return 会覆盖掉之前的 可以用来释放资源 如关闭一些流，即使在前面有return，finally也会执行，除非是 exit(0) 缺憾：异常丢失：前一个异常还没处理就抛出了下一个异常 9：异常的匹配系统会自动的找到最近的处理程序 catch块 1234567891011try&#123;&#125;catch（Type1 id1）&#123;&#125;catch(Type2 id2)&#123;&#125;...&#125;finally&#123;&#125; 在try捕获到异常会自上到下逐一的匹配 异常然后执行相应的catch，就结束执行finally了 把最大的放在后面 Exception ,如果放前面 会覆盖后面的 从而不知道具体的异常了 10：其他可选方式把异常给控制台 在main 抛出异常 throws 把被检查异常，转换成 不检查异常 将抛出了异常 e 用RuntimeException封装并且抛出","tags":[{"name":"java基础","slug":"java基础","permalink":"http://cxqiang.gitee.io/blog/tags/java基础/"}]},{"title":"内部类","date":"2019-08-30T14:27:30.000Z","path":"2019/08/30/内部类/","text":"内部类：将一个类定义在另一个类的定义内部1：创建内部类也是用class 关键字在类的内部创建个class类 不过，如果想从外部类的非静态方法之外的任意位置创建某个内部类对象，必须指明这个对象的 类型 OuterClassName.InnerClassName 2:链接到外部类当生成一个内部类对象时，此对象能访问外围对象的所有成员 指明做到的：某个外围累的对象创建一个内部类时，内部类的对象会秘密的获取外部类对象的一 个引用 3：使用.this 和 .new当你需要使用外部对象的引用时，可以用外部类的名称加 .this 当你创建外部类的对象的时候 可以用外部类的引用来调用 .new 加内部类的构造器 12345678910111213141516171819202122232425262728293031Inner i= new Outer().new Inner();即Outer o=new Outer();Inner i= o.new Inner();//静态内部类可以直接访问package com.xiaoqiang.day10;/** * @author xiaoqiang * @date 2019/7/13-15:26 */public class Outer &#123; public static class Inner &#123; public void f() &#123; System.out.println(\"静态内部类\"); &#125; &#125; public static void main(String[] args) &#123; Inner i = new Inner(); i.f(); &#125;&#125; 必须使用外部类的对象来创建内部类的对象 但是静态内部类，可直接访问 4：内部类向上转型当内部类被声明为 private时 除了在外部类的方法内部和它自己，没人访问他 设为protected 则只有子类和同包的能访问 5：在方法和作用域中的内部类场景：你实现了某个接口，想要返回这个类型 需要解决复杂的问题，需要用到这个类但不希望它是公共的 成员内部类：有权限修饰符,也可以是静态的，但是不能访问外部类中非静态的成员 12345public class Outer &#123; /*static*/ class Inner &#123; &#125;&#125; 局部内部类：在方法里面的类，类是方法的一部分，在方法（域）之外是不能访问的，当然你可以return这个类的基类引用，在方法内 定义的类，不能有修饰访问符，public等，可以访问外部内所有成员 123456789public class Outer &#123; public void method() &#123; class Inner &#123; &#125; Inner i = new Inner(); &#125; //方法外就无法访问到了&#125; 匿名内部类：就是在方法返回时 return new Content(){ （可以是带有参数的构造器） //定义者个类 }; 1234567891011121314151617interface Demo &#123; void fun();&#125;public class Outer &#123; public static void main(String[] args) &#123; int i=0; Object x = new Object(); Demo demo = new Demo() &#123; @Override public void fun() &#123;// i++; 不想修改,默认为为final System.out.println(i); &#125; &#125;; &#125;&#125; 例如我们经常使用的 创建线程任务的时候就经常用到匿名内部类 在匿名内部类中，希望它使用一个在外部定义的对象，那么要求 方法的参数必须为final的 即使（JAVA8）已经不强制添写final，但当你修改的时候回报错。 为什么加final，防止外部类的引用改变了，而内部类中的没改变， 简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。 ​ 故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。 在匿名内部类中使用 则参数 要为 final 在匿名内部类中的基类使用 不要 匿名内部类中没有构造器（因为它没有名字），一般用构造代码块来初始类 { 。。。} 匿名内部类为扩展类可以实现接口和继承类 ，但也只能实现一个接口 匿名内部类中不能存在任何的静态成员变量和静态方法 6：工厂方法我们可以用匿名内部类来返回实例 7：嵌套类（静态内部类）如果不需要让内部类对象与外围类对象有关联的话，可以将内部类声明为static，这就称为嵌套类 1）要创建嵌套类的对象，并不需要访问外部类对象 2）不能访问非静态的外围类成员 普通内部类的字段和方法不能声明为 static，不能包含嵌套类 而嵌套类可以 接口内部类；默认也是 static public ，在创建某些公共代码，使他们被某个接口的不同实现来使用 8：为什么需要内部类：1）内部类提供了进入其外围类的窗口 2）内部类能独立的继承某个类（接口的）实现，无论外围类怎么样，对内部类没影响 特性： 1）内部类可以多个实例，每个实例可以有自己的状态信息，并且与外围类相互独立的 2）在单个外围类中可以让多个内部类以不同的方式实现同一个接口 3）内部类对象创建的时候不依赖外围类对象的创建 4）是一个独立的实体 闭包和回调 闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域 .内部类和控制框架 控制框架的完整实现是有单个创建的，从而使的实现的细节被封装起来 内部类能容易的访问外围类的任意成员 9:内部类的继承因为内部类的构造器必须连接其他外围类的对象引用，所以继承内部类，必须把外围类对象的引 用初始化用外围类的参数传递，调用 Outer.super() 10:内部类可以被覆盖吗？不会，每个内部类都是个独立的存在","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"面向对象与面向过程","date":"2019-08-29T13:43:52.000Z","path":"2019/08/29/面向对象与面向过程/","text":"1：面向对象编程 OOP Object-oriented Programming 万物皆对象 程序是对象的集合，它们通过发送消息来告知彼此所要做的 每个对象都有自己的有其他对象所构成的存储 每个对象都有其类型 某一特定类型的所有对象都可以接受同样的消息 对象具有自己的状态（内部数据）， 行为（方法），标识（内存地址） 2：面向对象与面向过程面向过程：你拿扫帚去打扫房间，主体是你，取扫帚，大扫地，一系列动作都需要你自己完成； 面向对象：把扫地机器人当成主体对象，相当于个活物，机器人主动去打扫卫生，至于如何打扫完，跟你没关系。 因此，面向过程，是人在干活。面向对象，相当于人创造机器人去干活。 站在计算机程序角度来讲，面向过程和面向对象的本质理解为： 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 总的来说：面向对象是将事物高度抽象化，面向对象必须先建立抽象模型，之后直接使用模型就行了；面向过程是一种自顶向下的编程 3、面向对象的特征封装: 隐藏对象属性和实现的细节，仅向外提供公共访问的接口 继承：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 多态：一个对象在程序不同运行时刻有多个不同状态，父类或者接口的引用指向子类对象","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"多态","date":"2019-08-29T13:43:26.000Z","path":"2019/08/29/多态/","text":"多态：同一个行为具有多个不同表现形式或形态的能力1：向上转型对象可以作为它自己本身的类型使用,也可以作为它的基类类型使用，而将某个对象的引用视为对 其基类型的引用的做法，被称为向上转型 （子类-&gt;基类） 忘记对象类型:用基类来传参 2：转机将一个方法调用和一个方法主体关联起来叫做绑定 前期绑定：程序执行前进行绑定（由编译器和连接程序实现 如 C） 后期绑定：在运行时根据对象的类型进行绑定，也叫动态绑定或运行时绑定 JAVA中除了static和final方法都是后期绑定 因此将方法定义为 final 即private的可以关闭动态绑定产生正确的行为 若导出类覆盖了基类的接口，由于后期绑定的机制即时是基类的引用但对象是导出类的还是会调用导出类的方法，所以编写代码可以与只基类打交道 可扩展性：只与基类接口通信，这样可以覆盖然后不用管新有什么类型，就可以通过基类的引用调用子类的覆盖的方法，那些操纵基类的方法接口不需要做任何的改动 缺陷：“覆盖”私有方法： 对于私有的方法是不能覆盖的 域与静态方法和字段域不具有多态，**如果某个方法是静态的，它是行为不具有多态性**3：构造器与多态构造器实际上是static方法，不过声明是隐形的 构造器的调用顺序 调用基类的构造器 按声明顺序调用成员的初始化方法 调用构造器的主体 123456789101112131415161718192021222324252627282930313233343536373839package com.xiaoqiang.day_7_11;/** * @author xiaoqiang */public class Glyph &#123; void draw() &#123; System.out.println(\"Glyph.draw()\"); &#125; Glyph() &#123; //1 先初始化父类 调用父类构造器 System.out.println(\"Glyph() before draw()\"); //2 draw(); //因为多态 调用的是子类覆盖的方法 即子类的draw 3 System.out.println(\"Glyph() after draw()\"); //4 &#125;&#125;class RoundGlyph extends Glyph &#123; private int radiu = 1; //5 RoundGlyph(int r) &#123; radiu = r; //6 System.out.println(\"RoundGlyph.RoundGlyph(),radius = \"+ radiu);//7 &#125; void draw() &#123; //3 在父类构造器中调用了，此时radiu还为被初始化，所有为0 System.out.println(\"RoundGlyph.draw(),radius = \" + radiu); &#125;&#125;输出是Glyph() before draw()RoundGlyph.draw(),radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(),radius = 5 构造器内部多态方法的行为初始化的顺序是 在其他任何事物都没有发生之前，讲分配给对象存储空间初始化为二进制的0 赋初值 如前所诉那样先调用基类构造器，此时，调用被覆盖后的draw（）方法（会在导出类构造方法 之前调用），会由于步骤1的原因，会发现 变量radius为0 按声明的顺序调用成员的初始化方法 调用用导出类的构造器 所以在构造器中尽可能的避免调用其他的方法，唯一能安全调用的是final（private）方法，因为 这些方法是不能被覆盖的 4：协变返回类型 方法中可以返回它与其子类5：用继承来进行设计用继承表达行为间的差异，并用字段表达状态上的变化 6：纯继承以扩展导出类与基类有着相同的接口 缺点:导出类中的接口的扩展部分不能被基类访问，因此我们一旦向上转型，就不能调用导出类的","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"继承","date":"2019-08-29T13:43:19.000Z","path":"2019/08/29/继承/","text":"1、概念：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 即导出类继承了 父类（基类）的所有成员与接口（尽管private但是不能访问和使用） 当继承现有类时，也就是创造了新的类型，这个新的类型（导出类具有和基类相同的类型） 2：继承语法关键词： extends ​ 会自动的得到基类中所有的域和方法（尽管private但是不能访问和使用） ​ super 基类（父类）的引用 初始化基类 构造过程是从基类向外扩散的，所以是先初始化基类然后是子类 当父类有带参数的构造器时，用super调用 super(参数) 3：特点单根继承结构 所有都继承与一个终极基类 Object 好处 可以在每个对象上执行某些基本操作 tostring等方法 所有对象都很容易在堆上创建 参数的传递也得到了极大的简化 使垃圾回收器的实现变得容易得多 由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局，这对于系统级操作（如异常处理）显得尤为重要 4、继承的好处： 继承提高了代码的复用性 继承的出现让类与类产生了关联，提供了多态的前提 5、父子类中成员的关系成员变量 成员方法 构造方法 子类实例化时，必须先实例化父类对象(默认是调用父类的无参构造器即 super（）),而且是在子类构造器 第一行代码 写上 super（） 若是有参构造器,则 super(2）带上对应的参数 重写与重载 重载：同一个类中，方法名相同，参数列表不同，重载可以改变返回类型 重写/覆盖 ： 在不同类中(子父类）,方法的名称，参数，返回值都相同 ​ 为了满足里式替换原则，重写有以下三个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 6、this和super关键字 this代表子类本身引用 super代表 父类的引用","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"封装","date":"2019-08-29T13:43:13.000Z","path":"2019/08/29/封装/","text":"1、概念封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。 2、好处 比如我们常用将类的属性设置为private的，然后通过get set方法来访问 良好的封装能够减少耦合。 外部只能通过 暴露的接口访问类的信息（get，set方法） 类内部的结构可以自由修改。 当你要修改 类中的一个日期Date型 问 String时 可以对成员进行更精确的控制。 比如说对 年龄age属性现在 可以在 set方法里 设置 if(age&gt;100|| age&lt;0) 抛出异常 隐藏信息，实现细节。 可以对外不提供一些属性的 get等外部访问方法，从而隐藏信息","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"接口和抽象类","date":"2019-08-29T13:42:59.000Z","path":"2019/08/29/接口和抽象类/","text":"1：抽象类和抽象方法** 抽象类，包含抽象方法的类，在包含抽象方法时，必须在类前面声明为 abstract class** 抽象类中可以包含普通的方法 其导出类必须实现抽象方法,否则其导出类 也必须声明为 抽象类 抽象方法：方法前面声明为 abstract，并且没有方法体 包含抽象方法的类叫抽象类 抽象类 可以包含抽象方法和普通方法 但是普通的类不能包含抽象方法 作用：使类抽象性明确起来，并告诉用户和编译器如何使用它 2：接口：使抽象的概念更迈进一步关键字：interface interface不仅仅是一个极度抽象的类，还允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多继承变种的特性 interface这个关键字产生了一个完全抽象的类，只提供了形式而没有任何的实现 所有方法必须（自动的）是public 就像类一样 将class 用interface代替 也有访问权限的 public private 包访问 在接口中的字段 默认都是并且只能是 public static final的 方法必须是 public 的抽象方法（不能有方法体） 接口中不能有 代码块 {} 不管是不是static的 接口的实现：implements 抽象类是什么：抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。 (1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法 (2) 抽象类不能被实例化 (3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类 (4) 具体派生类必须覆盖基类的抽象方法 (5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们 接口是什么：(1) 接口不能被实例化 (2) 接口只能包含方法声明 (3) 接口的成员包括方法、属性、索引器、事件 (4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员 接口和抽象类的区别：（1）抽象类可以有构造方法，接口中不能有构造方法。 （2）抽象类中可以有普通成员变量，接口中没有普通成员变量 （3）抽象类中可以包含静态方法，接口中不能包含静态方法 （4） 一个类可以实现多个接口，但只能继承一个抽象类。 （5）接口可以被多重实现，抽象类只能被单一继承 （6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法 接口和抽象类的相同点：(1) 都可以被继承 (2) 都不能被实例化 (3) 都可以包含方法声明 (4) 派生类必须实现未实现的方法","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"类与对象","date":"2019-08-29T13:42:47.000Z","path":"2019/08/29/类与对象/","text":"1：什么是对象 可谓万物皆对象，对象是客观存在的的事物，可以说任何客观存在都可以成为对象，(一台电脑,一只笔，一辆车)，对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 每个对象都提供服务 高内聚低耦合 ​ 高内聚就是说相关度比较高的部分尽可能的集中，不要分散 ​ 低耦合就是说两个相关的模块尽可以能把依赖的部分降低到最小，不要让两个系统产生强依赖 2: 什么是类呢？ ​ 类就是对象的模板，它描述一类的对象的行为（方法）状态（属性） ​ 而对象就是类的一个实例","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"this和super关键字","date":"2019-08-29T13:25:58.000Z","path":"2019/08/29/this_super/","text":"1. this this是自身的一个对象，代表对象本身，可以理解为：当前对象的引用。只能在方法内部使用 应用* 引用当前对象的成员变量和方法 * 引用类的构造器 this(参数) * 返回对象的值 return this注意：在构造器中调用构造器* 不能调用两个构造器，必须将构造器调用在起始位置，除了构造器外禁止在其他任何方法中调用构造器 2. super​ super是父类的一个对象，代表离自己最近的一个父类，可以理解为：父类的引用。只能在方法内部使用 应用 与this类似，应用父类的成员变量和方法 子类中的成员变量或方法与父类中的成员变量或方法同名123456789package demo;public class Country &#123; String name; void value() &#123; name = \"China\"; &#125;&#125; 123456789101112131415161718package demo;public class City extends Country&#123; String name; void value() &#123; name = \"Shanghai\"; super.value(); // 调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c = new City(); c.value(); &#125;&#125; 这输出的是Shanghai China可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 引用类的构造器 super(参数) （必须在构造器代码的第一行，默认都有父类构造器 super()在代码第一行的，若有参数就要显示的写出了）","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"权限修饰符","date":"2019-08-29T13:18:39.000Z","path":"2019/08/29/权限修饰符/","text":"权限修饰符私有的权限private： private 可以修饰 数据成员，构造方法，方法成员，可以修饰成员内部类，被private修饰的成员，只能在定义了它们的类中使用，在其他的类中不能被调用，私有的，创建者和内部使用 默认权限：（default） 可修饰，类，数据成员，构造方法，方法成员，使用默认的权限，即不写任何的关键字，默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包 的类中被调用，且子类不能访问 （除非子类和它是在同一个包里面） 受保护的权限 protected protected可以修饰 数据成员，构造方法，方法成员，可以修饰成员内部类，被 protected修饰得到成员，被protected修饰的成员，能在定义它们的类中，同包 的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。 公有的权限 public 可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。 注意： 并不是每个修饰符都可以修饰类（指外部类），只有public和default可以。 所有修饰符都可以修饰数据成员，方法成员，构造方法。 在private放在构造器前面你不能调用new来创建对象：应用：单例模式 为了代码安全起见，修饰符不要尽量使用权限大的，而是适用即可。比如，数据成员，如果没有特殊需要，尽可能用private。 修饰符修饰的是“被访问”的权限。 为什么要权限控制 为了不让客户端触及和修改 为了让类库设计者可用更改类的内部工作方式，而不必担心会对用户造成影响。","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"static","date":"2019-08-29T12:54:11.000Z","path":"2019/08/29/static/","text":"static 在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。 同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。 静态方法- static方法就是没有this的方法。**在static方法内部不能调用非静态方法，反过来是可以的。**而且可以在没有创建任何对象的前提下，仅仅**通过类本身来调用static方法**。这实际上正是static方法的主要用途。 在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。但是在非静态方法中可以访问静态成员的 只能访问static变量 静态变量 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static变量并不是所在类的某个具体对象所有，而是该类的所有对象所共有的，静态变量既能被对象调用，也能直接拿类来调用。 静态代码块 static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 误区 static关键字并不会改变变量和方法的访问权限。只有private,public,protected,(包访问)才能改变其访问权限 在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够） 在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。 static和final一块用表示什么？ 1. static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！ 2. 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 3. 对于方法，表示不可覆盖，并且可以通过类名直接访问。 static的局限1. 它只能调用static变量。 2. 它只能调用static方法。 3. 不能以任何形式引用this、super。 4. static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。总结： 无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"final","date":"2019-08-29T12:31:13.000Z","path":"2019/08/29/final/","text":"finalfinal关键字在java中有“这是无法改变的”或者“终态的”含义，可以修饰类(非抽象的)，方法(非抽象的)，变量 final类不能被继承，没有子类，final类中的方法默认都是final的 final方法不能被子类覆盖，但可以被继承调用 final变量表示为常量，只能被赋值一次，赋值后值不在修改 final不能用于修饰构造方法 1. final类​ final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。我们见到的String类就是final类 2. final方法​ 把方法锁定，以防任何继承类修改它的含义，不能重载覆盖 ​ 注意：类的private方法会隐式地被指定为final方法 3. final变量 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 修饰成员变量时必须在定义或者构造器中赋值初始化(空白final) 修饰普通变量时必须赋值才能使用 4. final参数​ 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。 5. 应用- 一个永不改变的编译时常量 - 一个在运行时被初始化的值，不希望你改变他","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"visitor","date":"2019-08-29T07:50:38.000Z","path":"2019/08/29/访问者模式/","text":"模式动机： – 对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接 口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访 问者其访问方式也有所不同。 • 定义： – 表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变个元素 的类的前提下定义作用于这些元素的新操作。 • 开发中的场景(应用范围非常窄，了解即可)： – XML文档解析器设计 – 编译器的设计 – 复杂集合对象的处理","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"模板方法模式","date":"2019-08-29T07:50:25.000Z","path":"2019/08/29/模板方法模式/","text":"介绍： 模板方法模式是编程中经常用得到模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义改算法的某些特定的步骤 核心： 处理某个流程的代码已经具备，但是其中某个节点的代码暂时不能确定，因此，我们采用工厂方法的模式，将这个节点的代码实现转移给子类完成，即：处理步骤父类定义好，具体实现延迟到子类中定义 1234567891011121314151617181920212223242526package com.xiaoqiang.gof23.actionnModel.templateMethod;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public abstract class BankTemplteMethod &#123; // 具体的方法 public void takeNumber() &#123; System.out.println(\"排队取号\"); &#125; //这个方法具体实现 在子类中 而排队和反馈都是一样的 public abstract void tranact(); public void evaluate() &#123; System.out.println(\"反馈评分\"); &#125; // 模板方法 父类给出了具体的步骤 取号 操作 反馈 public final void process() &#123; this.takeNumber(); this.tranact(); this.evaluate(); &#125;&#125; 1234567891011121314package com.xiaoqiang.gof23.actionnModel.templateMethod;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class DrawMoney extends BankTemplteMethod &#123; @Override public void tranact() &#123; System.out.println(\"我要取款\"); &#125;&#125; 客户端 1234567891011121314151617181920212223package com.xiaoqiang.gof23.actionnModel.templateMethod;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; BankTemplteMethod btm = new DrawMoney(); btm.process();// 或者采用用匿名内部类 BankTemplteMethod bankTemplteMethod = new BankTemplteMethod() &#123; @Override public void tranact() &#123; System.out.println(\"我要存钱\"); &#125; &#125;; bankTemplteMethod.process(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"策略模式","date":"2019-08-29T07:50:13.000Z","path":"2019/08/29/策略模式/","text":"策略模式（strategy） 软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据应用场景的不同选择不同的算法或者策略来完成该功能。把一个类(A)中经常改变或者将来可能改变的部分提取出来，作为一个接口(B)，然后在类(A)中包含这个接口(B)，这样类(A)的实例在运行时就可以随意调用实现了这个接口的类(C)的行为。比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式 场景：– 某个市场人员接到单后的报价策略(CRM系统中常见问题)。报价策略 很复杂，可以简单作如下分类： • 普通客户小批量报价 • 普通客户大批量报价 • 老客户小批量报价 • 老客户大批量报价– 具体选用哪个报价策略，这需要根据实际情况来确定。这时候，我们采用策略模式即可。 抽象的策略123456789package com.xiaoqiang.gof23.actionnModel.strategy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public interface Strategy &#123; public double getPrice(double standerdPrice);&#125; 少量新用户12345678910111213141516package com.xiaoqiang.gof23.actionnModel.strategy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class NewCustomerFewStrategy implements Strategy&#123; @Override public double getPrice(double standerdPrice) &#123; System.out.println(\"普通用户少量，原价不打折\"); return standerdPrice; &#125;&#125; 大量新用户12345678910111213141516package com.xiaoqiang.gof23.actionnModel.strategy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class NewCustomerManyStrategy implements Strategy&#123; @Override public double getPrice(double standerdPrice) &#123; System.out.println(\"普通用户大批量，打九折\"); return standerdPrice*0.9; &#125; &#125; 老用户少量12345678910111213141516package com.xiaoqiang.gof23.actionnModel.strategy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class OldCustomerFewStrategy implements Strategy&#123; @Override public double getPrice(double standerdPrice) &#123; System.out.println(\"老用户少量，不打八五折\"); return standerdPrice * 0.85; &#125;&#125; 老用户大量12345678910111213141516package com.xiaoqiang.gof23.actionnModel.strategy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class OldCustomerManyStrategy implements Strategy&#123; @Override public double getPrice(double standerdPrice) &#123; System.out.println(\"老用户大批量，打八折\"); return standerdPrice*0.8; &#125; &#125; 根据策略菜用不同的算法1234567891011121314151617181920package com.xiaoqiang.gof23.actionnModel.strategy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) *///与具体的策略类交互，具体的算法与客户端分离，算法可独立的变化public class Context &#123;// 当前采用的算法对象 private Strategy strategy;//通过构造器或set方法来注入 具体的算法类，配置文件动态注入 spring public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public void printPrice(double s) &#123; System.out.println(\"给你的报价是\" + strategy.getPrice(s)); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"状态模式","date":"2019-08-29T07:50:03.000Z","path":"2019/08/29/状态模式/","text":"状态模式（State） 对象行为的变化是由于状态的变化引入，那么即当内部状态发生变化的时候，就会改变对象的行为，而这种改变视乎就改变了整个类。 123456789101112131415161718192021222324252627282930package com.xiaoqiang.gof23.actionnModel.state;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 状态类 */public interface State &#123; void handle();&#125;package com.xiaoqiang.gof23.actionnModel.state;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 房间类 */public class Home &#123; private State state; public void setState(State state) &#123; System.out.println(\"修改状态\"); this.state = state; state.handle(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.xiaoqiang.gof23.actionnModel.state;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class FreeState implements State &#123; @Override public void handle() &#123; System.out.println(\"房间空闲，没人住\"); &#125;&#125;package com.xiaoqiang.gof23.actionnModel.state;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class BookedState implements State &#123; @Override public void handle() &#123; System.out.println(\"房间有人预定了\"); &#125;&#125;package com.xiaoqiang.gof23.actionnModel.state;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class CheckedState implements State &#123; @Override public void handle() &#123; System.out.println(\"'有人住了\"); &#125;&#125; 12345678910111213package com.xiaoqiang.gof23.actionnModel.state;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; Home home = new Home(); home.setState(new FreeState()); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"observer","date":"2019-08-29T07:49:55.000Z","path":"2019/08/29/观察者模式/","text":"","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"备忘录模式","date":"2019-08-29T07:49:46.000Z","path":"2019/08/29/备忘录模式/","text":"录入大批人员资料。正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改。– Word文档编辑时，忽然电脑死机或断电，再打开时，可以看到word提示你恢复到以前的文档– 管理系统中，公文撤回功能。公文发送出去后，想撤回来。 核心– 就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。• 结构：– 源发器类Originator– 备忘录类Memento– 负责人类CareTaker 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.xiaoqiang.gof23.actionnModel.memento;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 源发器类 员工信息 */public class Emp &#123; private String name; private int age; private double salary; //备忘操作，并返回备忘录对象 public EmpMemento memento() &#123; return new EmpMemento(this); &#125; // 进行数据恢复，恢复成备忘录对象的值 public void recoveryMemento(EmpMemento mmt) &#123; this.name = mmt.getName(); this.age = mmt.getAge(); this.salary = mmt.getSalary(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Emp(String name, int age, double salary) &#123; this.name = name; this.age = age; this.salary = salary; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.xiaoqiang.gof23.actionnModel.memento;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * * 备忘器类 */public class EmpMemento &#123; private String name; private int age; private double salary; public EmpMemento(Emp emp) &#123; this.name = emp.getName(); this.age = emp.getAge(); this.salary = emp.getSalary(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125;&#125; 123456789101112131415161718192021package com.xiaoqiang.gof23.actionnModel.memento;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * &lt;p&gt; * 负责人类 * 管理备忘录对象 */public class CareTaker &#123;// 保存多次 用 List Stack 序列化持久化 private EmpMemento empMemento; public EmpMemento getEmpMemento() &#123; return empMemento; &#125; public void setEmpMemento(EmpMemento empMemento) &#123; this.empMemento = empMemento; &#125;&#125; 123456789101112131415161718192021222324252627package com.xiaoqiang.gof23.actionnModel.memento;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; CareTaker careTaker = new CareTaker(); Emp emp = new Emp(\"我\", 18, 900); System.out.println(\"创建对象\" + emp.getName() + \"----\" + emp.getAge() + \"---------\" + emp.getSalary());// 备份 careTaker.setEmpMemento(emp.memento()); emp.setName(\"你\"); emp.setAge(38); emp.setSalary(1000); System.out.println(\"修改对象\" + emp.getName() + \"----\" + emp.getAge() + \"---------\" + emp.getSalary()); emp.recoveryMemento(careTaker.getEmpMemento()); System.out.println(\"恢复对象\" + emp.getName() + \"----\" + emp.getAge() + \"---------\" + emp.getSalary()); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"中介模式","date":"2019-08-29T07:49:28.000Z","path":"2019/08/29/中介模式/","text":"中介者模式（Mediator）生活中的场景：房产中介（你要租房直接和中介讲，让他去联系房主），总经理（各个公司部门直接的交流合作就通过他） 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Mediator接口12345678910111213141516171819202122232425262728293031323334353637package com.xiaoqiang.gof23.actionnModel.mediator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public interface Mediator &#123;// 注册让中介管理部门 void register(String dname, Department department);// 命令操作某个部门 void command(String dname);&#125;package com.xiaoqiang.gof23.actionnModel.mediator;import java.util.HashMap;import java.util.Map;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class President implements Mediator &#123; private Map&lt;String, Department&gt; map = new HashMap&lt;&gt;(); @Override public void register(String dname, Department department) &#123; map.put(dname, department); &#125; @Override public void command(String dname) &#123; map.get(dname).selfAction(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.xiaoqiang.gof23.actionnModel.mediator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public interface Department &#123; // 做本部门的事情 void selfAction(); // 向总经理发送申请 void outAction();&#125;//技术部package com.xiaoqiang.gof23.actionnModel.mediator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Development implements Department&#123; private Mediator m; //中介的引用 总经理 public Development(Mediator m) &#123; this.m = m; m.register(\"development\", this); &#125; @Override public void selfAction() &#123; System.out.println(\"钻心科研，发送项目\"); &#125; @Override public void outAction() &#123; System.out.println(\"汇报工作，没钱了，发工资\"); &#125;&#125;//财务部package com.xiaoqiang.gof23.actionnModel.mediator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Finalcial implements Department&#123; private Mediator m; //中介的引用 总经理 public Finalcial(Mediator m) &#123; this.m = m; m.register(\"Finalcial\", this); &#125; @Override public void selfAction() &#123; System.out.println(\"我在数钱\"); &#125; @Override public void outAction() &#123; System.out.println(\"汇报工作，没钱了，钱太多了，怎么花\"); &#125;&#125;//采购package com.xiaoqiang.gof23.actionnModel.mediator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Market implements Department&#123; private Mediator m; //中介的引用 总经理 public Market(Mediator m) &#123; this.m = m; m.register(\"Market\", this); &#125; @Override public void selfAction() &#123; System.out.println(\"跑去接项目\"); &#125; @Override public void outAction() &#123; System.out.println(\"汇报工作，项目承接的部分，许要资金支持\"); m.command(\"Finalcial\"); &#125;&#125; 总结：中介者就是一个处于众多对象中间，并恰当地处理众多对象之间相互之间的联系的角色","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"迭代器模式","date":"2019-08-29T07:49:16.000Z","path":"2019/08/29/迭代器模式/","text":"迭代器模式：Iterator提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。 接口123456789101112131415161718192021package com.xiaoqiang.gof23.actionnModel.iterator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public interface MyIterator &#123; void first(); //游标指向第一个元素 void next(); //将游标指向下一个元素 boolean hasNext(); //判断是否有下一个 boolean isFirst(); boolean isLast();// 获取当前游标的指向 Object getCurrentObj();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.xiaoqiang.gof23.actionnModel.iterator;import java.util.ArrayList;import java.util.List;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 自定义的聚合类 */public class ConcreteMyAggregate &#123; private List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public void addObjet(Object o) &#123; this.list.add(o); &#125; public void removeObject(Object o) &#123; this.list.remove(o); &#125; public List&lt;Object&gt; getList() &#123; return list; &#125; public void setList(List&lt;Object&gt; list) &#123; this.list = list; &#125;// 获取迭代器的方法 public MyIterator ctreateIterator() &#123; return new ConcreteIterator(); &#125; // 迭代器的内部类 为具体类提供服务 private class ConcreteIterator implements MyIterator &#123; // 定义游标记录遍历时的位置 private int cursor; @Override public void first() &#123; this.cursor = 0; &#125; @Override public void next() &#123; if (cursor &lt; list.size()) &#123; cursor++; &#125; &#125; @Override public boolean hasNext() &#123; if (cursor &lt; list.size()) &#123; return true; &#125; else &#123; return false; &#125; &#125; @Override public boolean isFirst() &#123; return cursor == 0; &#125; @Override public boolean isLast() &#123; return cursor == (list.size() - 1); &#125; @Override public Object getCurrentObj() &#123; return list.get(cursor); &#125; &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"命令模式","date":"2019-08-29T07:48:47.000Z","path":"2019/08/29/命令模式/","text":"命令模式(Coomand)将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。 作用：命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 1234567891011121314151617181920212223242526272829303132package com.xiaoqiang.gof23.actionnModel.command;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 命令的发送者 */public class Receiver &#123; public void action() &#123; System.out.println(\"Receiver action()\"); &#125;&#125;//命令的调用者package com.xiaoqiang.gof23.actionnModel.command;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Invoke &#123; private Command command; public Invoke(Command command) &#123; this.command = command; &#125;// 业务方法调用命令类的方法 public void call() &#123; command.execute(); &#125;&#125; //命令类 1234567891011121314151617181920212223242526272829package com.xiaoqiang.gof23.actionnModel.command;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public interface Command &#123; /** *这个方法是一个返回结果的方法 * 实际项目中，可以根据需求设计多个不同的方法 * * */ void execute();&#125;class ConcreteCommand implements Command &#123; private Receiver receiver; public ConcreteCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123;// 命令真正执行前后的相关处理 receiver.action(); &#125;&#125; 1234567891011121314151617package com.xiaoqiang.gof23.actionnModel.command;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; Command c = new ConcreteCommand(new Receiver()); Invoke i = new Invoke(c); i.call(); new Receiver().action(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"责任链模式","date":"2019-08-29T07:48:35.000Z","path":"2019/08/29/责任链模式/","text":"责任链模式(Chain)定义：责任链模式就是将请求的接收者对象连成一条链，然后在这一条链上传递请求，直到有个一接收者处理这个请求。通过这样一种方式，避免了请求者和接收者之间的耦合. 场景：打牌时，轮流出牌，接力赛跑，公司的公文审批 模拟公司里面，请假条的审批过程： • 如果请假天数小于3天，主任审批 • 如果请假天数大于等于3天，小于10天，经理审批 • 如果大于等于10天，小于30天，总经理审批 • 如果大于等于30天，提示拒绝 123456789101112131415161718192021222324252627package com.xiaoqiang.gof23.actionnModel.chainOfResq;/** * @author xiaoqiang * @date $(DATE)-$(TIME) *抽象类 * * 处理的流程 * */public abstract class Leader &#123; protected String name; // 责任链的后继对象 protected Leader nextLeader; public Leader(String name) &#123; this.name = name; &#125; public void setNextLeader(Leader nextLeader) &#123; this.nextLeader = nextLeader; &#125;// 处理请求的核心方法 public abstract void handleRequest(LeaveRequest request);&#125; 主任1234567891011121314151617181920212223package com.xiaoqiang.gof23.actionnModel.chainOfResq;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Director extends Leader &#123; public Director(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if (request.getLeaveDays() &lt; 3) &#123; System.out.println(\"员工\"+request.getEmpName()+\"请假，天数:\"+request.getLeaveDays()+\"天,理由:\" +request.getReason()+\"主任\"+this.name+\"审批通过\"); &#125; else &#123; if (this.nextLeader != null) &#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125; 经理123456789101112131415161718192021222324package com.xiaoqiang.gof23.actionnModel.chainOfResq;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 经理 */public class Manager extends Leader &#123; public Manager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if (request.getLeaveDays() &lt; 10) &#123; System.out.println(\"员工\"+request.getEmpName()+\"请假，天数:\"+request.getLeaveDays()+\"天,理由:\" +request.getReason()+\"经理\"+this.name+\"审批通过\"); &#125; else &#123; if (this.nextLeader != null) &#123; this.nextLeader.handleRequest(request); &#125; &#125; &#125;&#125; 总经理123456789101112131415161718192021222324package com.xiaoqiang.gof23.actionnModel.chainOfResq;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 经理 */public class GeneralManager extends Leader &#123; public GeneralManager(String name) &#123; super(name); &#125; @Override public void handleRequest(LeaveRequest request) &#123; if (request.getLeaveDays() &lt; 30) &#123; System.out.println(\"员工\"+request.getEmpName()+\"请假，天数:\"+request.getLeaveDays()+\"天,理由:\" +request.getReason()+\"总经理\"+this.name+\"审批通过\"); &#125; else &#123; if (this.nextLeader != null) &#123; System.out.println(\"莫非\" + request.getEmpName() + \"想辞职，居然请假\" + request.getLeaveDays() + \"天!\"); &#125; &#125; &#125;&#125; 客户端123456789101112131415161718192021package com.xiaoqiang.gof23.actionnModel.chainOfResq;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; Leader a = new Director(\"张三\"); Leader b = new Manager(\"李四\"); Leader c = new GeneralManager(\"王五\");// 责任链对象的关系 a.setNextLeader(b); b.setNextLeader(c); LeaveRequest request = new LeaveRequest(\"Tom\", 1, \"请病假\"); a.handleRequest(request); &#125;&#125; 总结，平常的处理是用if /else if 语句来判断条件，但是当要新增加条件是需要修改原来的代码，而责任链模式就可以通过增加新的类来实现条件的控制","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"代理模式","date":"2019-08-29T07:48:10.000Z","path":"2019/08/29/代理模式/","text":"proxy作用：通过代理来控制对对象的访问可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后 做后置处理。（即：Spring的AOP的微观实现！） ​ 现实生活中的 经纪人，中介公司 ​ 比如：歌手的演唱会： 经纪人要 安排 面谈 合同签字 机票车辆 歌手唱歌 收尾款 ​ 对于每个歌手流程都是一样的 就 歌手唱歌不同 静态代理​ RealStar和StarProxy 都实现Star接口，StarProxy有一个 RealStar成员变量，然后在调用StarProxy相应方法只要调用它，就调用其成员变量RealStar相应实现的方法（但是可以在前后加相应的操作） #### 1）歌手接口 12345678910111213141516171819202122package com.xiaoqiang.gof23.structureModel.proxy.dynamicProxy;/** * @author xiaoqiang */public interface Star &#123; /*面谈*/ void confer(); /*签合约*/ void signContract(); /*订票*/ void bookTicket(); /*唱歌*/ void sing(); /*收尾款*/ void collectMoney();&#125; 2）歌手的具体实现类12345678910111213141516171819202122232425262728293031323334353637package com.xiaoqiang.gof23.structureModel.proxy.dynamicProxy;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class RealStar implements Star &#123; @Override public void confer() &#123; System.out.println(&quot;RealStar.confer()&quot;); &#125; @Override public void signContract() &#123; System.out.println(&quot;RealStar.signContract()&quot;); &#125; @Override public void bookTicket() &#123; System.out.println(&quot;RealStar.bookTicket()&quot;); &#125; @Override public void sing() &#123; System.out.println(&quot;RealStar(歌手本人).sing()&quot;); &#125; @Override public void collectMoney() &#123; System.out.println(&quot;RealStar.collectMoney()&quot;); &#125;&#125; 3）代理类123456789101112131415161718192021222324252627282930package com.xiaoqiang.gof23.structureModel.proxy.dynamicProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * @author xiaoqiang */public class StarHandler implements InvocationHandler &#123; private Star realStart; public StarHandler(Star realStart) &#123; this.realStart = realStart; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;// 返回的数据 Object obj = null; System.out.println(\"真正的方法执行前，面谈，签合同，预付款，订机票\"); if (method.getName().equals(\"sing\")) &#123; obj=method.invoke(realStart, args); &#125; System.out.println(\"真正方法执行后，收尾款\"); return obj; &#125;&#125; 调用123456789101112131415161718package com.xiaoqiang.gof23.structureModel.proxy.dynamicProxy;import java.lang.reflect.Proxy;/** * @author xiaoqiang */public class Client &#123; public static void main(String[] args) &#123; Star realStar = new RealStar(); StarHandler handler = new StarHandler(realStar); //jdk提供的动态代理 Star proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Star.class&#125;, handler); proxy.bookTicket(); proxy.sing(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"享元模式","date":"2019-08-29T07:48:00.000Z","path":"2019/08/29/享元模式/","text":"享元模式 （flyweight ）场景：– 内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。 • 核心：– 享元模式以共享的方式高效地支持大量细粒度对象的重用。– 享元对象能做到共享的关键是区分了内部状态和外部状态。• 内部状态：可以共享，不会随环境变化而改变• 外部状态：不可以共享，会随环境变化而改变 比如说，在围棋软件中，每个棋子都是一个对象 有如下的属性 颜色 形状 大小 这三个是可以共享的（内部状态） 位置 这是不共享的（外部状态） 123456789101112131415161718192021222324252627282930313233343536373839404142package com.xiaoqiang.gof23.structureModel.flyweight;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * * 享元类 */public interface ChessFlyWeight &#123; void setColor(String color); String getColor(); void display(Coordinate c);&#125;class ConcreteChess implements ChessFlyWeight &#123;// 为被共享的 内部状态提供成员变量提供存储 比如说棋子的颜色大小形状等// 不能被共享的内容，设置为非共享的享元类 如 棋子的坐标位置 Coordinate private String color; public ConcreteChess(String color) &#123; this.color = color; &#125; @Override public void setColor(String color) &#123; this.color = color; &#125; @Override public String getColor() &#123; return color; &#125; @Override public void display(Coordinate c) &#123; System.out.println(\"棋子颜色：\" + color + \"棋子位置\" + c.getX() + \"---\" + c.getY()); &#125;&#125; 享元工厂123456789101112131415161718192021222324package com.xiaoqiang.gof23.structureModel.flyweight;import java.util.HashMap;import java.util.Map;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class ChessFlyWeightFactory &#123;//享元池 private static Map&lt;String, ChessFlyWeight&gt; map = new HashMap&lt;&gt;(); public static ChessFlyWeight getChess(String color) &#123;// 如果没有之前此颜色 创建 ，有就从 享元池里面拿 if (map.get(color) != null) &#123; return map.get(color); &#125; else &#123; ChessFlyWeight cwf = new ConcreteChess(color); map.put(color, cwf); return cwf; &#125; &#125;&#125; 外部状态的 非享元类 位置坐标123456789101112131415161718192021222324252627282930313233343536package com.xiaoqiang.gof23.structureModel.flyweight;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * * 外部类 * * * 位置坐标 */public class Coordinate &#123; private int x; private int y; public Coordinate(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125;&#125; Client类12345678910111213141516171819package com.xiaoqiang.gof23.structureModel.flyweight;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; ChessFlyWeight chess = ChessFlyWeightFactory.getChess(\"黑色\"); ChessFlyWeight chess1 = ChessFlyWeightFactory.getChess(\"黑色\");// 共享同一个黑色棋子 System.out.println(chess); System.out.println(chess1);// 但外部状态不一样 System.out.println(\"外部状态的处理\"); chess.display(new Coordinate(10, 10)); chess.display(new Coordinate(20, 20)); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"外观模式","date":"2019-08-29T07:47:49.000Z","path":"2019/08/29/外观模式/","text":"外观模式facade 迪米特法则(最少知识原则)： 一个软件实体应当尽可能少的与其他实体发生相互作用 频率很高。哪里都会遇到。各种技术和框架中 注册公司 不使用外观模式 使用外观模式","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"装饰模式","date":"2019-08-29T07:47:41.000Z","path":"2019/08/29/装饰模式/","text":"装饰模式（decorator）Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰 对象交互。 – ConcreteComponent 具体构件角色(真实对象)：​ 比如：io流中的FileInputStream、FileOutputStream Decorator装饰角色：• 持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象 。这样，就能在真实对象调用前后增加新的功能。 – ConcreteDecorator具体装饰角色： • 负责给构件对象增加新的责任。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.xiaoqiang.gof23.structureModel.decorator;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * &lt;p&gt; * 抽象组件 */public interface ICar &#123; void move();&#125;//真实的对象，被装饰的对象class Car implements ICar &#123; @Override public void move() &#123; System.out.println(\"陆地上跑\"); &#125;&#125;//装饰器class SuperCar implements ICar &#123; private ICar car; public SuperCar(ICar car) &#123; this.car = car; &#125; @Override public void move() &#123; car.move(); &#125;&#125;//装饰对象class FlyCar extends SuperCar &#123; public FlyCar(ICar car) &#123; super(car); &#125; public void fly() &#123; System.out.println(\"天上飞\"); &#125; @Override public void move() &#123; super.move(); fly(); &#125;&#125;class WaterCar extends SuperCar &#123; public WaterCar(ICar car) &#123; super(car); &#125; public void swim() &#123; System.out.println(\"水上游\"); &#125; @Override public void move() &#123; super.move(); swim(); &#125;&#125;class AICar extends SuperCar &#123; public AICar(ICar car) &#123; super(car); &#125; public void autoMove() &#123; System.out.println(\"自动跑\"); &#125; @Override public void move() &#123; super.move(); autoMove(); &#125;&#125; 每次调用公共的方法都先调用其父类的方法 它们的父类都是 真实的对象Car Cilent 123456789101112131415161718192021222324252627282930313233343536373839package com.xiaoqiang.gof23.structureModel.decorator;import java.io.*;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * * 装饰(器)模式 Decorator * 包装模式 Wrapper */public class Client &#123; public static void main(String[] args) &#123; Car car = new Car(); car.move();// 增加新的功能 System.out.println(\"增加新的功能 飞\"); FlyCar flyCar = new FlyCar(car); flyCar.move(); System.out.println(\"增加新的功能 游\"); WaterCar waterCar = new WaterCar(flyCar); waterCar.move(); System.out.println(\"增加全部功能 飞 游 AI\"); ICar iCar = new AICar(new FlyCar(new WaterCar(new Car()))); iCar.move();// IO流就是典型的装饰模式+ /* try &#123; Reader r = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"123\")))); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125;*/ &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"组合模式","date":"2019-08-29T07:47:27.000Z","path":"2019/08/29/组合模式/","text":"composite场景：（杀毒软件等）把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对 象和整体对象。 抽象构件(Component)角色: 定义了叶子和容器构件的共同点 – 叶子(Leaf) 构件角色：无子节点 – 容器(Composite)构件角色： 有容器特征，可以包含子节点 12345678910111213141516171819202122232425262728293031package com.xiaoqiang.gof23.structureModel.composite;/** * @author xiaoqiang * &lt;p&gt; * 抽象组件 */public interface Component &#123; void operation();&#125;/** * 叶子组件 */interface Leaf extends Component &#123;&#125;//容器组件interface Composite extends Component &#123; void add(Component c); void remove(Component c); Component get(int index);&#125; 具体的杀毒软件实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.xiaoqiang.gof23.structureModel.composite;import java.util.ArrayList;import java.util.List;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * &lt;p&gt; * 抽象构建 */public interface AbstractFile &#123; void killVirus();&#125;//叶子节点构建class ImageFile implements AbstractFile &#123; private String name; public ImageFile(String name) &#123; this.name = name; &#125; @Override public void killVirus() &#123; System.out.println(\"图像文件：\"+name+\",进行查杀\"); &#125;&#125;class TextFile implements AbstractFile &#123; private String name; public TextFile(String name) &#123; this.name = name; &#125; @Override public void killVirus() &#123; System.out.println(\"文本文件：\"+name+\",进行查杀\"); &#125;&#125;class VideoFile implements AbstractFile &#123; private String name; public VideoFile(String name) &#123; this.name = name; &#125; @Override public void killVirus() &#123; System.out.println(\"视频文件：\"+name+\",进行查杀\"); &#125;&#125;//容器组件 构建class Folder implements AbstractFile &#123; private String name; private List&lt;AbstractFile&gt; list = new ArrayList&lt;&gt;(); public Folder(String name) &#123; this.name = name; &#125; public void add(AbstractFile file) &#123; list.add(file); &#125; public void remove(AbstractFile file) &#123; list.remove(file); &#125; public AbstractFile getChild(int index) &#123; return list.get(index); &#125; @Override public void killVirus() &#123; System.out.println(\"文件夹\"+name+\",进行查杀\"); for (AbstractFile abstractFile : list) &#123;// 天然的递归 abstractFile.killVirus(); &#125; &#125;&#125; 客户端 123456789101112131415161718192021222324252627282930package com.xiaoqiang.gof23.structureModel.composite;/** * @author xiaoqiang * @date $(DATE)-$(TIME) */public class Client &#123; public static void main(String[] args) &#123; Folder f1; AbstractFile f2, f3, f4, f5; f1 = new Folder(\"我的收藏\"); f2 = new ImageFile(\"我的相片.jpg\"); f3 = new TextFile(\"Hello.txt\"); f1.add(f2); f1.add(f3); Folder f11 = new Folder(\"电影\"); f4 = new VideoFile(\"神雕侠侣.avi\"); f5 = new VideoFile(\"天龙八部.avi\"); f11.add(f4); f11.add(f5); f1.add(f11);// f2.killVirus(); f1.killVirus(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"桥接模式","date":"2019-08-29T07:47:04.000Z","path":"2019/08/29/桥接模式/","text":"Bridge 处理多继承的关系，如要多加个品牌，或者增加个智能手机 场景分析 – 商城系统中常见的商品分类，以电脑为类，如何良好的处理商品分类销售的问题? – 这个场景中有两个变化的维度：电脑类型、电脑品牌。 品牌一个接口 123456789101112131415161718192021222324252627282930package com.xiaoqiang.gof23.structureModel.bridge;/** * @author xiaoqiang */public interface Brand &#123; void sale();&#125;class Lenovo implements Brand &#123; @Override public void sale() &#123; System.out.println(&quot;销售联想电脑&quot;); &#125;&#125;class Dell implements Brand &#123; @Override public void sale() &#123; System.out.println(&quot;销售戴尔电脑&quot;); &#125;&#125; 电脑产品 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xiaoqiang.gof23.structureModel.bridge;/** * @author xiaoqiang */public abstract class Computer &#123; protected Brand brand; public Computer(Brand brand) &#123; this.brand = brand; &#125; public void sale() &#123; brand.sale(); &#125;&#125;class Desktop extends Computer &#123; public Desktop(Brand brand) &#123; super(brand); &#125; @Override public void sale() &#123; super.sale(); System.out.println(\"销售台式机\"); &#125;&#125;class Laptop extends Computer &#123; public Laptop(Brand brand) &#123; super(brand); &#125; @Override public void sale() &#123; super.sale(); System.out.println(\"销售笔记本\"); &#125;&#125; 就这样吧 者连个维度组合在一起 当要增加一个品牌是只要多个实现Brand的类，而增加一个产品比如智能手机是只要多一个Phone的抽象类与Brand组合就行 总结： – 桥接模式可以取代多层继承的方案。 多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个数，从而降低管理和维护的成本。 – 桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"适配器模式","date":"2019-08-29T07:46:44.000Z","path":"2019/08/29/适配器模式/","text":"适配器模式定义将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 和生活场景中的插头转接器有点像 模式中的角色目标接口(Target) :客户所期待的接口，目标可以是具体的或者抽象的类，也可以是接口 需要的适配类(Adaptee):需要适配的类或者适配者类 适配器(Adapter)：通过包装一个需要适配的对象，把原接口转变成目标接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.xiaoqiang.gof23.structureModel.adapter;/** * @author xiaoqiang目标接口 两个的插座 */public interface Target &#123; void handleReq();&#125;package com.xiaoqiang.gof23.structureModel.adapter;/** * @author xiaoqiang * * 被适配的类 相当于 三个头的插座 */public class Adaptee &#123; public void request() &#123; System.out.println(\"可以完成客户需要的功能!\"); &#125;&#125;package com.xiaoqiang.gof23.structureModel.adapter;/** * @author xiaoqiang * * 适配器本身 * * 相当于转接口 *先实现目标的接口(两个的插座) * 两种方式 * 1：继承被适配类（三个的插座） 然后通过 super.request(); 实现其(三个插座)的功能 * 不过灵活，只能单继承，实现一种 * 2：组合被适配的类 * 组合，需要自己提供 Adaptee */public class Adapter implements Target &#123; private Adaptee adaptee; @Override public void handleReq() &#123; adaptee.request(); &#125; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125;&#125;package com.xiaoqiang.gof23.structureModel.adapter;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 客户类 * * 相当于笔记本 */public class Client &#123; public static void main(String[] args) &#123;// 调用方法 Adaptee adaptee = new Adaptee();// 用适配器将 Adaptee 变成了目标需要的 Target Target target = new Adapter(adaptee);// 调用目标需要的方法 target.handleReq();// 或者这样 new Adapter(new Adaptee()).handleReq(); &#125;&#125; 场景：经常用来做旧系统改造和升级– 如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。 输入输出流就是标准的适配器模式 java.io.InputStreamReader(InputStream)java.io.OutputStreamWriter(OutputStream)","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"建造者模式","date":"2019-08-29T03:20:47.000Z","path":"2019/08/29/建造者模式/","text":"建造者模式（Bulider）建造者模式能够将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。这句话理解起来可能有点抽象，简单来说就是调用相同的创建对象的方法（建造过程）可以创建出不同的对象。 举例说明：如果说创建一个电脑：我们需要几个核心的部件，比如说：主机，显示器，鼠标，键盘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xiaoqiang.gof23.createModel.builder.computer;/** * @author xiaoqiang * @date 2019/8/29-15:33 */public class Computer &#123; // 主机 private String host; // 显示器 private String monitor; // 键盘 private String keyboard; // 鼠标 private String mouser; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public String getMonitor() &#123; return monitor; &#125; public void setMonitor(String monitor) &#123; this.monitor = monitor; &#125; public String getKeyboard() &#123; return keyboard; &#125; public void setKeyboard(String keyboard) &#123; this.keyboard = keyboard; &#125; public String getMouser() &#123; return mouser; &#125; public void setMouser(String mouser) &#123; this.mouser = mouser; &#125;&#125; 每一个电脑都是这个类的对象，在创建电脑时都需要保证这几个核心组件的创建，所以创建手机需要一个规范，因为几个核心部件都可以是不同的型号，不同的型号的部件制造出来的电脑也是不同的，这样就有了下面建造规范的接口。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"工厂模式","date":"2019-08-29T03:20:29.000Z","path":"2019/08/29/factory/","text":"Factory(工厂模式)1.核心本质是： 实例化对象，用工厂方法代替new操作。 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的 实现类解耦。 2.工厂模式1) 简单工厂模式（静态工厂模式） 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已 有代码） 接口与实现类 车子接口 123public interface Car &#123; void run();&#125; 具体的奥迪 Audi 奥迪 和 Byd比亚迪实现类 123456789101112131415public class Audi implements Car &#123; @Override public void run() &#123; System.out.println(\"Audi Running\"); &#125;&#125;public class Byd implements Car &#123; @Override public void run() &#123; System.out.println(\"Byd Running\"); &#125;&#125; 第一种工厂实现 通过名称作为参数来创建实例 12345678910111213public class CarFactory &#123; public static Car creatCar(String type) &#123; if (\"Audi\".equals(type)) &#123; return new Audi(); &#125; else if (\"Byd\".equals(type)) &#123; return new Byd(); &#125; else &#123;// 修改增加新的类 违反了开闭原则OCP：扩展开放，修改关闭 return null; &#125; &#125;&#125; 第二种工厂实现 通过方法名来区分创建不同的实例， 123456789public class CarFactory02 &#123; public static Car creatAudi() &#123; return new Audi(); &#125; public static Car creatByd() &#123; return new Byd(); &#125;&#125; 测试 123456789101112131415161718public class Client02 &#123; /** * 简单工厂情况 * * 只要与工厂打交道，不要知道 具体的实现类 * 使用最多，需要修改已有的工厂类来增加新的类 * */ public static void main(String[] args) &#123; Car c1 = CarFactory.creatCar(\"Audi\"); Car c2 = CarFactory.creatCar(\"Byd\"); /* c1 = CarFactory02.creatAudi(); c2 = CarFactory02.creatByd();*/ c1.run(); c2.run(); &#125;&#125; 2) 工厂方法模式​ 用来生产同一等级结构中的固定产品。（支持增加任意产品） 还是原来的接口和实现类，但是多了一个工厂的接口，每个具体类都有对应的具体的工厂来创建对应的实例，当要添加新的实例时，只需要创建实现Car和CarFactory接口即可 工厂接口 只有一个创建方法 123public interface CarFactory &#123; Car createCar();&#125; 具体工厂实现实现类 1234567891011121314public class AudiFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125;public class BydFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 测试 123456789101112131415/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 工厂方法模式 * 根据对应的类，继承工厂接口，和相应的方法创建类返回 * * 不能修改已有类的前提下，通过增加新的工厂来实现扩展 */public class Cilcent &#123; public static void main(String[] args) &#123; Car c1 = new AudiFactory().createCar(); c1.run(); &#125;&#125; 3) 抽象工厂模式 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持 增加产品族） 比如说汽车 有发动机，座椅，轮胎三个组件合成，每个汽车有普通和智能型的，所有组件也分为普通和智能型的 首先是 每个组件的接口与实现类 发动机12345678910111213141516171819202122232425262728293031public interface Engine &#123; void run(); void start();&#125;//好发动机class LuxuryEngine implements Engine &#123; @Override public void run() &#123; System.out.println(\"转的快\"); &#125; @Override public void start() &#123; System.out.println(\"启动的块，自动启停\"); &#125;&#125;//不好的发动机class LowEngine implements Engine &#123; @Override public void run() &#123; System.out.println(\"转的慢\"); &#125; @Override public void start() &#123; System.out.println(\"启动的慢\"); &#125;&#125; 座椅12345678910111213141516171819public interface Seat &#123; void massage();&#125;class LuxuraySeat implements Seat &#123; @Override public void massage() &#123; System.out.println(\"可以自动按摩\"); &#125;&#125;class LowSeat implements Seat &#123; @Override public void massage() &#123; System.out.println(\"不可以自动按摩\"); &#125; 轮胎 12345678910111213141516171819public interface Tyre &#123; void revolve();&#125;class LuxurtTyre implements Tyre &#123; @Override public void revolve() &#123; System.out.println(\"旋转不磨损\"); &#125;&#125;class LowTyre implements Tyre &#123; @Override public void revolve() &#123; System.out.println(\"旋转磨损快\"); &#125;&#125; 其次是工厂的抽象类或接口 1234567public interface CarFactory &#123; Engine createEngine(); Seat createSeat(); Tyre createTrpe();&#125; 工厂的实现类 返回各种的组件 普通型1234567891011121314151617public class LowCarFactory implements CarFactory&#123; @Override public Engine createEngine() &#123; return new LowEngine(); &#125; @Override public Seat createSeat() &#123; return new LowSeat(); &#125; @Override public Tyre createTrpe() &#123; return new LowTyre(); &#125;&#125; 智能型1234567891011121314151617181920public class LuxuryCarFactory implements CarFactory &#123; @Override public Engine createEngine() &#123; return new LuxuryEngine(); &#125; @Override public Seat createSeat() &#123; return new LuxuraySeat(); &#125; @Override public Tyre createTrpe() &#123; return new LuxurtTyre(); &#125;&#125; 测试 可以增加一类产品族的，比如 XXX型的汽车的的组件，并且可以相互的组合 12345678910111213141516/** * @author xiaoqiang * @date $(DATE)-$(TIME) * * 抽象工厂 * * 不可以增加产品，可以增加产品族， */public class Client &#123; public static void main(String[] args) &#123; CarFactory carFactory = new LuxuryCarFactory(); Engine engine = carFactory.createEngine(); engine.run(); engine.start(); &#125;&#125; 工厂模式要点：– 简单工厂模式(静态工厂模式)• 虽然某种程度不符合设计原则，但实际使用最多。 – 工厂方法模式• 不修改已有类的前提下，通过增加新的工厂类实现扩展。 – 抽象工厂模式• 不可以增加产品，可以增加产品族！","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"原型模式","date":"2019-08-29T03:20:05.000Z","path":"2019/08/29/原型模式/","text":"Prototype原型模式 也叫 克隆（复制）模式1.试用场景通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点 优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的 对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。 2.实现方式Cloneable接口和clone方法 Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了clone()方法替我们做了绝大部分事情。 潜克隆 （属性还是一样的，内存还是指向同一个） 深克隆 (把属性也进行拷贝) 实现深克隆的方法1：在clone方法 对象的字段属性也 要相应的设置为克隆的 1234567891011@Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //直接调用object的clone方法 //添加如下代码实现深克隆 //即新建一个对象，然后为其每个属性都克隆一份 // Sheep sheep = (Sheep) obj; // sheep.birthday = (Date) this.birthday.clone(); return obj; &#125; 2: 序列化和反序列化实现深克隆 （前提，克隆的类要实现序列化接口 Serializable） public class Sheep implements Cloneable, Serializable {} 123456789101112131415161718192021 Date date = new Date(1111111111); Sheep s1 = new Sheep(\"少莉\", date);// Sheep s2 = (Sheep) s1.clone(); // 使用序列化和反序列化来实现深克隆 //建立对象字节流，然后用对象流修饰，将要序列化的对象输出到字节数组中 //输出流就是 从流中的数据输出到其他形式，输出流 -&gt; 字节数组(文件等其他形式) ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); //输出流的write方法是将 输出流中的数据 写出来 oos.writeObject(s1); //获取字节数组 byte[] bytes = bos.toByteArray(); //通过字节数组输入到 字节输入流，然后通过Object流封装修饰 //输入流是把其他形式数据输入到输入流中去 字节数组(文件等其他形式)-&gt;输入流 //read方法是将输入流中的数据读取出来 ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); Sheep s2 = (Sheep) ois.readObject(); //克隆羊原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone 的方法创建一个对象，然后由工厂方法提供给调用者。 ​ spring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型 模式需要和工厂模式搭配起来）","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"单例模式","date":"2019-08-29T03:09:42.000Z","path":"2019/08/29/单例模式/","text":"单例模式(Singleton)核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点 延迟加载：又叫懒加载，需要使用对象时才创建 常见的五种单例模式实现方式– 主要： 饿汉式（线程安全，调用效率高。 但是，不能延时加载。） 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。） – 其他： 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用） 静态内部类式(线程安全，调用效率高。 但是，可以延时加载) 枚举式(线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列 化漏洞！) 如何选用?单例对象 占用 资源 少，不需要 延时加载： 枚举式 好于 饿汉式 单例对象 占用 资源 大，需要 延时加载： 静态内部类式 好于 懒汉式 1.饿汉式12345678910111213141516171819202122232425262728293031323334package com.xiaoqiang.gof23.createModel.singleton;import java.io.ObjectStreamException;/**- @author xiaoqiang * *饿汉式单例模式 */ public class SingletonDemo1 &#123; /**饿汉式单例模式 - 在加载的时候直接初始化时，立即加载这个并且创建这个对象，不能延迟 - 由于加载类时是天然的线程安全的 不用synchronized 同步锁，效率高 - */ private static SingletonDemo1 singletonDemo1 = new SingletonDemo1(); private SingletonDemo1() &#123; if (singletonDemo1 != null) &#123; // 防止反射破解单例 throw new RuntimeException(); &#125; &#125; public static /*synchronized*/ SingletonDemo1 getsingletonDemo1() &#123; return singletonDemo1; &#125;// 反正反序列化破解单例// 定义readResolve()则直接返回此方法的对象，不用单独在创建新的对象 private Object readResolve() throws ObjectStreamException &#123; return singletonDemo1; &#125;&#125; ​ 注意：关于防止反射和反序列化来破解单例模式的方法，一下就不一一列举了，都是一样的 2.懒汉式12345678910111213141516171819202122package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * 懒汉式, */public class SingletonDemo2 &#123; // 懒汉式,不初始化对象，延迟加载，需要的时候创建， // 要用到线程锁 synchronized，效率低了 private static SingletonDemo2 singletonDemo2; private SingletonDemo2() &#123; &#125; public static synchronized SingletonDemo2 getSingletonDemo2() &#123; if (singletonDemo2 == null) &#123; singletonDemo2 = new SingletonDemo2(); &#125; return singletonDemo2; &#125;&#125; 3.双重检测锁123456789101112131415161718192021222324252627282930313233343536package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * */public class SingletonDemo3 &#123; /**双重检查锁单例模式实现 * 将同步放到if的内部，提高了执行的效率 * 问题：由于编译器优化和jvm内部模型的原因，偶尔会出现问题，不建议使用 * * */ private static SingletonDemo3 singletonDemo3; private SingletonDemo3() &#123; &#125; private static SingletonDemo3 getSingletonDemo3() &#123; if (singletonDemo3 == null) &#123; SingletonDemo3 s; synchronized (SingletonDemo3.class) &#123; s = singletonDemo3; if (s == null) &#123; synchronized (SingletonDemo3.class) &#123; if (s == null) &#123; s = new SingletonDemo3(); &#125; &#125; singletonDemo3=s; &#125; &#125; &#125; return singletonDemo3; &#125;&#125; 4.静态内部类1234567891011121314151617181920212223242526272829package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * 静态内部类实现单例模式 * 线程安全，调用效率高，延迟加载 * * 在加载SingletonDemo4时，不会加载SingletonClassInstance， * 、当使用到才会加载，所以是延迟加载 */public class SingletonDemo4 &#123; //实例内部类，但没有用到时，内部类是不会加载的，即不会创建 instance private static class SingletonClassInstance &#123;// 保证线程安全 private static final SingletonDemo4 instance = new SingletonDemo4(); &#125; //调用这个方法，用到了静态的内部类才会加载这个类，并初始化 instance public static SingletonDemo4 getSingletonDemo4() &#123; return SingletonClassInstance.instance; &#125; private SingletonDemo4() &#123; &#125;&#125; 5.枚举类型1234567891011121314151617181920212223package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 枚举实现单例 * 枚举本身就是单例，简单，避免反射和反序列化漏洞来创建对象 * 没有懒（延迟）加载 */public enum SingletonDemo5 &#123; /** * 定义一个枚举元素，它就代表一个单例 * */ INSTANCE; /** * 单例有自己的操作 */ public void singletonOperation() &#123; /**功能处理*/ &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"markdown语法和Typora软件的使用","date":"2019-08-28T02:46:50.000Z","path":"2019/08/28/markdown-use/","text":"markdown常用语法中间用空格隔开 1.标题123456# 一级标题## 二级标题### 三级标题#### 四季标题##### 五级标题###### 六级标题 对应的Typora快捷键 Ctrl + 1 2 3 4 5 6 2.分割线12---*** 3.列表 无序列表 ：- + * 有序列表 : 数字 + . + 空格 4.引用&gt; 这就是引用 &gt; &gt; 可以引用其他的文章5.图片与链接 图片语法： ![图片文本][图片地址链接] 链接语法： [百度](www.baidu.com) 示例：百度 6.粗体与斜体 粗体语法 **我是粗体** 斜体语法 *我是斜体* 粗体加斜体 ***我是粗体加斜体*** 7.删除线，使用~~包裹文字 删除线 ~~删除线~~ 8.代码块- 行内代码块 使用``括起来 - 不同语言的代码块 ```加上语言9.表格​ 表格主要用到的符号有 | - : ​ | 表格 | 怎么用 | ​ Typora 右键可以插入行列","tags":[{"name":"markdown","slug":"markdown","permalink":"http://cxqiang.gitee.io/blog/tags/markdown/"}]},{"title":"test","date":"2019-08-27T09:23:10.000Z","path":"2019/08/27/test/","text":"test 测试一下","tags":[]},{"title":"Hello World","date":"2019-08-27T08:22:31.623Z","path":"2019/08/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]