[{"title":"","date":"2019-08-31T02:56:42.147Z","path":"2019/08/31/System/","text":"一、System类的定义 System类为Java的系统类，位于 java.lang 包中 System类的构造方法由 private 进行修饰，因此无法被实例化 System类提供了标准输入流、标准输出流和错误输出流； 此外还提供了访问操作系统环境变量，访问虚拟机环境变量，复制数组，垃圾回收等一系列实用方法 二、System类的常用方法 1、System.currentTimeMillis() 获取当前时间戳，单位为秒 2、System.nanoTime() 获取当前时间戳，单位为纳秒 3、System.lineSeparator() 行分隔符，等同于 System.getProperty(“line.separator”) 4、System.arraycopy() 拷贝数组，有五个参数，System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) src：源数组 srcPos：源数组开始截取的位置，从0开始 dest：目标数组 destPos：目标数组开始拷贝的位置，从0开始 length：截取长度 5、System.gc() 相当于调用了 Runtime.getRuntime().gc()， 在回收之前会调用对象的finalize()方法，用于负责回收无用对象占据的内存资源 告诉垃圾收集器准备进行垃圾收集，但垃圾收集器不一定会马上执行， 这是因为 垃圾回收只与内存有关，根据虚拟机的各种算法来计算得到执行垃圾回收的时间 6、System.runFinalization() 调用已失去引用的对象的finalize()方法，但不能保证其一定执行 7、System.load(String filepath) 用于加载库文件，参数为 库文件的绝对路径 库文件：动态链接库(ddl)，Dynamic Link Library， 是一个包含可由多个程序同时使用的代码和数据的库,实现程序模块化 8、System.loadLibrary(String libname) 用于加载库文件，参数为 库文件名 该库文件必须在 java.library.path 所指向的路径中 9、System.mapLibraryName(String libname) 将库名称映射到特定的字符串中 10、System.exit(int status) 终止目前正在运行的Java虚拟机 参数为0：正常终止 参数非0：异常终止 11、System.getenv() 获取操作系统的环境变量（即本地系统中的环境变量） 参数为空：获取操作系统的所有环境变量 参数不为空：获取操作系统的指定环境变量（例如：参数为“path”） 12、System.getProperties() 获取虚拟机（JVM）的所有环境变量 13、System.getProperty(String key) 获取虚拟机（JVM）的指定环境变量 System.getProperty(“java.version”)：获取java运行环境版本 System.getProperty(“java.vendor”)：获取java运行环境供应商 System.getProperty(“java.vendor.url”)：获取java运行环境供应商的URL System.getProperty(“java.home”)：获取java安装路径 System.getProperty(“java.vm.specification.version”)：获取java虚拟机规范版本 System.getProperty(“java.vm.specification.vendor”)：获取java虚拟机规范供应商 System.getProperty(“java.vm.specification.name”)：获取java虚拟机规范名称 System.getProperty(“java.vm.version”)：获取java虚拟机实现版本 System.getProperty(“java.vm.vendor”)：获取java虚拟机实现供应商 System.getProperty(“java.vm.name”)：获取java虚拟机实现名称 System.getProperty(“java.specification.version”)：获取java运行时环境规范版本 System.getProperty(“java.specification.vender”)：获取java运行时环境规范供应商 System.getProperty(“java.specification.name”)：获取java运行时环境规范名称 System.getProperty(“java.class.version”)：获取java类格式版本号 System.getProperty(“jjava.class.path”)：获取java类路径 System.getProperty(“java.library.path”)：获取加载库时搜索的路径列表 System.getProperty(“java.io.tmpdir”)：获取默认的临时文件路径 System.getProperty(“java.ext.dirs”)：获取一个或多个扩展目录的路径 System.getProperty(“os.name”)：获取操作系统的名称 System.getProperty(“os.arch”)：获取操作系统的构架 System.getProperty(“os.version”)：获取操作系统的版本 System.getProperty(“file.separator”)：获取文件分隔符 System.getProperty(“path.separator”)：获取路径分隔符 System.getProperty(“line.separator”)：获取行分隔符 System.getProperty(“user.name”)：获取用户名称 System.getProperty(“user.home”)：获取用户主目录 System.getProperty(“user.dir”)：获取用户当前工作目录 14、System.setProperties(Properties props) 设置虚拟机(JVM)的环境变量（批量） 1234Properties prop = new Properties();prop.setProperty(\"aaa\", \"bbb\");System.setProperties(prop);System.out.println(System.getProperty(\"aaa\")); 15、System.setProperty(String key, String value) 设置虚拟机(JVM)的环境变量（单个） 16、System.clearProperty(String key) 清除设置的虚拟机(JVM)的环境变量 17、System.console() 从控制台设备读取字符信息,只能通过命令执行,在IDE中会报错 18、System.setIn(InputStream in) 重新分配标准输入流 19、System.setErr(PrintStream err) 重新分配标准错误输出流 20、System.setOut(PrintStream out) 重新分配标准输出流 21、err 标准错误输出流，没有缓存，会立即输出 22、out 标准输出流，有缓存，不一定会立即输出 23、System.identityHashCode(Object obj) 根据对象内存地址来计算得到哈希值 注意，这里需要与 hashCode() 方法进行区分 1234567891011121314151617181920212223// 由于Apple并没有覆盖hashCode()方法，所以两方法得到的哈希值相等Apple apple = new Apple();System.out.println(apple.hashCode()); // 21685669System.out.println(System.identityHashCode(apple)); // 21685669// 由于String类覆盖了hashCode()方法，所以两方法得到的哈希值不相等String str = \"123\";System.out.println(str.hashCode()); // 48690System.out.println(System.identityHashCode(str)); // 21685669// 由于\"123\"会存在常量池中，str1和str2两者指向的是常量池中的同一对象，所以两方法得到的哈希值相等String str1 = \"123\";String str2 = \"123\";System.out.println(System.identityHashCode(str1)); // 21685669System.out.println(System.identityHashCode(str2)); // 21685669// str1和str2是两个不同对象，所以两方法得到的哈希值不相等String str1 = new String(\"123\");String str2 = new String(\"123\");System.out.println(System.identityHashCode(str1)); // 21685669System.out.println(System.identityHashCode(str2)); // 2133927002 24、System.setSecurityManager(SecurityManager securityManager) 设置安全管理器，接收一个 SecurityManager 类型的参数 25、System.getSecurityManager() 获取安全管理器 26、System.inheritedChannel() 返回从创建此Java虚拟机的实体继承得到的channel","tags":[]},{"title":"Random","date":"2019-08-31T02:56:32.000Z","path":"2019/08/31/Random/","text":"一、Random类的定义Random类位于 java.util 包中，主要用于生成伪 随机数 Random类将 种子数 作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关 创建Random实例时，若没有指定种子数，则会以 当前时间 作为种子数，来计算生成伪随机数 拥有 相同种子 的Random实例，在相同次数下，生成的伪随机数完全相同 1234Random random1 = new Random(10);Random random2 = new Random(10);System.out.println(random1.nextInt()); // -1157793070System.out.println(random2.nextInt()); // -1157793070 二、Random类的常用方法 1、random.nextBoolean() 用于从该随机数生成器的序列中得到下一个伪均匀分布的boolean值 2、random.nextBytes() 用于生成随机字节并将其放入用户提供的byte数组中 3、random.nextDouble() 用于从该随机数生成器的序列中得到下一个伪均匀分布在0.0到1.0之间的double值，[0.0, 1.0) 4、random.nextFloat() 用于从该随机数生成器的序列中得到下一个伪均匀分布在0.0到1.0之间的float值，[0.0, 1.0) 5、random.nextInt() random.nextInt() 用于从该随机数生成器的序列中得到下一个伪均匀分布的int值 random.nextInt(int bound) 用于从该随机数生成器的序列中得到下一个0到结束值之间伪均匀分布的int值，[0, 结束值) 6、random.nextGaussian() 用于从该随机数生成器的序列中得到下一个伪均匀分布的double值 生成的double值符合均值为0，方差为1的正态分布(高斯分布) 7、random.setSeed(long seed) 设置随机种子","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"Date","date":"2019-08-31T02:56:22.000Z","path":"2019/08/31/Date/","text":"一、Date类的定义 Date类位于 java.util 包中，主要用来封装当前的日期和时间， Date 类提供两个构造函数来实例化 Date 对象 Date()：使用当前日期和时间来初始化对象 Date(long milliseconds)：接收一个long类型的参数，该参数是从1970-01-01 00:00:00.000到当前时间的毫秒数 1234567Date date = new Date();// 打印Date对象// Sat：表示周六// Aug：表示八月// GMT：格林威治标准时间// GMT+08:00：东八区即标准北京时间System.out.println(date); // Sat Aug 11 17:03:32 GMT+08:00 2018 二、Date类的常用方法 1、getTime() 得到时间毫秒数 2、setTime(long milliseconds) 设置时间毫秒数 3、equals(Object obj) 比较两个时间是否相等 4、after(Date when) 测试目标日期是否在参数日期之后 5、before(Date when) 测试目标日期是否在参数日期之前 6、compareTo(Date anotherDate) 对两个Date对象进行比较 1234SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");Date date1 = sdf.parse(\"2018-08-10 08:08:123\");Date date2 = sdf.parse(\"2018-08-10 08:08:123\");System.out.println(date1.compareTo(date2)); // 0 如果目标日期在参数日期之后，则返回1 如果目标日期在参数日期之前，则返回-1 7、toInstant() 注意：Instant输出的是标准时间，即格林威治标准时间，而Date输出的是北京时间，两者相差8个小时 返回一个时间线上与此日期相同的一个点","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"Collections","date":"2019-08-31T02:56:11.000Z","path":"2019/08/31/Collections/","text":"1. 排序操作（主要针对List接口相关） reverse(List list)：反转指定List集合中元素的顺序 shuffle(List list)：对List中的元素进行随机排序（洗牌） sort(List list)：对List里的元素根据自然升序排序 sort(List list, Comparator c)：自定义比较器进行排序 swap(List list, int i, int j)：将指定List集合中i处元素和j出元素进行交换 rotate(List list, int distance)：将所有元素向右移位指定长度 2. 查找和替换（主要针对Collection接口相关） binarySearch(List list, Object key)：使用二分搜索法，以获得指定对象在List中的索引，前提是集合已经排序 max(Collection coll)：返回最大元素 max(Collection coll, Comparator comp)：根据自定义比较器，返回最大元素 min(Collection coll)：返回最小元素 min(Collection coll, Comparator comp)：根据自定义比较器，返回最小元素 fill(List list, Object obj)：使用指定对象填充 frequency(Collection Object o)：返回指定集合中指定对象出现的次数 3. 同步控制Collections工具类中提供了多个synchronizedXxx方法，该方法返回指定集合对象对应的同步对象，从而解决多线程并发访问集合时线程的安全问题。HashSet、ArrayList、HashMap都是线程不安全的，如果需要考虑同步，则使用这些方法。这些方法主要有：synchronizedSet、synchronizedSortedSet、synchronizedList、synchronizedMap、synchronizedSortedMap。 特别需要指出的是，在使用迭代方法遍历集合时需要手工同步返回的集合。 4. 设置不可变集合Collections有三类方法可返回一个不可变集合： emptyXxx()：返回一个空的不可变的集合对象 singletonXxx()：返回一个只包含指定对象的，不可变的集合对象。 unmodifiableXxx()：返回指定集合对象的不可变视图 5、其他 disjoint(Collection c1, Collection c2) - 如果两个指定 collection 中没有相同的元素，则返回 true。 addAll(Collection&lt;? super T&gt; c, T… a) - 一种方便的方式，将所有指定元素添加到指定 collection 中。示范： Collections.addAll(flavors, “Peaches ‘n Plutonium”, “Rocky Racoon”); Comparator reverseOrder(Comparator cmp) - 返回一个比较器，它强行反转指定比较器的顺序。如果指定比较器为 null，则此方法等同于 reverseOrder()（换句话说，它返回一个比较器，该比较器将强行反转实现 Comparable 接口那些对象 collection 上的自然顺序）。","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"Arrays","date":"2019-08-31T02:55:55.000Z","path":"2019/08/31/Arrays/","text":"一、Arrays类的定义 Arrays类位于 java.util 包中，主要包含了操纵数组的各种方法 二、Arrays类的常用方法 1、Arrays.asList(T… data) 注意：该方法返回的是Arrays内部静态类ArrayList，而不是我们平常使用的ArrayList,，该静态类ArrayList没有覆盖父类的add, remove等方法，所以如果直接调用，会报UnsupportedOperationException异常 可接受可变参数，数组等 2、Arrays.fill() Arrays.fill(Object[] array, Object obj) 用指定元素填充整个数组（会替换掉数组中原来的元素） Arrays.fill(Object[] array, int fromIndex, int toIndex, Object obj) 用指定元素填充数组，从起始位置到结束位置，取头不取尾（会替换掉数组中原来的元素） 左闭右开原则 Integer[] data = {1, 2, 3, 4}; Arrays.fill(data, 0, 2, 9); System.out.println(Arrays.toString(data)); // [9, 9, 3, 4] 3、Arrays.sort() Arrays.sort(Object[] array) 对数组元素进行排序（串行排序） Arrays.sort(T[] array, Comparator&lt;? super T&gt; comparator) 使用自定义比较器，对数组元素进行排序（串行排序） Arrays.sort(Object[] array, int fromIndex, int toIndex) 对数组元素的指定范围进行排序（串行排序） 4、Arrays.parallelSort() 注意：其余重载方法与 sort() 相同 Arrays.parallelSort(T[] array) 对数组元素进行排序（并行排序），当数据规模较大时，会有更好的性能 5、Arrays.binarySearch() 二分查找 注意：在调用该方法之前，必须先调用sort()方法进行排序，如果数组没有排序， 那么结果是不确定的，此外如果数组中包含多个指定元素，则无法保证将找到哪个元素 Arrays.binarySearch(Object[] array, Object key) 使用 二分法 查找数组内指定元素的索引值 Arrays.binarySearch(Object[] array, int fromIndex, int toIndex, Object obj) 使用 二分法 查找数组内指定范围内的指定元素的索引值 6、Arrays.copyOf() Arrays.copyOf(T[] original, int newLength) 拷贝数组，其内部调用了 System.arraycopy() 方法，从下标0开始，如果超过原数组长度，会用null进行填充 7、Arrays.copyOfRange(T[] original, int from, int to) 拷贝数组，指定起始位置和结束位置，如果超过原数组长度，会用null进行填充 8、Arrays.equals(Object[] array1, Object[] array2) 判断两个数组是否相等，实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2) 9、Arrays.deepEquals(Object[] array1, Object[] array2) 判断两个多维数组是否相等，实际上比较的是两个数组的哈希值，即 Arrays.hashCode(data1) == Arrays.hashCode(data2) 10、Arrays.hashCode(Object[] array) 返回数组的哈希值 11、Arrays.deepHashCode(Object[] array) 返回多维数组的哈希值 12、Arrays.toString(Object[] array) 返回数组元素的字符串形式 13、Arrays.deepToString(Object[] array) 返回多维数组元素的字符串形式 14、Arrays.setAll(T[] array, IntFunction 12345Integer[] data = &#123;2, 3, 4, 5&#125;;// 第一个元素2不变，将其与第二个元素3一起作为参数x, y传入，得到乘积6，作为数组新的第二个元素// 再将6和第三个元素4一起作为参数x, y传入，得到乘积24，作为数组新的第三个元素，以此类推Arrays.parallelPrefix(data, (x, y) -&gt; x * y);System.out.println(Arrays.toString(data)); // [2, 6, 24, 120] 16、Arrays.spliterator(T[] array) 返回数组的分片迭代器，用于并行遍历数组 17、Arrays.stream(T[] array) 返回数组的流Stream，然后我们就可以使用Stream相关的许多方法了","tags":[{"name":"常用类","slug":"常用类","permalink":"http://cxqiang.gitee.io/blog/tags/常用类/"}]},{"title":"正则表达式","date":"2019-08-31T02:37:46.000Z","path":"2019/08/31/正则表达式/","text":"正则表达式正则表达式就是以某种方式来描述字符串 可以用来匹配字符串来找到你需要的 String类的分隔split 和 replace方法可以放入正则表达式的参数 matches 匹配正则表达式的方法 符号定义基本书写符号 符号 符号 示例 解释 匹配输入 \\ 转义符 * 符号“*” * [ ] 可接收的字符列表 [efgh] e、f、g、h中的任意1个字符 e、f、g、h [^] 不接收的字符列表 [^abc] 除a、b、c之外的任意1个字符，包括数字和特殊符号 m、q、5、* | 匹配“|”之前或之后的表达式 ab|cd ab或者cd ab、cd ( ) 将子表达式分组 (abc) 将字符串abc作为一组 abc - 连字符 A-Z 任意单个大写字母 大写字母 限定符限定符将可选数量的数据添加到正则表达式，下表为常用限定符： 符号 含义 示例 示例 匹配输入 不匹配输入 * 指定字符重复0次或n次 (abc)* 仅包含任意个abc的字符串，等效于\\w* abc、abcabcabc a、abca + 指定字符重复1次或n次 m+(abc)* 以至少1个m开头，后接任意个abc的字符串 m、mabc、mabcabc ma、abc ? 指定字符重复0次或1次 m+abc? 以至少1个m开头，后接ab或abc的字符串 mab、mabc、mmmab、mmabc ab、abc、mabcc {n} 只能输入n个字符 [abcd]{3} 由abcd中字母组成的任意长度为3的字符串 abc、dbc、adc a、aa、dcbd {n,} 指定至少 n 个匹配 [abcd]{3,} 由abcd中字母组成的任意长度不小于3的字符串 aab、dbc、aaabdc a、cd、bb {n,m} 指定至少 n 个但不多于 m 个匹配 [abcd]{3,5} 由abcd中字母组成的任意长度不小于3，不大于5的字符串 abc、abcd、aaaaa、bcdab ab、ababab、a ^ 指定起始字符 ^[0-9]+[a-z]* 以至少1个数字开头，后接任意个小写字母的字符串 123、6aa、555edf abc、aaa、a33 $ 指定结束字符 ^[0-9]-[a-z]+$ 以1个数字开头后接连字符“–”，并以至少1个小写字母结尾的字符串 2-a、3-ddd、5-efg 33a、8-、7-Ab 匹配字符集匹配字符集是预定义的用于正则表达式中的符号集。如果字符串与字符集中的任何一个字符相匹配，它就会找到这个匹配项。 正则表达式中的部分匹配字符集: 符号 含义 示例 示例 匹配输入 不匹配输入 . 匹配除 \\n 以外的任何字符 a..b 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 aaab、aefb、a35b、a#*b ab、aaaa、a347b \\d 匹配单个数字字符，相当于[0-9] \\d{3}(\\d)? 包含3个或4个数字的字符串 123、9876 123、9876 \\D 匹配单个非数字字符，相当于[^0-9] \\D(\\d)* 以单个非数字字符开头，后接任意个数字字符串 a、A342 aa、AA78、1234 \\w 匹配单个数字、大小写字母字符，相当于[0-9a-zA-Z] \\d{3}\\w{4} 以3个数字字符开头的长度为7的数字字母字符串 234abcd、12345Pe 58a、Ra46 \\W 匹配单个非数字、大小写字母字符，相当于[^0-9a-zA-Z] \\W+\\d{2} 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 #29、#?@10 23、#?@100 分组构造常用分组构造形式: 常用分组构造形式 说明 () 非命名捕获。捕获匹配的子字符串（或非捕获组）。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 (?) 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如 (?’name’) 字符转义如果你想查找元字符本身的话，比如你查找.,或者,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用.和\\。当然，要查找\\本身，你也得用\\ 例如：deerchao.net匹配deerchao.NET，C:\\Windows匹配C:\\Windows。注意在Java中: (https://github\\\\.com/[\\\\w\\\\-]) 用”\\.”配备”.”。 常用正则表达式举例 非负整数：“^\\d+$ ” 正整数： “ ^[0-9][1-9][0-9]$” 非正整数： “ ^((-\\d+)|(0+))$” 整数： “ ^-?\\d+$” 英文字符串： “ ^[A-Za-z]+$” 英文字符数字串： “ ^[A-Za-z0-9]+$” 英数字加下划线串： “^\\w+$” E-mail地址：“^[\\w-]+(.[\\w-]+)*@[\\w-]+(.[\\w-]+)+$” URL：“^[a-zA-Z]+://(\\w+(-\\w+))(.(\\w+(-\\w+)))(?\\s)?$” Petteren 和 MatcherPattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可 以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, CharSequence 接口有 CharBuffer,String,StringBuilder,StringBuffer Pattern类详解 Pattern表示编译后的正则表达式 Pattern 12345678910111. static Pattern compile(String regex) //将给定的正则表达式编译并赋予给Pattern类2. static Pattern compile(String regex, int flags) //同上，但增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ 3. int flags() //返回当前Pattern的匹配flag参数. 4. String[] split(CharSequence input) 分隔字符串 //快速判断匹配 5.Pattern.matcher(String regex,CharSequence input)//返回一个Matcher对象6.Pattern.matcher(CharSequence input) Matcher对象 123456789101112131415161718192021222324252627282930313233matches()Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.matches();//返回false,因为bb不能被\\d+匹配,导致整个字符串匹配未成功. Matcher m2=p.matcher(\"2223\"); m2.matches();//返回true,因为\\d+匹配到了整个字符串1. Pattern.matcher(String regex,CharSequence input),它与下面这段代码等价 Pattern.compile(regex).matcher(input).matches()2. matches是整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。但如果前部分匹配成功，将移动下次匹配的位置。2.lookingAt()Matcher m=p.matcher(\"22bb23\"); m.lookingAt();//返回true,因为\\d+匹配到了前面的22 Matcher m2=p.matcher(\"aa2223\"); m2.lookingAt();//返回false,因为\\d+不能匹配前面的aa lookingAt是部分匹配，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配。Pattern p = Pattern.compile(expression); // 正则表达式 Matcher m = p.matcher(text); // 操作的字符串 while (m.find()) &#123; matcher.start(); matcher.end(); matcher.group(1);&#125;1. find()是部分匹配，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。2. find()从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。 https://www.cnblogs.com/ggjucheng/p/3423731.html","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"泛型","date":"2019-08-31T01:34:09.000Z","path":"2019/08/31/泛型/","text":"泛型是什么？一般的类和方法，只能使用具体的类型，要么是自定义的类，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大,所有要使代码应用于“某种不具体的类型”， 于是引入了泛型 泛型实现了参数化类型的概念，使代码可以应用于多种类型 “泛型”意思就是适用于许多类型 一般我们是用Object类来存储任何类型 123456789101112public class Demo &#123; Object value; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125; &#125; 这样使用,只不过要的到具体类型时，需要强制转换 12345Demo demo = new Demo();demo.setValue(111); //自动装箱成Integer类型int value = (int) demo.getValue();demo.setValue(\"123\");String s = (String) demo.getValue(); 泛型却给我们带来了全新的编程体验 12345678910111213141516171819202122public class Demo&lt;T&gt; &#123; T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; public static void main(String[] args) &#123; Demo&lt;Integer&gt; demo = new Demo&lt;Integer&gt;(); demo.setValue(123); int value = demo.getValue(); Demo&lt;String&gt; demo1 = new Demo&lt;String&gt;(); demo1.setValue(\"123\"); String value1 = demo1.getValue(); // demo1.setValue(123); 错误 编译无法通过 &#125;&#125; 泛型除了可以将类型参数化外，而参数一旦确定好，如果类似不匹配，编译器就不通过。 所以，综合上面信息，我们可以得到下面的结论。 与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。 当具体的类型确定后，泛型又提供了一种类型检测的机制，只有相匹配的数据才能正常的赋值，否则编译器就不通过。所以说，它是一种类型安全检测机制，一定程度上提高了软件的安全性防止出现低级的失误。 泛型提高了程序代码的可读性，不必要等到运行的时候才去强制转换，在定义或者实例化阶段，因为 Cache这个类型显化的效果，程序员能够一目了然猜测出代码要操作的数据类型。 泛型方法原则：无论何时，只要你能做的，就尽可能使用泛型方法 要定义泛型方法,只需将泛型参数列表置于返回值之前 123public &lt;T&gt; T f() &#123;&#125;; 这是泛型方法；public int f（T a）&#123;&#125;；这不是泛型方法，返回值前无泛型。","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"异常","date":"2019-08-31T01:21:07.000Z","path":"2019/08/31/异常/","text":"JAVA的基本理念是结构不佳的代码不能运行 1：概念程序在运行时出现的错误 使用异常的好处能够降低错误处理代码的复杂度,只需要异常机制来捕获这个错误，然后处理，而且把正常的情况和非正常的处理代码相互隔离 2：基本异常异常情形是指阻止当前方法或者作用域继续执行的问题 抛出异常指：当前不解决问题，将问题交给上一级 throw new NullPointerException() 抛出异常后发生的事情 1）会在堆上 new 异常对象 2）当前的执行路径会终止，并且弹出异常的引用 3）异常处理机制会接管程序 4）异常处理程序会在特定的地方执行 使程序能从错误中恢复，或者以另一种方式运行或继续运行下去 异常会让我们（如果没有其他手段）强制程序（当前线程）停止，并告诉我们出现了什么问题，或者处理异常，并返回稳定状态 异常参数： 异常对象与其他对象一样，有两个构造器，默认构造器和字符串为参数的构造器 throw new NullPointerException(“t = null”) 其中throw 相当于”放回“这个异常对象 能够抛出任意类型的Throwable对象，它是异常类型的根类 3：捕获异常12345try&#123;&#125;catch(Type1 id1 )&#123;&#125; try块 捕获抛出的异常 catch 异常处理程序 可以有多个来处理不同的异常 对捕获的对应的异常Type1 id1进行处理 4：创建自定义的异常继承Exception异常类 有默认的构造器和 字符串参数的构造器就行 *异常以及记录日志 * 5：异常的说明 属于方法声明的一种 在方法后面 throws 异常列表 (相当于抛出异常将该方法的异常让别人理) 6：捕获所有的异常在catch(Exception e) 捕获异常的基类 放在最后一个catch，防止抢在其他具体异常处理前面 栈轨迹 printStackTrace（） 返回一个轨迹栈中元素所构成的数组，每个元素对应栈的一个栈帧第一 个方法在栈顶，最后在栈低，捕获后，重新抛出异常 throw Exception() 123456789Throwable的方法String getMessage() 获取详细信息String getLocalMessage() 用本地语言描述的详细信息String toString()简单描述fillInStackTrace(),原来异常点消失，只剩下新的抛出点信息（比如你捕获一个异常 然后从新把它抛出 可以调用这个方法） 异常链 在捕获一个异常后，抛出另一个异常，并且把原始异常信息保存下来，Throwable的子类在构造中可以接受一个 cause对象（原始的异常也是Throwable类）这样就可以将元素的异常传递个新的异常，可以通过最新的异常来递归的跟踪到原始的异常 7:JAVA标准异常 Throwable：任何可以作为异常抛出的类 Error：编译和系统错误 Exception，可抛出的基本类型 特例RuntimeException 运行时异常，不需要再声明方法中抛出，也被称为 不受检查异常，这种异常属于错误，将自 动捕获 务必记住：只能在代码中忽略RuntimeException及其子类的异常，其他类型的异常由编译器 强制实施的，究其原因，RuntimeException代表编程错误，无法预料的错误， 8：使用finally进行清理在运行完try 或者 catch 后必须执行的操作，一定执行的操作 123456789int i=1;try &#123; int x=1/0;&#125; catch (Exception e) &#123; return i;&#125;finally &#123; return -1;&#125; 上面代码返回的是 -1，因为finally中的return 会覆盖掉之前的 可以用来释放资源 如关闭一些流，即使在前面有return，finally也会执行，除非是 exit(0) 缺憾：异常丢失：前一个异常还没处理就抛出了下一个异常 9：异常的匹配系统会自动的找到最近的处理程序 catch块 1234567891011try&#123;&#125;catch（Type1 id1）&#123;&#125;catch(Type2 id2)&#123;&#125;...&#125;finally&#123;&#125; 在try捕获到异常会自上到下逐一的匹配 异常然后执行相应的catch，就结束执行finally了 把最大的放在后面 Exception ,如果放前面 会覆盖后面的 从而不知道具体的异常了 10：其他可选方式把异常给控制台 在main 抛出异常 throws 把被检查异常，转换成 不检查异常 将抛出了异常 e 用RuntimeException封装并且抛出","tags":[{"name":"java基础","slug":"java基础","permalink":"http://cxqiang.gitee.io/blog/tags/java基础/"}]},{"title":"内部类","date":"2019-08-30T14:27:30.000Z","path":"2019/08/30/内部类/","text":"内部类：将一个类定义在另一个类的定义内部1：创建内部类也是用class 关键字在类的内部创建个class类 不过，如果想从外部类的非静态方法之外的任意位置创建某个内部类对象，必须指明这个对象的 类型 OuterClassName.InnerClassName 2:链接到外部类当生成一个内部类对象时，此对象能访问外围对象的所有成员 指明做到的：某个外围累的对象创建一个内部类时，内部类的对象会秘密的获取外部类对象的一 个引用 3：使用.this 和 .new当你需要使用外部对象的引用时，可以用外部类的名称加 .this 当你创建外部类的对象的时候 可以用外部类的引用来调用 .new 加内部类的构造器 12345678910111213141516171819202122232425262728293031Inner i= new Outer().new Inner();即Outer o=new Outer();Inner i= o.new Inner();//静态内部类可以直接访问package com.xiaoqiang.day10;/** * @author xiaoqiang * @date 2019/7/13-15:26 */public class Outer &#123; public static class Inner &#123; public void f() &#123; System.out.println(\"静态内部类\"); &#125; &#125; public static void main(String[] args) &#123; Inner i = new Inner(); i.f(); &#125;&#125; 必须使用外部类的对象来创建内部类的对象 但是静态内部类，可直接访问 4：内部类向上转型当内部类被声明为 private时 除了在外部类的方法内部和它自己，没人访问他 设为protected 则只有子类和同包的能访问 5：在方法和作用域中的内部类场景：你实现了某个接口，想要返回这个类型 需要解决复杂的问题，需要用到这个类但不希望它是公共的 成员内部类：有权限修饰符,也可以是静态的，但是不能访问外部类中非静态的成员 12345public class Outer &#123; /*static*/ class Inner &#123; &#125;&#125; 局部内部类：在方法里面的类，类是方法的一部分，在方法（域）之外是不能访问的，当然你可以return这个类的基类引用，在方法内 定义的类，不能有修饰访问符，public等，可以访问外部内所有成员 123456789public class Outer &#123; public void method() &#123; class Inner &#123; &#125; Inner i = new Inner(); &#125; //方法外就无法访问到了&#125; 匿名内部类：就是在方法返回时 return new Content(){ （可以是带有参数的构造器） //定义者个类 }; 1234567891011121314151617interface Demo &#123; void fun();&#125;public class Outer &#123; public static void main(String[] args) &#123; int i=0; Object x = new Object(); Demo demo = new Demo() &#123; @Override public void fun() &#123;// i++; 不想修改,默认为为final System.out.println(i); &#125; &#125;; &#125;&#125; 例如我们经常使用的 创建线程任务的时候就经常用到匿名内部类 在匿名内部类中，希望它使用一个在外部定义的对象，那么要求 方法的参数必须为final的 即使（JAVA8）已经不强制添写final，但当你修改的时候回报错。 为什么加final，防止外部类的引用改变了，而内部类中的没改变， 简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。 ​ 故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。 在匿名内部类中使用 则参数 要为 final 在匿名内部类中的基类使用 不要 匿名内部类中没有构造器（因为它没有名字），一般用构造代码块来初始类 { 。。。} 匿名内部类为扩展类可以实现接口和继承类 ，但也只能实现一个接口 匿名内部类中不能存在任何的静态成员变量和静态方法 6：工厂方法我们可以用匿名内部类来返回实例 7：嵌套类（静态内部类）如果不需要让内部类对象与外围类对象有关联的话，可以将内部类声明为static，这就称为嵌套类 1）要创建嵌套类的对象，并不需要访问外部类对象 2）不能访问非静态的外围类成员 普通内部类的字段和方法不能声明为 static，不能包含嵌套类 而嵌套类可以 接口内部类；默认也是 static public ，在创建某些公共代码，使他们被某个接口的不同实现来使用 8：为什么需要内部类：1）内部类提供了进入其外围类的窗口 2）内部类能独立的继承某个类（接口的）实现，无论外围类怎么样，对内部类没影响 特性： 1）内部类可以多个实例，每个实例可以有自己的状态信息，并且与外围类相互独立的 2）在单个外围类中可以让多个内部类以不同的方式实现同一个接口 3）内部类对象创建的时候不依赖外围类对象的创建 4）是一个独立的实体 闭包和回调 闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域 .内部类和控制框架 控制框架的完整实现是有单个创建的，从而使的实现的细节被封装起来 内部类能容易的访问外围类的任意成员 9:内部类的继承因为内部类的构造器必须连接其他外围类的对象引用，所以继承内部类，必须把外围类对象的引 用初始化用外围类的参数传递，调用 Outer.super() 10:内部类可以被覆盖吗？不会，每个内部类都是个独立的存在 ####","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://cxqiang.gitee.io/blog/tags/Java基础/"}]},{"title":"面向对象与面向过程","date":"2019-08-29T13:43:52.000Z","path":"2019/08/29/面向对象与面向过程/","text":"1：面向对象编程 OOP Object-oriented Programming 万物皆对象 程序是对象的集合，它们通过发送消息来告知彼此所要做的 每个对象都有自己的有其他对象所构成的存储 每个对象都有其类型 某一特定类型的所有对象都可以接受同样的消息 对象具有自己的状态（内部数据）， 行为（方法），标识（内存地址） 2：面向对象与面向过程面向过程：你拿扫帚去打扫房间，主体是你，取扫帚，大扫地，一系列动作都需要你自己完成； 面向对象：把扫地机器人当成主体对象，相当于个活物，机器人主动去打扫卫生，至于如何打扫完，跟你没关系。 因此，面向过程，是人在干活。面向对象，相当于人创造机器人去干活。 站在计算机程序角度来讲，面向过程和面向对象的本质理解为： 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 总的来说：面向对象是将事物高度抽象化，面向对象必须先建立抽象模型，之后直接使用模型就行了；面向过程是一种自顶向下的编程 3、面向对象的特征封装: 隐藏对象属性和实现的细节，仅向外提供公共访问的接口 继承：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 多态：一个对象在程序不同运行时刻有多个不同状态，父类或者接口的引用指向子类对象","tags":[{"name":"面对对象","slug":"面对对象","permalink":"http://cxqiang.gitee.io/blog/tags/面对对象/"}]},{"title":"多态","date":"2019-08-29T13:43:26.000Z","path":"2019/08/29/多态/","text":"多态：同一个行为具有多个不同表现形式或形态的能力1：向上转型对象可以作为它自己本身的类型使用,也可以作为它的基类类型使用，而将某个对象的引用视为对 其基类型的引用的做法，被称为向上转型 （子类-&gt;基类） 忘记对象类型:用基类来传参 2：转机将一个方法调用和一个方法主体关联起来叫做绑定 前期绑定：程序执行前进行绑定（由编译器和连接程序实现 如 C） 后期绑定：在运行时根据对象的类型进行绑定，也叫动态绑定或运行时绑定 JAVA中除了static和final方法都是后期绑定 因此将方法定义为 final 即private的可以关闭动态绑定产生正确的行为 若导出类覆盖了基类的接口，由于后期绑定的机制即时是基类的引用但对象是导出类的还是会调用导出类的方法，所以编写代码可以与只基类打交道 可扩展性：只与基类接口通信，这样可以覆盖然后不用管新有什么类型，就可以通过基类的引用调用子类的覆盖的方法，那些操纵基类的方法接口不需要做任何的改动 缺陷：“覆盖”私有方法： 对于私有的方法是不能覆盖的 域与静态方法和字段域不具有多态，**如果某个方法是静态的，它是行为不具有多态性**3：构造器与多态构造器实际上是static方法，不过声明是隐形的 构造器的调用顺序 调用基类的构造器 按声明顺序调用成员的初始化方法 调用构造器的主体 123456789101112131415161718192021222324252627282930313233343536373839package com.xiaoqiang.day_7_11;/** * @author xiaoqiang */public class Glyph &#123; void draw() &#123; System.out.println(\"Glyph.draw()\"); &#125; Glyph() &#123; //1 先初始化父类 调用父类构造器 System.out.println(\"Glyph() before draw()\"); //2 draw(); //因为多态 调用的是子类覆盖的方法 即子类的draw 3 System.out.println(\"Glyph() after draw()\"); //4 &#125;&#125;class RoundGlyph extends Glyph &#123; private int radiu = 1; //5 RoundGlyph(int r) &#123; radiu = r; //6 System.out.println(\"RoundGlyph.RoundGlyph(),radius = \"+ radiu);//7 &#125; void draw() &#123; //3 在父类构造器中调用了，此时radiu还为被初始化，所有为0 System.out.println(\"RoundGlyph.draw(),radius = \" + radiu); &#125;&#125;输出是Glyph() before draw()RoundGlyph.draw(),radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(),radius = 5 构造器内部多态方法的行为初始化的顺序是 在其他任何事物都没有发生之前，讲分配给对象存储空间初始化为二进制的0 赋初值 如前所诉那样先调用基类构造器，此时，调用被覆盖后的draw（）方法（会在导出类构造方法 之前调用），会由于步骤1的原因，会发现 变量radius为0 按声明的顺序调用成员的初始化方法 调用用导出类的构造器 所以在构造器中尽可能的避免调用其他的方法，唯一能安全调用的是final（private）方法，因为 这些方法是不能被覆盖的 4：协变返回类型 方法中可以返回它与其子类5：用继承来进行设计用继承表达行为间的差异，并用字段表达状态上的变化 6：纯继承以扩展导出类与基类有着相同的接口 缺点:导出类中的接口的扩展部分不能被基类访问，因此我们一旦向上转型，就不能调用导出类的","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"继承","date":"2019-08-29T13:43:19.000Z","path":"2019/08/29/继承/","text":"1、概念：继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。 即导出类继承了 父类（基类）的所有成员与接口（尽管private但是不能访问和使用） 当继承现有类时，也就是创造了新的类型，这个新的类型（导出类具有和基类相同的类型） 2：继承语法关键词： extends ​ 会自动的得到基类中所有的域和方法（尽管private但是不能访问和使用） ​ super 基类（父类）的引用 初始化基类 构造过程是从基类向外扩散的，所以是先初始化基类然后是子类 当父类有带参数的构造器时，用super调用 super(参数) 3：特点单根继承结构 所有都继承与一个终极基类 Object 好处 可以在每个对象上执行某些基本操作 tostring等方法 所有对象都很容易在堆上创建 参数的传递也得到了极大的简化 使垃圾回收器的实现变得容易得多 由于所有对象都保证具有其类型信息，因此不会因无法确定对象的类型而陷入僵局，这对于系统级操作（如异常处理）显得尤为重要 4、继承的好处： 继承提高了代码的复用性 继承的出现让类与类产生了关联，提供了多态的前提 5、父子类中成员的关系成员变量 成员方法 构造方法 子类实例化时，必须先实例化父类对象(默认是调用父类的无参构造器即 super（）),而且是在子类构造器 第一行代码 写上 super（） 若是有参构造器,则 super(2）带上对应的参数 重写与重载 重载：同一个类中，方法名相同，参数列表不同，重载可以改变返回类型 重写/覆盖 ： 在不同类中(子父类）,方法的名称，参数，返回值都相同 6、this和super关键字 this代表子类本身引用 super代表 父类的引用","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"封装","date":"2019-08-29T13:43:13.000Z","path":"2019/08/29/封装/","text":"1、概念封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。 2、好处 比如我们常用将类的属性设置为private的，然后通过get set方法来访问 良好的封装能够减少耦合。 外部只能通过 暴露的接口访问类的信息（get，set方法） 类内部的结构可以自由修改。 当你要修改 类中的一个日期Date型 问 String时 可以对成员进行更精确的控制。 比如说对 年龄age属性现在 可以在 set方法里 设置 if(age&gt;100|| age&lt;0) 抛出异常 隐藏信息，实现细节。 可以对外不提供一些属性的 get等外部访问方法，从而隐藏信息","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"接口和抽象类","date":"2019-08-29T13:42:59.000Z","path":"2019/08/29/接口和抽象类/","text":"1：抽象类和抽象方法** 抽象类，包含抽象方法的类，在包含抽象方法时，必须在类前面声明为 abstract class** 抽象类中可以包含普通的方法 其导出类必须实现抽象方法,否则其导出类 也必须声明为 抽象类 抽象方法：方法前面声明为 abstract，并且没有方法体 包含抽象方法的类叫抽象类 抽象类 可以包含抽象方法和普通方法 但是普通的类不能包含抽象方法 作用：使类抽象性明确起来，并告诉用户和编译器如何使用它 2：接口：使抽象的概念更迈进一步关键字：interface interface不仅仅是一个极度抽象的类，还允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多继承变种的特性 interface这个关键字产生了一个完全抽象的类，只提供了形式而没有任何的实现 所有方法必须（自动的）是public 就像类一样 将class 用interface代替 也有访问权限的 public private 包访问 在接口中的字段 默认都是并且只能是 public static final的 方法必须是 public 的抽象方法（不能有方法体） 接口中不能有 代码块 {} 不管是不是static的 接口的实现：implements 抽象类是什么：抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。 (1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法 (2) 抽象类不能被实例化 (3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类 (4) 具体派生类必须覆盖基类的抽象方法 (5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们 接口是什么：(1) 接口不能被实例化 (2) 接口只能包含方法声明 (3) 接口的成员包括方法、属性、索引器、事件 (4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员 接口和抽象类的区别：（1）抽象类可以有构造方法，接口中不能有构造方法。 （2）抽象类中可以有普通成员变量，接口中没有普通成员变量 （3）抽象类中可以包含静态方法，接口中不能包含静态方法 （4） 一个类可以实现多个接口，但只能继承一个抽象类。 （5）接口可以被多重实现，抽象类只能被单一继承 （6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法 接口和抽象类的相同点：(1) 都可以被继承 (2) 都不能被实例化 (3) 都可以包含方法声明 (4) 派生类必须实现未实现的方法","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"类与对象","date":"2019-08-29T13:42:47.000Z","path":"2019/08/29/类与对象/","text":"1：什么是对象 可谓万物皆对象，对象是客观存在的的事物，可以说任何客观存在都可以成为对象，(一台电脑,一只笔，一辆车)，对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 每个对象都提供服务 高内聚低耦合 ​ 高内聚就是说相关度比较高的部分尽可能的集中，不要分散 ​ 低耦合就是说两个相关的模块尽可以能把依赖的部分降低到最小，不要让两个系统产生强依赖 2: 什么是类呢？ ​ 类就是对象的模板，它描述一类的对象的行为（方法）状态（属性） ​ 而对象就是类的一个实例","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cxqiang.gitee.io/blog/tags/面向对象/"}]},{"title":"this和super关键字","date":"2019-08-29T13:25:58.000Z","path":"2019/08/29/this_super/","text":"1. this this是自身的一个对象，代表对象本身，可以理解为：当前对象的引用。只能在方法内部使用 应用* 引用当前对象的成员变量和方法 * 引用类的构造器 this(参数) * 返回对象的值 return this注意：在构造器中调用构造器* 不能调用两个构造器，必须将构造器调用在起始位置，除了构造器外禁止在其他任何方法中调用构造器 2. super​ super是父类的一个对象，代表离自己最近的一个父类，可以理解为：父类的引用。只能在方法内部使用 应用 与this类似，应用父类的成员变量和方法 子类中的成员变量或方法与父类中的成员变量或方法同名123456789package demo;public class Country &#123; String name; void value() &#123; name = \"China\"; &#125;&#125; 123456789101112131415161718package demo;public class City extends Country&#123; String name; void value() &#123; name = \"Shanghai\"; super.value(); // 调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c = new City(); c.value(); &#125;&#125; 这输出的是Shanghai China可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法value()，只调用父类变量name的话，则父类name值为默认值null。 引用类的构造器 super(参数) （必须在构造器代码的第一行，默认都有父类构造器 super()在代码第一行的，若有参数就要显示的写出了）","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"权限修饰符","date":"2019-08-29T13:18:39.000Z","path":"2019/08/29/permission_controller/","text":"权限修饰符私有的权限private： private 可以修饰 数据成员，构造方法，方法成员，可以修饰成员内部类，被private修饰的成员，只能在定义了它们的类中使用，在其他的类中不能被调用，私有的，创建者和内部使用 默认权限：（default） 可修饰，类，数据成员，构造方法，方法成员，使用默认的权限，即不写任何的关键字，默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包 的类中被调用，且子类不能访问 （除非子类和它是在同一个包里面） 受保护的权限 protected protected可以修饰 数据成员，构造方法，方法成员，可以修饰成员内部类，被 protected修饰得到成员，被protected修饰的成员，能在定义它们的类中，同包 的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。 公有的权限 public 可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。 注意： 并不是每个修饰符都可以修饰类（指外部类），只有public和default可以。 所有修饰符都可以修饰数据成员，方法成员，构造方法。 在private放在构造器前面你不能调用new来创建对象：应用：单例模式 为了代码安全起见，修饰符不要尽量使用权限大的，而是适用即可。比如，数据成员，如果没有特殊需要，尽可能用private。 修饰符修饰的是“被访问”的权限。 为什么要权限控制 为了不让客户端触及和修改 为了让类库设计者可用更改类的内部工作方式，而不必担心会对用户造成影响。","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"static","date":"2019-08-29T12:54:11.000Z","path":"2019/08/29/static/","text":"static 在Java中并不存在全局变量的概念，但是我们可以通过static来实现一个“伪全局”的概念，在Java中static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，当然也可以修饰代码块。 同时被static修饰的成员变量和成员方法是独立于该类的，它不依赖于某个特定的实例变量，也就是说它被该类的所有实例共享。所有实例的引用都指向同一个地方，任何一个实例对其的修改都会导致其他实例的变化。 static可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。 静态方法- static方法就是没有this的方法。**在static方法内部不能调用非静态方法，反过来是可以的。**而且可以在没有创建任何对象的前提下，仅仅**通过类本身来调用static方法**。这实际上正是static方法的主要用途。 在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。但是在非静态方法中可以访问静态成员的 只能访问static变量 静态变量 static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 static变量并不是所在类的某个具体对象所有，而是该类的所有对象所共有的，静态变量既能被对象调用，也能直接拿类来调用。 静态代码块 static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 误区 static关键字并不会改变变量和方法的访问权限。只有private,public,protected,(包访问)才能改变其访问权限 在这里永远要记住一点：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够） 在Java中切记：static是不允许用来修饰局部变量。不要问为什么，这是Java语法的规定。 static和final一块用表示什么？ 1. static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！ 2. 对于变量，表示一旦给值就不可修改，并且通过类名可以访问。 3. 对于方法，表示不可覆盖，并且可以通过类名直接访问。 static的局限1. 它只能调用static变量。 2. 它只能调用static方法。 3. 不能以任何形式引用this、super。 4. static变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。总结： 无论是变量，方法，还是代码块，只要用static修饰，就是在类被加载时就已经”准备好了”,也就是可以被使用或者已经被执行，都可以脱离对象而执行。反之，如果没有static，则必须要依赖于对象实例。","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"final","date":"2019-08-29T12:31:13.000Z","path":"2019/08/29/final/","text":"finalfinal关键字在java中有“这是无法改变的”或者“终态的”含义，可以修饰类(非抽象的)，方法(非抽象的)，变量 final类不能被继承，没有子类，final类中的方法默认都是final的 final方法不能被子类覆盖，但可以被继承调用 final变量表示为常量，只能被赋值一次，赋值后值不在修改 final不能用于修饰构造方法 1. final类​ final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。我们见到的String类就是final类 2. final方法​ 把方法锁定，以防任何继承类修改它的含义，不能重载覆盖 ​ 注意：类的private方法会隐式地被指定为final方法 3. final变量 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 修饰成员变量时必须在定义或者构造器中赋值初始化(空白final) 修饰普通变量时必须赋值才能使用 4. final参数​ 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。 5. 应用- 一个永不改变的编译时常量 - 一个在运行时被初始化的值，不希望你改变他","tags":[{"name":"关键字","slug":"关键字","permalink":"http://cxqiang.gitee.io/blog/tags/关键字/"}]},{"title":"visitor","date":"2019-08-29T07:50:38.000Z","path":"2019/08/29/visitor/","text":"","tags":[]},{"title":"template","date":"2019-08-29T07:50:25.000Z","path":"2019/08/29/template/","text":"","tags":[]},{"title":"strategy","date":"2019-08-29T07:50:13.000Z","path":"2019/08/29/strategy/","text":"","tags":[]},{"title":"state","date":"2019-08-29T07:50:03.000Z","path":"2019/08/29/state/","text":"","tags":[]},{"title":"observer","date":"2019-08-29T07:49:55.000Z","path":"2019/08/29/observer/","text":"","tags":[]},{"title":"memento","date":"2019-08-29T07:49:46.000Z","path":"2019/08/29/memento/","text":"","tags":[]},{"title":"mediator","date":"2019-08-29T07:49:28.000Z","path":"2019/08/29/mediator/","text":"","tags":[]},{"title":"iterpreter","date":"2019-08-29T07:49:16.000Z","path":"2019/08/29/iterpreter/","text":"","tags":[]},{"title":"interpreter","date":"2019-08-29T07:49:02.000Z","path":"2019/08/29/interpreter/","text":"","tags":[]},{"title":"command","date":"2019-08-29T07:48:47.000Z","path":"2019/08/29/command/","text":"","tags":[]},{"title":"chain_of_responsibility","date":"2019-08-29T07:48:35.000Z","path":"2019/08/29/chain_of_responsibility/","text":"","tags":[]},{"title":"proxy","date":"2019-08-29T07:48:10.000Z","path":"2019/08/29/proxy/","text":"","tags":[]},{"title":"flyweight","date":"2019-08-29T07:48:00.000Z","path":"2019/08/29/flyweight/","text":"","tags":[]},{"title":"facade","date":"2019-08-29T07:47:49.000Z","path":"2019/08/29/facade/","text":"","tags":[]},{"title":"decorator","date":"2019-08-29T07:47:41.000Z","path":"2019/08/29/decorator/","text":"","tags":[]},{"title":"composite","date":"2019-08-29T07:47:27.000Z","path":"2019/08/29/composite/","text":"","tags":[]},{"title":"bridge","date":"2019-08-29T07:47:04.000Z","path":"2019/08/29/bridge/","text":"","tags":[]},{"title":"adapter","date":"2019-08-29T07:46:44.000Z","path":"2019/08/29/adapter/","text":"","tags":[]},{"title":"建造者模式","date":"2019-08-29T03:20:47.000Z","path":"2019/08/29/builder/","text":"建造者模式（Bulider）建造者模式能够将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。这句话理解起来可能有点抽象，简单来说就是调用相同的创建对象的方法（建造过程）可以创建出不同的对象。 举例说明：如果说创建一个电脑：我们需要几个核心的部件，比如说：主机，显示器，鼠标，键盘 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.xiaoqiang.gof23.createModel.builder.computer;/** * @author xiaoqiang * @date 2019/8/29-15:33 */public class Computer &#123; // 主机 private String host; // 显示器 private String monitor; // 键盘 private String keyboard; // 鼠标 private String mouser; public String getHost() &#123; return host; &#125; public void setHost(String host) &#123; this.host = host; &#125; public String getMonitor() &#123; return monitor; &#125; public void setMonitor(String monitor) &#123; this.monitor = monitor; &#125; public String getKeyboard() &#123; return keyboard; &#125; public void setKeyboard(String keyboard) &#123; this.keyboard = keyboard; &#125; public String getMouser() &#123; return mouser; &#125; public void setMouser(String mouser) &#123; this.mouser = mouser; &#125;&#125; 每一个电脑都是这个类的对象，在创建电脑时都需要保证这几个核心组件的创建，所以创建手机需要一个规范，因为几个核心部件都可以是不同的型号，不同的型号的部件制造出来的电脑也是不同的，这样就有了下面建造规范的接口。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"工厂模式","date":"2019-08-29T03:20:29.000Z","path":"2019/08/29/factory/","text":"Factory(工厂模式)1.核心本质是： 实例化对象，用工厂方法代替new操作。 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的 实现类解耦。 2.工厂模式1) 简单工厂模式（静态工厂模式） 用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已 有代码） 接口与实现类 车子接口 123public interface Car &#123; void run();&#125; 具体的奥迪 Audi 奥迪 和 Byd比亚迪实现类 123456789101112131415public class Audi implements Car &#123; @Override public void run() &#123; System.out.println(\"Audi Running\"); &#125;&#125;public class Byd implements Car &#123; @Override public void run() &#123; System.out.println(\"Byd Running\"); &#125;&#125; 第一种工厂实现 通过名称作为参数来创建实例 12345678910111213public class CarFactory &#123; public static Car creatCar(String type) &#123; if (\"Audi\".equals(type)) &#123; return new Audi(); &#125; else if (\"Byd\".equals(type)) &#123; return new Byd(); &#125; else &#123;// 修改增加新的类 违反了开闭原则OCP：扩展开放，修改关闭 return null; &#125; &#125;&#125; 第二种工厂实现 通过方法名来区分创建不同的实例， 123456789public class CarFactory02 &#123; public static Car creatAudi() &#123; return new Audi(); &#125; public static Car creatByd() &#123; return new Byd(); &#125;&#125; 测试 123456789101112131415161718public class Client02 &#123; /** * 简单工厂情况 * * 只要与工厂打交道，不要知道 具体的实现类 * 使用最多，需要修改已有的工厂类来增加新的类 * */ public static void main(String[] args) &#123; Car c1 = CarFactory.creatCar(\"Audi\"); Car c2 = CarFactory.creatCar(\"Byd\"); /* c1 = CarFactory02.creatAudi(); c2 = CarFactory02.creatByd();*/ c1.run(); c2.run(); &#125;&#125; 2) 工厂方法模式​ 用来生产同一等级结构中的固定产品。（支持增加任意产品） 还是原来的接口和实现类，但是多了一个工厂的接口，每个具体类都有对应的具体的工厂来创建对应的实例，当要添加新的实例时，只需要创建实现Car和CarFactory接口即可 工厂接口 只有一个创建方法 123public interface CarFactory &#123; Car createCar();&#125; 具体工厂实现实现类 1234567891011121314public class AudiFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Audi(); &#125;&#125;public class BydFactory implements CarFactory &#123; @Override public Car createCar() &#123; return new Byd(); &#125;&#125; 测试 123456789101112131415/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 工厂方法模式 * 根据对应的类，继承工厂接口，和相应的方法创建类返回 * * 不能修改已有类的前提下，通过增加新的工厂来实现扩展 */public class Cilcent &#123; public static void main(String[] args) &#123; Car c1 = new AudiFactory().createCar(); c1.run(); &#125;&#125; 3) 抽象工厂模式 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持 增加产品族） 比如说汽车 有发动机，座椅，轮胎三个组件合成，每个汽车有普通和智能型的，所有组件也分为普通和智能型的 首先是 每个组件的接口与实现类 发动机12345678910111213141516171819202122232425262728293031public interface Engine &#123; void run(); void start();&#125;//好发动机class LuxuryEngine implements Engine &#123; @Override public void run() &#123; System.out.println(\"转的快\"); &#125; @Override public void start() &#123; System.out.println(\"启动的块，自动启停\"); &#125;&#125;//不好的发动机class LowEngine implements Engine &#123; @Override public void run() &#123; System.out.println(\"转的慢\"); &#125; @Override public void start() &#123; System.out.println(\"启动的慢\"); &#125;&#125; 座椅12345678910111213141516171819public interface Seat &#123; void massage();&#125;class LuxuraySeat implements Seat &#123; @Override public void massage() &#123; System.out.println(\"可以自动按摩\"); &#125;&#125;class LowSeat implements Seat &#123; @Override public void massage() &#123; System.out.println(\"不可以自动按摩\"); &#125; 轮胎 12345678910111213141516171819public interface Tyre &#123; void revolve();&#125;class LuxurtTyre implements Tyre &#123; @Override public void revolve() &#123; System.out.println(\"旋转不磨损\"); &#125;&#125;class LowTyre implements Tyre &#123; @Override public void revolve() &#123; System.out.println(\"旋转磨损快\"); &#125;&#125; 其次是工厂的抽象类或接口 1234567public interface CarFactory &#123; Engine createEngine(); Seat createSeat(); Tyre createTrpe();&#125; 工厂的实现类 返回各种的组件 普通型1234567891011121314151617public class LowCarFactory implements CarFactory&#123; @Override public Engine createEngine() &#123; return new LowEngine(); &#125; @Override public Seat createSeat() &#123; return new LowSeat(); &#125; @Override public Tyre createTrpe() &#123; return new LowTyre(); &#125;&#125; 智能型1234567891011121314151617181920public class LuxuryCarFactory implements CarFactory &#123; @Override public Engine createEngine() &#123; return new LuxuryEngine(); &#125; @Override public Seat createSeat() &#123; return new LuxuraySeat(); &#125; @Override public Tyre createTrpe() &#123; return new LuxurtTyre(); &#125;&#125; 测试 可以增加一类产品族的，比如 XXX型的汽车的的组件，并且可以相互的组合 12345678910111213141516/** * @author xiaoqiang * @date $(DATE)-$(TIME) * * 抽象工厂 * * 不可以增加产品，可以增加产品族， */public class Client &#123; public static void main(String[] args) &#123; CarFactory carFactory = new LuxuryCarFactory(); Engine engine = carFactory.createEngine(); engine.run(); engine.start(); &#125;&#125; 工厂模式要点：– 简单工厂模式(静态工厂模式)• 虽然某种程度不符合设计原则，但实际使用最多。 – 工厂方法模式• 不修改已有类的前提下，通过增加新的工厂类实现扩展。 – 抽象工厂模式• 不可以增加产品，可以增加产品族！","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"原型模式","date":"2019-08-29T03:20:05.000Z","path":"2019/08/29/prototype/","text":"Prototype原型模式 也叫 克隆（复制）模式1.试用场景通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点 优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的 对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。 2.实现方式Cloneable接口和clone方法 Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了clone()方法替我们做了绝大部分事情。 潜克隆 （属性还是一样的，内存还是指向同一个） 深克隆 (把属性也进行拷贝) 实现深克隆的方法1：在clone方法 对象的字段属性也 要相应的设置为克隆的 1234567891011@Override protected Object clone() throws CloneNotSupportedException &#123; Object obj = super.clone(); //直接调用object的clone方法 //添加如下代码实现深克隆 //即新建一个对象，然后为其每个属性都克隆一份 // Sheep sheep = (Sheep) obj; // sheep.birthday = (Date) this.birthday.clone(); return obj; &#125; 2: 序列化和反序列化实现深克隆 （前提，克隆的类要实现序列化接口 Serializable） public class Sheep implements Cloneable, Serializable {} 123456789101112131415161718192021 Date date = new Date(1111111111); Sheep s1 = new Sheep(\"少莉\", date);// Sheep s2 = (Sheep) s1.clone(); // 使用序列化和反序列化来实现深克隆 //建立对象字节流，然后用对象流修饰，将要序列化的对象输出到字节数组中 //输出流就是 从流中的数据输出到其他形式，输出流 -&gt; 字节数组(文件等其他形式) ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); //输出流的write方法是将 输出流中的数据 写出来 oos.writeObject(s1); //获取字节数组 byte[] bytes = bos.toByteArray(); //通过字节数组输入到 字节输入流，然后通过Object流封装修饰 //输入流是把其他形式数据输入到输入流中去 字节数组(文件等其他形式)-&gt;输入流 //read方法是将输入流中的数据读取出来 ByteArrayInputStream bis = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bis); Sheep s2 = (Sheep) ois.readObject(); //克隆羊原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone 的方法创建一个对象，然后由工厂方法提供给调用者。 ​ spring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型 模式需要和工厂模式搭配起来）","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"单例模式","date":"2019-08-29T03:09:42.000Z","path":"2019/08/29/singleton/","text":"单例模式(Singleton)核心作用：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点 延迟加载：又叫懒加载，需要使用对象时才创建 常见的五种单例模式实现方式– 主要： 饿汉式（线程安全，调用效率高。 但是，不能延时加载。） 懒汉式（线程安全，调用效率不高。 但是，可以延时加载。） – 其他： 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用） 静态内部类式(线程安全，调用效率高。 但是，可以延时加载) 枚举式(线程安全，调用效率高，不能延时加载。并且可以天然的防止反射和反序列 化漏洞！) 如何选用?单例对象 占用 资源 少，不需要 延时加载： 枚举式 好于 饿汉式 单例对象 占用 资源 大，需要 延时加载： 静态内部类式 好于 懒汉式 1.饿汉式12345678910111213141516171819202122232425262728293031323334package com.xiaoqiang.gof23.createModel.singleton;import java.io.ObjectStreamException;/**- @author xiaoqiang * *饿汉式单例模式 */ public class SingletonDemo1 &#123; /**饿汉式单例模式 - 在加载的时候直接初始化时，立即加载这个并且创建这个对象，不能延迟 - 由于加载类时是天然的线程安全的 不用synchronized 同步锁，效率高 - */ private static SingletonDemo1 singletonDemo1 = new SingletonDemo1(); private SingletonDemo1() &#123; if (singletonDemo1 != null) &#123; // 防止反射破解单例 throw new RuntimeException(); &#125; &#125; public static /*synchronized*/ SingletonDemo1 getsingletonDemo1() &#123; return singletonDemo1; &#125;// 反正反序列化破解单例// 定义readResolve()则直接返回此方法的对象，不用单独在创建新的对象 private Object readResolve() throws ObjectStreamException &#123; return singletonDemo1; &#125;&#125; ​ 注意：关于防止反射和反序列化来破解单例模式的方法，一下就不一一列举了，都是一样的 2.懒汉式12345678910111213141516171819202122package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * 懒汉式, */public class SingletonDemo2 &#123; // 懒汉式,不初始化对象，延迟加载，需要的时候创建， // 要用到线程锁 synchronized，效率低了 private static SingletonDemo2 singletonDemo2; private SingletonDemo2() &#123; &#125; public static synchronized SingletonDemo2 getSingletonDemo2() &#123; if (singletonDemo2 == null) &#123; singletonDemo2 = new SingletonDemo2(); &#125; return singletonDemo2; &#125;&#125; 3.双重检测锁123456789101112131415161718192021222324252627282930313233343536package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * */public class SingletonDemo3 &#123; /**双重检查锁单例模式实现 * 将同步放到if的内部，提高了执行的效率 * 问题：由于编译器优化和jvm内部模型的原因，偶尔会出现问题，不建议使用 * * */ private static SingletonDemo3 singletonDemo3; private SingletonDemo3() &#123; &#125; private static SingletonDemo3 getSingletonDemo3() &#123; if (singletonDemo3 == null) &#123; SingletonDemo3 s; synchronized (SingletonDemo3.class) &#123; s = singletonDemo3; if (s == null) &#123; synchronized (SingletonDemo3.class) &#123; if (s == null) &#123; s = new SingletonDemo3(); &#125; &#125; singletonDemo3=s; &#125; &#125; &#125; return singletonDemo3; &#125;&#125; 4.静态内部类1234567891011121314151617181920212223242526272829package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * 静态内部类实现单例模式 * 线程安全，调用效率高，延迟加载 * * 在加载SingletonDemo4时，不会加载SingletonClassInstance， * 、当使用到才会加载，所以是延迟加载 */public class SingletonDemo4 &#123; //实例内部类，但没有用到时，内部类是不会加载的，即不会创建 instance private static class SingletonClassInstance &#123;// 保证线程安全 private static final SingletonDemo4 instance = new SingletonDemo4(); &#125; //调用这个方法，用到了静态的内部类才会加载这个类，并初始化 instance public static SingletonDemo4 getSingletonDemo4() &#123; return SingletonClassInstance.instance; &#125; private SingletonDemo4() &#123; &#125;&#125; 5.枚举类型1234567891011121314151617181920212223package com.xiaoqiang.gof23.createModel.singleton;/** * @author xiaoqiang * @date $(DATE)-$(TIME) * 枚举实现单例 * 枚举本身就是单例，简单，避免反射和反序列化漏洞来创建对象 * 没有懒（延迟）加载 */public enum SingletonDemo5 &#123; /** * 定义一个枚举元素，它就代表一个单例 * */ INSTANCE; /** * 单例有自己的操作 */ public void singletonOperation() &#123; /**功能处理*/ &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://cxqiang.gitee.io/blog/tags/设计模式/"}]},{"title":"markdown语法和Typora软件的使用","date":"2019-08-28T02:46:50.000Z","path":"2019/08/28/markdown-use/","text":"markdown常用语法中间用空格隔开 1.标题123456# 一级标题## 二级标题### 三级标题#### 四季标题##### 五级标题###### 六级标题 对应的Typora快捷键 Ctrl + 1 2 3 4 5 6 2.分割线12---*** 3.列表 无序列表 ：- + * 有序列表 : 数字 + . + 空格 4.引用&gt; 这就是引用 &gt; &gt; 可以引用其他的文章5.图片与链接 图片语法： ![图片文本][图片地址链接] 链接语法： [百度](www.baidu.com) 示例：百度 6.粗体与斜体 粗体语法 **我是粗体** 斜体语法 *我是斜体* 粗体加斜体 ***我是粗体加斜体*** 7.删除线，使用~~包裹文字 删除线 ~~删除线~~ 8.代码块- 行内代码块 使用``括起来 - 不同语言的代码块 ```加上语言9.表格​ 表格主要用到的符号有 | - : ​ | 表格 | 怎么用 | ​ Typora 右键可以插入行列","tags":[{"name":"markdown","slug":"markdown","permalink":"http://cxqiang.gitee.io/blog/tags/markdown/"}]},{"title":"test","date":"2019-08-27T09:23:10.000Z","path":"2019/08/27/test/","text":"test 测试一下","tags":[]},{"title":"Hello World","date":"2019-08-27T08:22:31.623Z","path":"2019/08/27/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]